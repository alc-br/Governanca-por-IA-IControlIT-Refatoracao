# RF045 - Gest√£o de Volumetria

**Fase:** Fase-2-Servicos-Essenciais
**EPIC:** EPIC003-GES-Gestao
**Requisito Funcional:** RF045
**Prioridade:** M√âDIA
**Complexidade:** ALTA
**Vers√£o:** 1.0
**Data:** 2025-01-14

---

## SE√á√ÉO 1 - VIS√ÉO GERAL

### 1.1 Descri√ß√£o Geral

O **RF045 - Gest√£o de Volumetria** implementa um sistema completo de monitoramento, an√°lise e previs√£o de consumo de recursos computacionais e tr√°fego de dados do sistema IControlIT. Permite acompanhar em tempo real o volume de dados trafegados, armazenados e processados, com an√°lise de tend√™ncias, previs√£o de capacidade e alertas de sobrecarga.

Este RF centraliza a intelig√™ncia de capacidade e performance, oferecendo:
- Monitoramento real-time de tr√°fego de dados (upload/download)
- An√°lise de consumo por fornecedor, usu√°rio, servi√ßo e per√≠odo
- Previs√£o de capacidade com machine learning (Azure ML)
- Alertas autom√°ticos de limite de volume e tend√™ncia de esgotamento
- Dashboards visuais de volumetria com heatmaps e gr√°ficos temporais
- Otimiza√ß√£o de custos de infraestrutura baseada em dados
- Relat√≥rios de conformidade com SLA de performance
- Hist√≥rico de 7 anos para an√°lise de crescimento

### 1.2 Import√¢ncia Estrat√©gica

**Benef√≠cios para o Neg√≥cio:**
- **Previsibilidade de Capacidade:** Planejamento antecipado de upgrade de infraestrutura evitando indisponibilidades
- **Otimiza√ß√£o de Custos:** Identifica√ß√£o de desperd√≠cios e right-sizing de recursos (30-40% de economia)
- **SLA de Performance:** Garantia de tempo de resposta adequado mesmo em picos de uso
- **Conformidade Regulat√≥ria:** Rastreabilidade de uso de dados conforme LGPD/GDPR
- **Detec√ß√£o de Anomalias:** Identifica√ß√£o precoce de ataques DDoS, loops infinitos ou vazamentos de dados

**Impacto Operacional:**
- Redu√ß√£o de 80% em incidentes de sobrecarga n√£o planejada
- Previs√£o de necessidade de expans√£o com 90 dias de anteced√™ncia
- Identifica√ß√£o de 95% dos gargalos de performance em 24h
- Economia de 35% em custos de storage com pol√≠ticas de reten√ß√£o inteligentes
- Tempo m√©dio de an√°lise de causa-raiz reduzido de 4h para 15min

### 1.3 Sistema Legado vs Modernizado

#### Sistema Legado (ASP.NET Web Forms)

**Limita√ß√µes Cr√≠ticas:**
- ‚ùå Monitoramento manual via logs do IIS (sem agrega√ß√£o)
- ‚ùå Sem rastreamento de volume por fornecedor/usu√°rio
- ‚ùå Relat√≥rios retroativos limitados a 30 dias
- ‚ùå Alertas reativos (s√≥ ap√≥s problema acontecer)
- ‚ùå Sem previs√£o de capacidade ou tend√™ncias
- ‚ùå An√°lise de storage manual via queries SQL ad-hoc
- ‚ùå Performance degradada com consultas de volumetria
- ‚ùå Sem integra√ß√£o com ferramentas de monitoramento (Grafana, Prometheus)

**Problemas Recorrentes:**
- Sobrecarga n√£o detectada at√© usu√°rios reclamarem
- Banco de dados crescendo sem controle (100GB+ sem limpeza)
- Custos de storage cloud aumentando 200% ao ano sem visibilidade
- Imposs√≠vel identificar qual cliente/servi√ßo gera mais tr√°fego

**Arquivos Legados Principais:**
```
ic1_legado/IControlIT/
‚îú‚îÄ‚îÄ Admin/
‚îÇ   ‚îî‚îÄ‚îÄ LogsIIS.aspx (visualiza√ß√£o b√°sica de logs)
‚îú‚îÄ‚îÄ Relatorios/
‚îÇ   ‚îî‚îÄ‚îÄ ConsumoMensal.aspx (relat√≥rio est√°tico)
‚îî‚îÄ‚îÄ App_Code/
    ‚îî‚îÄ‚îÄ Helpers/VolumetriaHelper.vb (queries lentas)
```

#### Sistema Modernizado (.NET 10 + Angular 19)

**Melhorias Implementadas:**
- ‚úÖ **Coleta Autom√°tica em Real-Time:** Middleware que captura todo request/response (tamanho, tempo)
- ‚úÖ **Agrega√ß√£o Inteligente:** Rollup autom√°tico de minutely ‚Üí hourly ‚Üí daily ‚Üí monthly
- ‚úÖ **Machine Learning Predictivo:** Azure ML para forecast de 30/60/90 dias
- ‚úÖ **Alertas Proativos:** Notifica√ß√£o 7 dias antes de atingir limite
- ‚úÖ **Dashboard Visual:** ApexCharts com heatmaps de uso por hora/dia
- ‚úÖ **Multi-Tenancy:** Volumetria isolada por fornecedor com billing granular
- ‚úÖ **Exporta√ß√£o para FinOps:** Integra√ß√£o com Azure Cost Management
- ‚úÖ **Performance Otimizada:** Particionamento de tabelas + √≠ndices columnstore
- ‚úÖ **Reten√ß√£o Inteligente:** Arquivamento autom√°tico de dados antigos em cold storage

**Arquitetura Clean + CQRS:**
```
backend/IControlIT.API/src/
‚îú‚îÄ‚îÄ Domain/Entities/
‚îÇ   ‚îú‚îÄ‚îÄ VolumetriaConsumo.cs (consumo por per√≠odo)
‚îÇ   ‚îú‚îÄ‚îÄ VolumetriaAgregada.cs (rollups otimizados)
‚îÇ   ‚îú‚îÄ‚îÄ VolumetriaLimite.cs (quotas por fornecedor)
‚îÇ   ‚îî‚îÄ‚îÄ VolumetriaAlerta.cs (configura√ß√£o de alertas)
‚îú‚îÄ‚îÄ Application/
‚îÇ   ‚îú‚îÄ‚îÄ Volumetria/Commands/ (processar, agregar)
‚îÇ   ‚îú‚îÄ‚îÄ Volumetria/Queries/ (consultas otimizadas)
‚îÇ   ‚îî‚îÄ‚îÄ Volumetria/Services/
‚îÇ       ‚îú‚îÄ‚îÄ VolumetriaCollectorService.cs (coleta via middleware)
‚îÇ       ‚îú‚îÄ‚îÄ VolumetriaAggregationService.cs (rollups)
‚îÇ       ‚îî‚îÄ‚îÄ VolumetriaPredictionService.cs (Azure ML)
‚îú‚îÄ‚îÄ Infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/VolumetriaMiddleware.cs
‚îÇ   ‚îî‚îÄ‚îÄ BackgroundJobs/VolumetriaAggregationJob.cs (Hangfire)
‚îî‚îÄ‚îÄ Web/Endpoints/VolumetriaEndpoints.cs

frontend/icontrolit-app/src/app/modules/gestao/volumetria/
‚îú‚îÄ‚îÄ dashboard/ (vis√£o geral com gr√°ficos)
‚îú‚îÄ‚îÄ detalhes/ (drill-down por servi√ßo/usu√°rio)
‚îú‚îÄ‚îÄ limites/ (configura√ß√£o de quotas)
‚îî‚îÄ‚îÄ services/volumetria.service.ts
```

### 1.4 Funcionalidades Principais

#### 1.4.1 Coleta Autom√°tica de Volumetria

**Middleware de Captura:**
```csharp
public class VolumetriaMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        var originalBodyStream = context.Response.Body;

        using var responseBody = new MemoryStream();
        context.Response.Body = responseBody;

        await _next(context);

        stopwatch.Stop();

        // Captura m√©tricas
        var volumetria = new VolumetriaConsumo
        {
            FornecedorId = context.User.GetFornecedorId(),
            UsuarioId = context.User.GetUserId(),
            Endpoint = context.Request.Path,
            Metodo = context.Request.Method,
            BytesRequest = context.Request.ContentLength ?? 0,
            BytesResponse = responseBody.Length,
            TempoResposta = stopwatch.ElapsedMilliseconds,
            StatusCode = context.Response.StatusCode,
            Timestamp = DateTime.UtcNow
        };

        // Enfileira para processamento ass√≠ncrono (n√£o bloqueia request)
        await _volumetriaQueue.EnqueueAsync(volumetria);

        await responseBody.CopyToAsync(originalBodyStream);
    }
}
```

**Dados Capturados por Request:**
- Endpoint acessado (`/api/faturas`, `/api/relatorios/export`)
- M√©todo HTTP (GET, POST, PUT, DELETE)
- Tamanho request (bytes)
- Tamanho response (bytes)
- Tempo de resposta (ms)
- Status code (200, 400, 500)
- Fornecedor e usu√°rio
- IP de origem
- User-Agent (browser/app)

#### 1.4.2 Agrega√ß√£o e Rollups

**Hierarquia de Agrega√ß√£o:**
```
Raw Data (1min granularity, 7 dias)
‚îú‚îÄ‚îÄ Hourly Rollup (1h granularity, 90 dias)
‚îÇ   ‚îú‚îÄ‚îÄ Daily Rollup (1 dia granularity, 2 anos)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Monthly Rollup (1 m√™s granularity, 7 anos)
```

**Hangfire Job - Agrega√ß√£o Autom√°tica:**
```csharp
[AutomaticRetry(Attempts = 3)]
public class VolumetriaAggregationJob : IJob
{
    // Roda a cada 1h para agregar dados da √∫ltima hora
    public async Task Execute()
    {
        var dataHora = DateTime.UtcNow.AddHours(-1);

        // Agrega minutely ‚Üí hourly
        var hourlyData = await _context.VolumetriaConsumo
            .Where(v => v.Timestamp >= dataHora && v.Timestamp < dataHora.AddHours(1))
            .GroupBy(v => new {
                v.FornecedorId,
                v.Endpoint,
                Hora = v.Timestamp.Hour
            })
            .Select(g => new VolumetriaAgregada
            {
                FornecedorId = g.Key.FornecedorId,
                Endpoint = g.Key.Endpoint,
                Periodo = "HOURLY",
                DataHora = dataHora,
                TotalRequests = g.Count(),
                TotalBytesRequest = g.Sum(v => v.BytesRequest),
                TotalBytesResponse = g.Sum(v => v.BytesResponse),
                TempoRespostaMedia = g.Average(v => v.TempoResposta),
                TempoRespostaP95 = g.OrderBy(v => v.TempoResposta).Skip((int)(g.Count() * 0.95)).FirstOrDefault().TempoResposta
            })
            .ToListAsync();

        await _context.VolumetriaAgregada.AddRangeAsync(hourlyData);
        await _context.SaveChangesAsync();

        // Deleta dados raw ap√≥s agrega√ß√£o (economia de storage)
        await _context.VolumetriaConsumo
            .Where(v => v.Timestamp < dataHora.AddDays(-7))
            .ExecuteDeleteAsync();
    }
}
```

**M√©tricas Agregadas:**
- Total de requests
- Total de bytes enviados (upload)
- Total de bytes recebidos (download)
- Tempo m√©dio de resposta
- Tempo P95/P99 (percentis)
- Taxa de erro (4xx, 5xx)
- Requests por segundo (RPS)

#### 1.4.3 Limites e Quotas por Fornecedor

**Configura√ß√£o de Limites:**
```typescript
interface VolumetriaLimite {
  fornecedorId: string;
  tipoLimite: 'MENSAL' | 'DIARIO' | 'HORARIO';
  limiteBytesTotal: number; // Ex: 100GB/m√™s
  limiteRequests: number; // Ex: 1M requests/m√™s
  limiteStorage: number; // Ex: 50GB armazenados
  acaoAoExceder: 'ALERTAR' | 'BLOQUEAR' | 'THROTTLE';
  percentualAlerta: number; // Ex: 80% (alerta antes de estourar)
}
```

**Exemplo de Quotas:**
```
Fornecedor A (Plano Premium):
‚îú‚îÄ‚îÄ 500 GB tr√°fego/m√™s
‚îú‚îÄ‚îÄ 5M requests/m√™s
‚îú‚îÄ‚îÄ 200 GB storage
‚îî‚îÄ‚îÄ A√ß√£o: ALERTAR a 80%, THROTTLE a 95%

Fornecedor B (Plano Basic):
‚îú‚îÄ‚îÄ 50 GB tr√°fego/m√™s
‚îú‚îÄ‚îÄ 500K requests/m√™s
‚îú‚îÄ‚îÄ 20 GB storage
‚îî‚îÄ‚îÄ A√ß√£o: ALERTAR a 80%, BLOQUEAR a 100%
```

**Enforcement em Real-Time:**
```csharp
public class VolumetriaQuotaService
{
    public async Task<bool> CheckQuota(Guid fornecedorId)
    {
        var limite = await GetLimite(fornecedorId);
        var consumoMes = await GetConsumoMesAtual(fornecedorId);

        var percentualUsado = (consumoMes.TotalBytes / limite.LimiteBytesTotal) * 100;

        if (percentualUsado >= limite.PercentualAlerta)
        {
            await _alertService.NotifyAsync($"Fornecedor {fornecedorId} atingiu {percentualUsado}% da quota");
        }

        if (percentualUsado >= 100)
        {
            return limite.AcaoAoExceder switch
            {
                "BLOQUEAR" => false, // Bloqueia request
                "THROTTLE" => await ApplyRateLimit(fornecedorId), // Rate limit agressivo
                _ => true // Apenas alerta, permite
            };
        }

        return true;
    }
}
```

#### 1.4.4 An√°lise de Tend√™ncias e Previs√£o

**Machine Learning com Azure ML:**
```csharp
public class VolumetriaPredictionService
{
    public async Task<VolumetriaForecast> PredictNextMonths(Guid fornecedorId, int meses)
    {
        // Busca hist√≥rico de 12 meses
        var historico = await _context.VolumetriaAgregada
            .Where(v => v.FornecedorId == fornecedorId && v.Periodo == "MONTHLY")
            .OrderBy(v => v.DataHora)
            .Take(12)
            .ToListAsync();

        // Chama Azure ML endpoint
        var request = new
        {
            data = historico.Select(h => new[] { h.DataHora.ToOADate(), (double)h.TotalBytes })
        };

        var response = await _httpClient.PostAsJsonAsync(_azureMLEndpoint, request);
        var forecast = await response.Content.ReadFromJsonAsync<ForecastResponse>();

        return new VolumetriaForecast
        {
            PrevisaoProximoMes = forecast.Predictions[0],
            PrevisaoProximos3Meses = forecast.Predictions.Take(3).Sum(),
            IntervaloConfianca95 = forecast.ConfidenceInterval,
            Tendencia = forecast.Trend, // CRESCENTE, ESTAVEL, DECRESCENTE
            ProbabilidadeExcederQuota = CalculateProbability(forecast, quota)
        };
    }
}
```

**Visualiza√ß√£o de Forecast:**
- Gr√°fico de linha com valores hist√≥ricos + previs√£o
- Banda de confian√ßa (95%) em √°rea sombreada
- Linha de limite/quota para compara√ß√£o
- Alertas visuais se previs√£o ultrapassar limite

#### 1.4.5 Dashboards de Volumetria

**Dashboard Executivo:**
- **Card Resumo:** Total trafegado no m√™s (GB), % da quota, tend√™ncia
- **Gr√°fico Temporal:** Evolu√ß√£o di√°ria de consumo (√∫ltimos 30 dias)
- **Heatmap de Uso:** Consumo por hora do dia e dia da semana (identificar picos)
- **Top 10 Endpoints:** Endpoints que mais consomem banda
- **Top 10 Usu√°rios:** Usu√°rios que mais geram tr√°fego
- **Distribui√ß√£o por Tipo:** GET (leitura) vs POST (escrita)

**Dashboard T√©cnico:**
- **Lat√™ncia P95/P99:** Tempo de resposta por endpoint
- **Taxa de Erro:** % de requests 4xx e 5xx
- **Requests por Segundo:** RPS em tempo real
- **Storage por Tabela:** Crescimento de cada tabela do banco
- **Cache Hit Rate:** Efici√™ncia de cache (Redis)

**Heatmap Interativo:**
```
        | Seg  | Ter  | Qua  | Thu  | Sex  | Sab  | Dom
  00:00 |  üü¢  |  üü¢  |  üü¢  |  üü¢  |  üü¢  |  üü¢  |  üü¢  (baixo)
  06:00 |  üü°  |  üü°  |  üü°  |  üü°  |  üü°  |  üü¢  |  üü¢  (m√©dio)
  12:00 |  üî¥  |  üî¥  |  üî¥  |  üî¥  |  üî¥  |  üü°  |  üü°  (alto)
  18:00 |  üü°  |  üü°  |  üü°  |  üü°  |  üü°  |  üü¢  |  üü¢  (m√©dio)
```

#### 1.4.6 Alertas Autom√°ticos

**Tipos de Alertas:**
1. **Quota Atingida:** 80%, 90%, 95%, 100% do limite mensal
2. **Crescimento Anormal:** Aumento > 50% vs m√©dia de 7 dias
3. **Previs√£o de Esgotamento:** Vai atingir 100% em X dias
4. **Lat√™ncia Elevada:** P95 > 2s (degrada√ß√£o de performance)
5. **Taxa de Erro Alta:** > 5% de requests com 5xx
6. **Storage Cr√≠tico:** Banco > 80% da capacidade

**Configura√ß√£o:**
```typescript
interface VolumetriaAlerta {
  id: string;
  fornecedorId: string;
  tipo: 'QUOTA' | 'CRESCIMENTO' | 'PREVISAO' | 'LATENCIA' | 'ERRO' | 'STORAGE';
  threshold: number;
  unidade: 'BYTES' | 'REQUESTS' | 'PERCENT' | 'MILLISECONDS';
  periodo: 'HORARIO' | 'DIARIO' | 'SEMANAL' | 'MENSAL';
  destinatarios: string[]; // e-mails
  canais: ('EMAIL' | 'SMS' | 'WEBHOOK')[];
  ativo: boolean;
}
```

**Exemplo de Alerta:**
```
üîî ALERTA: Quota Mensal Atingida (85%)

Fornecedor: ACME Corp
Consumo Atual: 425 GB de 500 GB (85%)
Dias Restantes: 8 dias
Previs√£o de Esgotamento: 5 dias (23/01)

A√ß√£o Recomendada:
- Revisar endpoints com maior consumo
- Considerar upgrade de plano
- Implementar caching agressivo

Top 3 Endpoints:
1. /api/relatorios/export - 120 GB (28%)
2. /api/faturas/pdf - 85 GB (20%)
3. /api/dashboard/data - 60 GB (14%)
```

#### 1.4.7 Otimiza√ß√£o e Recomenda√ß√µes

**An√°lise Autom√°tica:**
- Endpoints com baixo cache hit rate ‚Üí Sugest√£o de implementar cache
- Queries lentas (> 1s) ‚Üí Sugest√£o de otimizar √≠ndices
- Tabelas com crescimento exponencial ‚Üí Sugest√£o de arquivamento
- Hor√°rios de pico consistentes ‚Üí Sugest√£o de auto-scaling

**Relat√≥rio Mensal de FinOps:**
```markdown
# Relat√≥rio de Volumetria e Custos - Janeiro/2025

## Resumo Executivo
- **Consumo Total:** 450 GB (90% da quota)
- **Custo Estimado:** R$ 2.250 (Azure egress + storage)
- **Economia Potencial:** R$ 675 (30%) com otimiza√ß√µes

## Oportunidades de Otimiza√ß√£o

### 1. Implementar CDN para Assets Est√°ticos (Economia: R$ 300/m√™s)
- 120 GB de arquivos PDF/imagens servidos diretamente do backend
- Sugest√£o: Mover para Azure CDN (90% mais barato)

### 2. Arquivar Dados Antigos para Cold Storage (Economia: R$ 250/m√™s)
- 80 GB de dados > 2 anos em hot storage
- Sugest√£o: Migrar para Azure Cool/Archive (95% mais barato)

### 3. Otimizar Endpoint /api/relatorios/export (Economia: R$ 125/m√™s)
- 45% dos requests retornam dados id√™nticos (cacheable)
- Sugest√£o: Implementar cache de 15min (reduz 80% do tr√°fego)
```

---

## SE√á√ÉO 2 - REGRAS DE NEG√ìCIO

### RN001 - Granularidade de Coleta por Tipo de Dado

**Descri√ß√£o:**
Dados raw s√£o coletados a cada request (granularidade de 1 segundo), mas armazenados apenas por 7 dias. Agrega√ß√µes hor√°rias ficam 90 dias, di√°rias 2 anos, mensais 7 anos.

**Justificativa:**
Balanceia necessidade de an√°lise detalhada com custo de storage. 99% das an√°lises usam dados agregados.

**Implementa√ß√£o:**
- Middleware captura todos os requests
- Hangfire job agrega e deleta dados antigos
- Particionamento de tabelas por per√≠odo

**Exemplo:**
```
Raw (1s): 15/01 14:35:23 ‚Üí Mantido at√© 22/01
Hourly: 15/01 14:00 ‚Üí Mantido at√© 15/04
Daily: 15/01 ‚Üí Mantido at√© 15/01/2027
Monthly: 01/2025 ‚Üí Mantido at√© 01/2032
```

---

### RN002 - Quota Mensal por Fornecedor Obrigat√≥ria

**Descri√ß√£o:**
Todo fornecedor deve ter uma quota mensal configurada (GB de tr√°fego + n√∫mero de requests). Sem quota = ilimitado apenas para Super Admin.

**Justificativa:**
Evita abuso de recursos e permite billing justo. Protege infraestrutura de sobrecargas.

**Implementa√ß√£o:**
- Valida√ß√£o em `CreateFornecedorCommandHandler`
- Default: 50GB/500K requests para novos fornecedores
- Middleware verifica quota antes de processar request

**Exemplo:**
```csharp
// ‚úÖ V√°lido
new VolumetriaLimite {
    FornecedorId = guid,
    LimiteBytesTotal = 50_000_000_000, // 50GB
    LimiteRequests = 500_000
}

// ‚ùå Inv√°lido (sem quota e n√£o √© Super Admin)
new Fornecedor { Quota = null } ‚Üí Erro!
```

---

### RN003 - Alerta em 80% da Quota (7 Dias Antes)

**Descri√ß√£o:**
Sistema deve alertar automaticamente quando fornecedor atingir 80% da quota mensal ou quando previs√£o indicar esgotamento em 7 dias.

**Justificativa:**
Permite a√ß√£o proativa (upgrade de plano, otimiza√ß√£o) antes de bloquear servi√ßo.

**Implementa√ß√£o:**
- Hangfire job verifica quotas a cada 1h
- Azure ML calcula previs√£o de esgotamento
- Notifica√ß√£o via e-mail + in-app

**Exemplo:**
```
Dia 10: Consumo 40 GB de 50 GB (80%) ‚Üí üîî Alerta
Dia 15: Previs√£o indica 50 GB em 7 dias ‚Üí üîî Alerta
Dia 22: Atingiu 50 GB (100%) ‚Üí üîî Alerta cr√≠tico
```

---

### RN004 - Throttling Progressivo (95%-99%-100%)

**Descri√ß√£o:**
Ao atingir 95% da quota, sistema aplica rate limit de 50%. A 99%, rate limit de 80%. A 100%, bloqueia novos requests (apenas leitura permitida).

**Justificativa:**
Degrada servi√ßo gradualmente ao inv√©s de bloqueio abrupto. Permite finalizar opera√ß√µes cr√≠ticas.

**Implementa√ß√£o:**
- Middleware `VolumetriaQuotaMiddleware`
- Rate limiting com ASP.NET Core RateLimiter
- Exce√ß√£o: endpoints de leitura (`GET`) sempre permitidos

**Exemplo:**
```
95%-98%: Rate limit 10 requests/min (normal: 100/min)
99%-99.9%: Rate limit 5 requests/min
100%+: Apenas GET permitido, POST/PUT/DELETE = 429 Too Many Requests
```

---

### RN005 - Separa√ß√£o de Volumetria por Fornecedor (Multi-Tenancy)

**Descri√ß√£o:**
Volumetria de um fornecedor n√£o pode afetar outro. Quotas, limites e billing s√£o completamente isolados.

**Justificativa:**
Fair usage e isolamento de recursos. Evita "noisy neighbor problem".

**Implementa√ß√£o:**
- Coluna `FornecedorId` em todas as tabelas de volumetria
- √çndices particionados por fornecedor
- Queries sempre filtram por `FornecedorId`

**Exemplo:**
```sql
-- ‚úÖ Correto (sempre filtra por fornecedor)
SELECT SUM(TotalBytes)
FROM VolumetriaAgregada
WHERE FornecedorId = @fornecedorId
  AND DataHora >= @inicio

-- ‚ùå Errado (agrega√ß√£o global)
SELECT SUM(TotalBytes)
FROM VolumetriaAgregada
```

---

### RN006 - Exclus√£o de Volumetria de Health Checks

**Descri√ß√£o:**
Requests de health check (`/health`, `/ping`) n√£o devem contar para quota de volumetria.

**Justificativa:**
Health checks s√£o infraestrutura, n√£o uso real. Evita consumo artificial de quota.

**Implementa√ß√£o:**
- Lista de endpoints exclu√≠dos em configura√ß√£o
- Middleware ignora paths matching regex `^/(health|ping|metrics)`

**Exemplo:**
```csharp
// Exclu√≠dos da volumetria:
/health
/health/ready
/health/live
/ping
/metrics

// Inclu√≠dos na volumetria:
/api/faturas ‚úÖ
/api/relatorios/export ‚úÖ
```

---

### RN007 - Detec√ß√£o de Anomalias (2x M√©dia de 7 Dias)

**Descri√ß√£o:**
Se consumo de um dia ultrapassar 2x a m√©dia dos √∫ltimos 7 dias, dispara alerta de anomalia.

**Justificativa:**
Detecta comportamento at√≠pico que pode indicar ataque, bug ou uso indevido.

**Implementa√ß√£o:**
- Hangfire job calcula m√©dia m√≥vel de 7 dias
- Compara consumo do dia com 2x a m√©dia
- Alerta com severidade ALTA

**Exemplo:**
```
M√©dia 7d: 10 GB/dia
Dia atual: 25 GB ‚Üí 2.5x m√©dia ‚Üí üîî Anomalia detectada!

Poss√≠veis causas sugeridas:
- Exporta√ß√£o massiva de relat√≥rios
- Loop infinito em integra√ß√£o
- Ataque DDoS
```

---

### RN008 - Rollup Autom√°tico Irrevers√≠vel

**Descri√ß√£o:**
Ap√≥s agrega√ß√£o de dados raw para hourly/daily/monthly, dados originais s√£o deletados permanentemente (economia de storage).

**Justificativa:**
Dados agregados s√£o suficientes para 99% das an√°lises. Manter raw √© desperd√≠cio de 95% do storage.

**Implementa√ß√£o:**
- Hangfire job `VolumetriaAggregationJob`
- Delete em batch (100K registros por vez)
- Log de agrega√ß√£o para auditoria

**Exemplo:**
```
Raw data 08/01: 10 milh√µes de registros (5 GB)
‚Üì Agrega√ß√£o para hourly
Hourly data 08/01: 24 registros (1 MB)
‚Üì Deleta raw
Storage economizado: 4.999 GB (99.98%)
```

---

### RN009 - Billing Proporcional por Per√≠odo Parcial

**Descri√ß√£o:**
Se fornecedor for criado no meio do m√™s, quota √© proporcional aos dias restantes. Ex: criado dia 15 de 30 = 50% da quota mensal.

**Justificativa:**
Cobran√ßa justa apenas pelo per√≠odo de uso efetivo.

**Implementa√ß√£o:**
- C√°lculo em `VolumetriaQuotaService.CalculateProportionalQuota()`
- F√≥rmula: `quotaMensal * (diasRestantes / diasTotaisMes)`

**Exemplo:**
```
Quota mensal: 100 GB
Criado em: 15/01 (30 dias no m√™s)
Dias restantes: 16 dias
Quota proporcional: 100 * (16/30) = 53.3 GB
```

---

### RN010 - Forecast Apenas com 3+ Meses de Hist√≥rico

**Descri√ß√£o:**
Previs√£o de consumo s√≥ √© gerada se fornecedor tiver pelo menos 3 meses de hist√≥rico. Caso contr√°rio, usa m√©dia simples.

**Justificativa:**
Machine learning precisa de dados suficientes para ser confi√°vel. Com < 3 meses, previs√£o seria imprecisa.

**Implementa√ß√£o:**
- Verifica√ß√£o em `VolumetriaPredictionService`
- Fallback para m√©dia simples se hist√≥rico insuficiente

**Exemplo:**
```csharp
if (historicoMeses.Count < 3)
{
    return new Forecast {
        Metodo = "MEDIA_SIMPLES",
        Previsao = historicoMeses.Average(h => h.TotalBytes)
    };
}
else
{
    return await AzureML.Predict(historicoMeses); // Machine learning
}
```

---

### RN011 - Exporta√ß√£o de Dados Limitada a 1 GB por Request

**Descri√ß√£o:**
Endpoints de exporta√ß√£o (`/api/*/export`) s√≥ podem retornar at√© 1 GB por request. Exporta√ß√µes maiores devem usar pagina√ß√£o ou background job.

**Justificativa:**
Evita timeout e consumo excessivo de mem√≥ria. Protege contra DoS acidental.

**Implementa√ß√£o:**
- Valida√ß√£o em `ExportQueryHandler`
- Se dataset > 1 GB, retorna 413 Payload Too Large
- Sugere usar background job ass√≠ncrono

**Exemplo:**
```
Exporta√ß√£o: 5.000 faturas = 200 MB ‚Üí ‚úÖ OK
Exporta√ß√£o: 500.000 faturas = 2 GB ‚Üí ‚ùå 413 Payload Too Large

Sugest√£o: Use POST /api/export/async para gerar arquivo em background
```

---

### RN012 - Cache Agressivo para Endpoints de Leitura

**Descri√ß√£o:**
Endpoints `GET` de dados est√°ticos devem ter cache de 15min. Reduz volumetria em 60-80% sem impacto na experi√™ncia.

**Justificativa:**
Maioria dos requests s√£o leituras id√™nticas. Cache reduz tr√°fego, lat√™ncia e custos.

**Implementa√ß√£o:**
- Response caching middleware
- Redis para cache distribu√≠do
- Header `Cache-Control: public, max-age=900`

**Exemplo:**
```
Sem cache:
10.000 requests/dia ao /api/dashboard/kpis
= 10.000 queries ao banco
= 5 GB tr√°fego

Com cache de 15min:
10.000 requests/dia
= 96 queries ao banco (15min * 96 = 24h)
= 0.5 GB tr√°fego (90% redu√ß√£o)
```

---

### RN013 - Reten√ß√£o de 7 Anos para Conformidade LGPD

**Descri√ß√£o:**
Dados agregados mensais devem ser mantidos por 7 anos para auditoria fiscal e conformidade com LGPD.

**Justificativa:**
Legisla√ß√£o brasileira exige reten√ß√£o de 7 anos para dados financeiros/fiscais.

**Implementa√ß√£o:**
- Particionamento anual de tabela `VolumetriaAgregada`
- Ap√≥s 7 anos, arquiva em Azure Blob (cold storage)

**Exemplo:**
```sql
VolumetriaAgregada_2025 (hot storage - Azure SQL)
VolumetriaAgregada_2024 (hot storage)
...
VolumetriaAgregada_2019 (cold storage - Azure Blob)
VolumetriaAgregada_2018 (deletado ap√≥s 7 anos)
```

---

### RN014 - Drill-Down at√© Request Individual (7 Dias)

**Descri√ß√£o:**
Usu√°rio pode fazer drill-down de qualquer m√©trica agregada at√© o request individual, mas apenas dos √∫ltimos 7 dias (dados raw).

**Justificativa:**
Permite investiga√ß√£o detalhada de problemas recentes. Ap√≥s 7 dias, apenas dados agregados dispon√≠veis.

**Implementa√ß√£o:**
- Link "Ver detalhes" em dashboard
- Query em `VolumetriaConsumo` se < 7 dias
- Query em `VolumetriaAgregada` se > 7 dias

**Exemplo:**
```
Dashboard: "Endpoint /api/faturas consumiu 50 GB em Janeiro"
‚Üì Click drill-down
Lista: Agregado por dia (31 registros)
‚Üì Click em "15/01" (< 7 dias)
Lista: 10.000 requests individuais com timestamp, usu√°rio, tamanho
‚Üì Click em "08/01" (> 7 dias)
Mensagem: "Dados detalhados n√£o dispon√≠veis (> 7 dias). Apenas agregado por hora."
```

---

### RN015 - Notifica√ß√£o Semanal de Resumo para Administradores

**Descri√ß√£o:**
Todo domingo √†s 23h, sistema envia e-mail autom√°tico para administradores com resumo semanal de volumetria e anomalias.

**Justificativa:**
Mant√©m equipe informada de forma proativa. Identifica tend√™ncias antes de virarem problemas.

**Implementa√ß√£o:**
- Hangfire job recorrente `VolumetriaWeeklySummaryJob`
- Template de e-mail HTML com gr√°ficos embedded
- Destinat√°rios: perfil "Administrador" + "Gestor"

**Exemplo de E-mail:**
```
üìä Resumo Semanal de Volumetria (08/01 - 14/01/2025)

‚úÖ Tudo sob controle:
- Consumo total: 92 GB (18% da quota mensal)
- Lat√™ncia m√©dia: 250ms (-15% vs semana anterior)
- Taxa de erro: 0.3% (dentro do SLA)

‚ö†Ô∏è Pontos de aten√ß√£o:
- Fornecedor ACME Corp: 85% da quota (alerta acionado)
- Endpoint /api/relatorios/export: +40% de uso (investigar)

üìà Tend√™ncias:
- Crescimento semanal: +8% (esperado 10% por sazonalidade)
- Previs√£o de fim do m√™s: 450 GB (90% da quota)
```

---

## SE√á√ÉO 3 - REFER√äNCIAS AO LEGADO

### 3.1 P√°ginas ASPX Relacionadas

```
ic1_legado/IControlIT/Admin/
‚îú‚îÄ‚îÄ LogsIIS.aspx
‚îÇ   ‚îî‚îÄ‚îÄ Visualiza√ß√£o de logs do IIS (txt raw)
‚îÇ   ‚îî‚îÄ‚îÄ Sem agrega√ß√£o ou filtros
‚îÇ   ‚îî‚îÄ‚îÄ Limitado a 1.000 linhas por performance
‚îÇ
‚îî‚îÄ‚îÄ Relatorios/
    ‚îî‚îÄ‚îÄ ConsumoMensal.aspx
        ‚îî‚îÄ‚îÄ Query manual de tamanho de tabelas
        ‚îî‚îÄ‚îÄ Exporta√ß√£o Excel b√°sica
        ‚îî‚îÄ‚îÄ Sem an√°lise de tend√™ncias
```

### 3.2 Code-Behind VB.NET

```vb
' VolumetriaHelper.vb (queries lentas sem otimiza√ß√£o)
Public Class VolumetriaHelper
    Public Shared Function GetConsumoMensal(mes As Integer, ano As Integer) As DataTable
        ' Query sem √≠ndices, trava em tabelas grandes
        Dim sql As String = "
            SELECT
                CAST(Data AS DATE) AS Dia,
                COUNT(*) AS TotalRequests,
                AVG(TempoResposta) AS TempoMedio
            FROM LogAcesso
            WHERE MONTH(Data) = " & mes & "
              AND YEAR(Data) = " & ano & "
            GROUP BY CAST(Data AS DATE)
            ORDER BY Dia
        "
        Return ExecuteQuery(sql)
    End Function

    ' ‚ùå Calcula tamanho de tabelas de forma ineficiente
    Public Shared Function GetTamanhoTabelas() As List(Of TamanhoTabela)
        Dim resultado As New List(Of TamanhoTabela)

        For Each tabela In GetAllTables()
            Dim sql = "SELECT COUNT(*) FROM " & tabela.Nome
            Dim rows = ExecuteScalar(sql) ' Lento, usa COUNT(*)

            ' Estima tamanho (impreciso)
            Dim tamanhoEstimado = rows * 1024 ' 1KB por linha (chute)

            resultado.Add(New TamanhoTabela With {
                .Nome = tabela.Nome,
                .Linhas = rows,
                .TamanhoBytes = tamanhoEstimado
            })
        Next

        Return resultado
    End Function
End Class
```

### 3.3 Limita√ß√µes do Legado

**Problemas Identificados:**
1. **Sem Coleta Autom√°tica:** Logs do IIS n√£o capturam tamanho de request/response
2. **Queries Lentas:** COUNT(*) em tabelas de milh√µes de registros trava sistema
3. **Sem Multi-Tenancy:** Imposs√≠vel separar consumo por fornecedor
4. **Sem Agrega√ß√£o:** Dados raw nunca s√£o consolidados (storage infinito)
5. **Sem Alertas:** Problemas s√≥ descobertos quando cliente reclama
6. **Sem Forecast:** Imposs√≠vel prever necessidade de expans√£o

---

## SE√á√ÉO 4 - BANCO DE DADOS LEGADO

### 4.1 Estrutura Original

```sql
-- Tabela de logs (sem otimiza√ß√£o)
CREATE TABLE dbo.LogAcesso (
    Id BIGINT IDENTITY PRIMARY KEY,
    Data DATETIME DEFAULT GETDATE(),
    Endpoint VARCHAR(500),
    UsuarioId INT,
    TempoResposta INT, -- milissegundos
    StatusCode INT
    -- ‚ùå Falta: tamanho request/response, FornecedorId
    -- ‚ùå Falta: √≠ndices por data, endpoint
    -- ‚ùå Falta: particionamento (performance degrada)
)

-- Sem agrega√ß√µes (tudo √© raw data)
-- Sem quotas/limites configur√°veis
-- Sem tabelas de alertas ou previs√µes
```

### 4.2 Query Problem√°tica de Tamanho de Banco

```sql
-- sp_GetDatabaseSize (execu√ß√£o > 5min em bancos grandes)
CREATE PROCEDURE sp_GetDatabaseSize
AS
BEGIN
    -- Loop por todas as tabelas (lento)
    SELECT
        t.NAME AS TableName,
        SUM(a.total_pages) * 8 AS TotalSpaceKB,
        SUM(a.used_pages) * 8 AS UsedSpaceKB,
        (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB
    FROM sys.tables t
    INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id
    INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
    INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id
    WHERE t.is_ms_shipped = 0
    GROUP BY t.Name
    ORDER BY SUM(a.total_pages) DESC
END
```

---

## SE√á√ÉO 5 - INTEGRA√á√ïES OBRIGAT√ìRIAS

### 5.1 Central de Funcionalidades

**Funcionalidades a Registrar:**
```typescript
{
  modulo: 'GESTAO',
  funcionalidades: [
    {
      codigo: 'GES.VOLUMETRIA.DASHBOARD',
      nome: 'Visualizar Dashboard Volumetria',
      descricao: 'Acessar painel de consumo de dados e tr√°fego',
      tipo: 'CONSULTA',
      endpoint: '/api/volumetria/dashboard'
    },
    {
      codigo: 'GES.VOLUMETRIA.DETALHES',
      nome: 'Visualizar Detalhes de Consumo',
      descricao: 'Drill-down at√© requests individuais',
      tipo: 'CONSULTA',
      endpoint: '/api/volumetria/detalhes'
    },
    {
      codigo: 'GES.VOLUMETRIA.LIMITES.CONFIGURAR',
      nome: 'Configurar Quotas',
      descricao: 'Definir limites de consumo por fornecedor',
      tipo: 'ESCRITA',
      endpoint: '/api/volumetria/limites'
    },
    {
      codigo: 'GES.VOLUMETRIA.ALERTAS.CONFIGURAR',
      nome: 'Configurar Alertas',
      descricao: 'Criar alertas de quota e performance',
      tipo: 'ESCRITA',
      endpoint: '/api/volumetria/alertas'
    },
    {
      codigo: 'GES.VOLUMETRIA.EXPORTAR',
      nome: 'Exportar Dados de Volumetria',
      descricao: 'Exportar m√©tricas para an√°lise externa',
      tipo: 'EXPORTACAO',
      endpoint: '/api/volumetria/export'
    }
  ]
}
```

### 5.2 Internacionaliza√ß√£o (i18n)

**Chaves de Tradu√ß√£o:**
```json
{
  "volumetria": {
    "title": "Gest√£o de Volumetria",
    "subtitle": "Monitoramento de consumo e capacidade",
    "dashboard": {
      "consumoMensal": "Consumo Mensal",
      "quotaRestante": "Quota Restante",
      "tendencia": "Tend√™ncia",
      "previsao": "Previs√£o Pr√≥ximo M√™s"
    },
    "limites": {
      "configurar": "Configurar Quotas",
      "mensal": "Limite Mensal",
      "diario": "Limite Di√°rio",
      "acaoExceder": "A√ß√£o ao Exceder"
    },
    "acoes": {
      "ALERTAR": "Apenas Alertar",
      "THROTTLE": "Limitar Taxa",
      "BLOQUEAR": "Bloquear Acesso"
    },
    "messages": {
      "quotaExcedida": "Quota mensal excedida ({percent}%)",
      "alertaEnviado": "Alerta de consumo enviado",
      "limiteAtualizado": "Limite atualizado com sucesso"
    }
  }
}
```

### 5.3 Auditoria

**Opera√ß√µes Auditadas:**
| Opera√ß√£o | Dados Capturados |
|----------|------------------|
| `VOLUMETRIA_QUOTA_EXCEEDED` | FornecedorId, Consumo, Limite, % |
| `VOLUMETRIA_LIMITE_CHANGED` | LimiteAntigo, LimiteNovo, Justificativa |
| `VOLUMETRIA_ALERTA_SENT` | Tipo, Threshold, Destinat√°rios |
| `VOLUMETRIA_ANOMALY_DETECTED` | Consumo, M√©dia7d, Desvio |
| `VOLUMETRIA_DATA_EXPORTED` | Per√≠odo, Formato, Tamanho |

### 5.4 Controle de Acesso (RBAC)

**Matriz de Permiss√µes:**
| Perfil | Dashboard | Detalhes | Config Quotas | Alertas | Exportar |
|--------|-----------|----------|---------------|---------|----------|
| **Super Admin** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Administrador** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Gestor** | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ |
| **Operador** | ‚úÖ | ‚ùå | ‚ùå | ‚ùå | ‚ùå |

---

**FIM DO RF045**

**Estat√≠sticas:**
- **Linhas:** 847 linhas
- **Se√ß√µes:** 5/5 completas ‚úÖ
- **Regras de Neg√≥cio:** 15 regras (RN001-RN015)
- **Integra√ß√µes:** 4/4 obrigat√≥rias ‚úÖ
- **Complexidade:** ALTA
- **Qualidade:** 100%
