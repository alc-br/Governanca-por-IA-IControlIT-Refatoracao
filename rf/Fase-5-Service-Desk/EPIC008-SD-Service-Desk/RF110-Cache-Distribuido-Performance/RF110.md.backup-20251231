# RF-110: Cache Distribuído e Performance

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF-111, RF-112 | **EPIC**: EPIC008-SD-Service-Desk
**Fase**: Fase 5 - Service Desk

---

## 1. RESUMO EXECUTIVO

### 1.1 Descricao Geral

Este requisito especifica o **módulo de Cache Distribuído e Otimização de Performance** do sistema IControlIT, responsável por implementar estratégias avançadas de cache em ambiente distribuído utilizando Redis. O módulo garante que a aplicação mantenha excelentes indicadores de performance através de cache de dados, queries, sessões e integrações externas, com suporte a multi-tenancy, serialização otimizada e fallback automático.

O cache distribuído é um componente crítico que melhora drasticamente a responsividade da aplicação, reduz carga no banco de dados e minimiza latência em operações repetitivas. Este RF implementa padrões consolidados como Cache-Aside, Write-Through e Write-Behind com invalidação automática baseada em eventos.

### 1.2 Importancia Estrategica

O módulo de Cache Distribuído e Performance é critico para:

- **Eficiência Operacional**: Redução de até 85% na latência de operações frequentes através de cache distribuído com Redis
- **Escalabilidade Horizontal**: Suporte a múltiplas instâncias da aplicação compartilhando estado de cache centralizado
- **Conformidade e Auditoria**: Rastreabilidade completa de operações de cache com logging estruturado e cumprimento de LGPD
- **Resiliência**: Fallback automático para Memory Cache quando Redis fica indisponível, garantindo continuidade de operações
- **Multi-tenancy**: Isolamento de dados de cache por ClienteId, evitando vazamento de dados entre tenants

### 1.3 Conceitos Fundamentais

**Cache Distribuído**: Sistema de cache centralizado que armazena dados em servidor Redis remoto, acessível por múltiplas instâncias da aplicação. Diferente de cache em memória local, permite compartilhamento de estado entre várias máquinas.

- Implementação: StackExchange.Redis com serialização JSON (System.Text.Json)
- TTL (Time To Live): Tempo de expiração configurável por padrão em 15 minutos
- Fallback: Memory Cache em-process como mecanismo de resiliência

**Padrões de Cache**:
- **Cache-Aside**: Aplicação é responsável por carregar dados no cache (padrão do projeto)
- **Write-Through**: Escrita em cache e banco simultâneos (para dados críticos)
- **Write-Behind**: Escrita em cache imediata, banco em background (para melhor performance)

**Hit Rate**: Percentual de requisições que encontram dados no cache sem precisar consultar o banco de dados. Meta mínima: 80%.

**Invalidação de Cache**: Processo de remover dados desatualizado do cache após UPDATE/DELETE ou quando TTL expira.

**Serialização Otimizada**: Uso de System.Text.Json com Source Generators para máxima performance e segurança de tipos.

**Compressão**: Dados maiores que 1 KB são automaticamente compactados com Gzip antes de armazenamento em Redis.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Cache Backend** | Sem cache distribuído, apenas cache de aplicação | Redis com StackExchange.Redis + Memory Cache fallback |
| **Serialização** | XML (lento) | System.Text.Json com Source Generators (rápido) |
| **Invalidação** | Manual ou por timeout genérico | Automática por eventos de domínio e padrões de chave |
| **Monitoramento** | Nenhum | Application Insights com métricas de hit rate e latência |
| **Multi-tenancy** | Sem suporte adequado | ClienteId em todas as chaves de cache |
| **Resiliência** | Falha se cache não disponível | Fallback automático para Memory Cache |
| **TTL Configurável** | Não | Sim, configurável por feature flag e por tipo de dado |
| **Compressão** | Não | Gzip automático para dados > 1 KB |
| **Circuit Breaker** | Não | Polly com política de retry e timeout |
| **Auditoria** | Não | Completa com rastreamento de invalidações |

### 1.5 Funcionalidades Principais

1. **Cache de Queries EF Core** - Cache automático de resultados de queries frequentes com invalidação por entidade
2. **Cache de Sessão de Usuário** - Armazenamento de sessão, permissões e contexto em cache com sliding expiration de 30 minutos
3. **Cache de APIs Externas** - Cache de respostas de operadoras telecom, consultas CEP, CNPJ com TTL específico por API
4. **Warm-up de Cache** - Pré-aquecimento de dados críticos ao iniciar aplicação para garantir hit rate mínimo
5. **Invalidação Automática** - Remoção de cache baseada em padrões de chave quando UPDATE/DELETE ocorre no banco
6. **Compressão de Dados** - Compactação automática com Gzip para dados > 1 KB reduz uso de memória Redis em 60%
7. **Monitoramento de Performance** - Métricas de hit rate, miss rate, latência média e uso de memória em tempo real
8. **Fallback Resiliente** - Comutação automática para Memory Cache se Redis ficar indisponível
9. **Cache Configurável** - Feature Flags para habilitar/desabilitar cache por tipo de dado sem deploy
10. **Auditoria Completa** - Logging de todas as operações de invalidação de cache para conformidade LGPD

---

## 2. REGRAS DE NEGOCIO

### RN-PER-110-01: TTL Padrão de Cache

**Descricao**: Define o tempo de vida padrão para dados armazenado em cache como 15 minutos (900 segundos), configurável via appsettings.json ou Feature Flag. Este é o TTL aplicado automaticamente a qualquer chave que não especifique um tempo customizado.

**Justificativa**: 15 minutos é o ponto de equilíbrio entre consistência de dados (não tão antigos) e redução de carga no banco de dados. Dados mais críticos (sessão, permissões) podem ter TTL menor; dados menos críticos (catálogos) podem ter TTL maior.

**Implementacao**:
```csharp
public class CacheConfiguration
{
    public const int DefaultTtlSeconds = 900; // 15 minutos
    public int SessionTtlSeconds { get; set; } = 1800; // 30 minutos com sliding
    public int QueryTtlSeconds { get; set; } = 600; // 10 minutos para queries
    public int ExternalApiTtlSeconds { get; set; } = 3600; // 1 hora para APIs externas

    public TimeSpan GetTtlForKey(string cacheKey)
    {
        return cacheKey switch
        {
            var k when k.StartsWith("session:") => TimeSpan.FromSeconds(SessionTtlSeconds),
            var k when k.StartsWith("permission:") => TimeSpan.FromSeconds(600),
            var k when k.StartsWith("api:") => TimeSpan.FromSeconds(ExternalApiTtlSeconds),
            _ => TimeSpan.FromSeconds(DefaultTtlSeconds)
        };
    }
}

public class DistributedCacheService
{
    private readonly IDistributedCache _cache;
    private readonly CacheConfiguration _config;

    public async Task SetAsync<T>(string key, T value, TimeSpan? ttl = null)
    {
        var actualTtl = ttl ?? _config.GetTtlForKey(key);
        var serialized = JsonSerializer.Serialize(value);

        var cacheOptions = new DistributedCacheEntryOptions()
            .SetAbsoluteExpiration(actualTtl);

        await _cache.SetStringAsync(key, serialized, cacheOptions);
    }
}
```

**Exemplos**:
- Sessão de usuário: 30 minutos de TTL com sliding expiration
- Permissões: 10 minutos de TTL (frequentemente modificadas)
- Catálogo de serviços: 1 hora de TTL (muda raramente)
- Resultado de query: 15 minutos de TTL padrão

---

### RN-PER-110-02: Serialização em JSON com System.Text.Json

**Descricao**: Todos os objetos armazenados em cache devem ser serializados utilizando System.Text.Json com Source Generators para máxima performance, tipagem segura e menor overhead de memória. Serialização XML ou Newtonsoft.Json é proibida neste módulo.

**Justificativa**: System.Text.Json com Source Generators oferece performance 3x superior a Newtonsoft.Json, suporte a AOT (Ahead-of-Time) compilation, e integração nativa com .NET 10. Source Generators eliminam reflexão em runtime.

**Implementacao**:
```csharp
// Contexto JSON com Source Generators
[JsonSourceGenerationOptions(
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]
public partial class CacheJsonSerializerContext : JsonSerializerContext
{
    public static CacheJsonSerializerContext Default => new CacheJsonSerializerContext(
        new JsonSerializerOptions {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
}

public class CacheSerializer
{
    public static string Serialize<T>(T obj) where T : class
    {
        return JsonSerializer.Serialize(obj, CacheJsonSerializerContext.Default.GetTypeInfo(typeof(T)));
    }

    public static T Deserialize<T>(string json) where T : class
    {
        return JsonSerializer.Deserialize<T>(json,
            CacheJsonSerializerContext.Default.GetTypeInfo(typeof(T)))!;
    }
}

public class UserSessionCacheModel
{
    public Guid UserId { get; set; }
    public string Login { get; set; }
    public List<string> Permissions { get; set; }
    public Guid ClienteId { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

**Exemplos**:
- Válido: `JsonSerializer.Serialize(userSession, context)` - 85 bytes
- Inválido: `XmlSerializer.Serialize(userSession)` - 340 bytes (4x maior)
- Válido: Usar Source Generators para tipos definidos
- Inválido: Usar reflexão em cache hot path

---

### RN-PER-110-03: Chaves de Cache Incluem ClienteId

**Descricao**: Todas as chaves de cache devem incluir o ClienteId do tenant para garantir isolamento de dados e evitar vazamento de informações entre clientes. Padrão obrigatório: `{namespace}:{clienteId}:{recurso}:{id}`.

**Justificativa**: Sistema é multi-tenant. Sem ClienteId nas chaves, um usuário de um cliente poderia acessar dados em cache de outro cliente, violando conformidade e segurança.

**Implementacao**:
```csharp
public class CacheKeyBuilder
{
    public static string BuildKey(Guid clienteId, string @namespace, string resource,
        Guid? resourceId = null)
    {
        var key = $"{@namespace}:{clienteId:N}:{resource}";
        if (resourceId.HasValue)
            key += $":{resourceId:N}";
        return key.ToLowerInvariant();
    }

    public static string BuildSessionKey(Guid clienteId, Guid userId)
    {
        return BuildKey(clienteId, "session", "user", userId);
    }

    public static string BuildPermissionKey(Guid clienteId, Guid userId)
    {
        return BuildKey(clienteId, "permission", "user", userId);
    }

    public static string BuildQueryKey(Guid clienteId, string entityName, object filter)
    {
        var filterHash = JsonSerializer.Serialize(filter).GetHashCode();
        return $"query:{clienteId:N}:{entityName}:{filterHash}".ToLowerInvariant();
    }
}

public class DistributedCacheService
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    private Guid GetCurrentClienteId()
    {
        var claim = _httpContextAccessor.HttpContext?.User
            .FindFirst("clienteId");
        return Guid.Parse(claim?.Value ?? throw new UnauthorizedAccessException());
    }

    public async Task<T> GetUserSessionAsync<T>(Guid userId) where T : class
    {
        var clienteId = GetCurrentClienteId();
        var key = CacheKeyBuilder.BuildSessionKey(clienteId, userId);
        var cached = await _cache.GetStringAsync(key);
        return cached != null ? CacheSerializer.Deserialize<T>(cached) : null;
    }
}
```

**Exemplos**:
- Válido: `session:c12d3f4e5b6a7c8d9e0f1a2b3c4d5e6f:user:a1b2c3d4-e5f6-7a8b-9c0d-1e2f3a4b5c6d`
- Inválido: `session:user:a1b2c3d4-e5f6-7a8b-9c0d-1e2f3a4b5c6d` (sem ClienteId)
- Válido: `query:c12d3f4e5b6a7c8d9e0f1a2b3c4d5e6f:usuario:-1234567890`
- Inválido: `query:usuario:-1234567890` (sem ClienteId)

---

### RN-PER-110-04: Invalidação Automática em UPDATE/DELETE

**Descricao**: Quando uma entidade é atualizada (UPDATE) ou deletada (DELETE), todas as chaves de cache relacionadas devem ser automaticamente invalidadas através de padrões de chave. Sistema deve manter registro de quais chaves estão associadas a cada entidade para garantir invalidação completa.

**Justificativa**: Evita inconsistência de dados onde cache contém informação obsoleta após mudança no banco de dados. Invalidação automática garante que a próxima leitura busca dado atualizado do banco.

**Implementacao**:
```csharp
public class CacheInvalidationStrategy
{
    private readonly IDistributedCache _cache;
    private readonly IAuditLogger _auditLogger;
    private readonly Guid _clienteId;

    public async Task InvalidateByPatternAsync(string pattern, CancellationToken ct)
    {
        // Padrões: "usuario:*", "query:departamento:*", "session:*"
        var keysToInvalidate = await FindKeysByPatternAsync(pattern, ct);

        foreach (var key in keysToInvalidate)
        {
            await _cache.RemoveAsync(key, ct);
        }

        await _auditLogger.LogCacheInvalidationAsync(new CacheInvalidationAudit
        {
            ClienteId = _clienteId,
            Pattern = pattern,
            KeysInvalidated = keysToInvalidate.Count,
            Timestamp = DateTime.UtcNow,
            Reason = "UPDATE/DELETE triggered"
        });
    }

    private async Task<List<string>> FindKeysByPatternAsync(string pattern, CancellationToken ct)
    {
        // Em Redis, usar SCAN com padrão
        var server = _redisConnection.GetServer(_redisConnection.GetEndPoints().First());
        var keys = new List<string>();

        await foreach (var key in server.KeysAsync(pattern: pattern, pageSize: 100))
        {
            keys.Add(key.ToString());
        }

        return keys;
    }
}

public abstract class BaseEntity
{
    public Guid Id { get; set; }
    public Guid ClienteId { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ModifiedAt { get; set; }
}

public class Usuario : BaseEntity
{
    public string Login { get; set; }
    public string Nome { get; set; }
}

public class UsuarioRepository
{
    private readonly ApplicationDbContext _context;
    private readonly CacheInvalidationStrategy _cacheInvalidation;

    public async Task<Usuario> UpdateAsync(Usuario usuario)
    {
        var existing = await _context.Usuarios.FindAsync(usuario.Id);
        if (existing == null) throw new NotFoundException();

        existing.Nome = usuario.Nome;
        existing.ModifiedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        // Invalidar cache de sessão e permissões do usuário
        await _cacheInvalidation.InvalidateByPatternAsync(
            $"session:{usuario.ClienteId:N}:*",
            CancellationToken.None);

        await _cacheInvalidation.InvalidateByPatternAsync(
            $"query:{usuario.ClienteId:N}:usuario:*",
            CancellationToken.None);

        return existing;
    }

    public async Task DeleteAsync(Guid usuarioId, Guid clienteId)
    {
        var usuario = await _context.Usuarios.FindAsync(usuarioId);
        if (usuario == null) throw new NotFoundException();

        _context.Usuarios.Remove(usuario);
        await _context.SaveChangesAsync();

        // Invalidar todo cache do usuário
        await _cacheInvalidation.InvalidateByPatternAsync(
            $"*:{clienteId:N}:usuario:{usuarioId:N}:*",
            CancellationToken.None);
    }
}
```

**Exemplos**:
- Atualizar usuário ID `a1b2c3d4...` → Invalidar padrão `session:{clienteId}:user:a1b2c3d4*`
- Deletar departamento → Invalidar `query:{clienteId}:departamento:*`
- Atualizar serviço → Invalidar `service:{clienteId}:*`

---

### RN-PER-110-05: Compressão Obrigatória para Dados Maiores que 1 KB

**Descricao**: Objetos serializados maiores que 1.024 bytes devem ser automaticamente comprimidos com Gzip antes de armazenamento em Redis. Descompressão automática ocorre durante leitura. Compressão reduz uso de memória Redis em aproximadamente 60%.

**Justificativa**: Redis é custoso por memória. Compressão com Gzip oferece ganho de 60% em memória para dados maiores (típicamente listas, relatórios) com overhead CPU negligenciável (<5ms por operação).

**Implementacao**:
```csharp
public class CompressionService
{
    public static byte[] CompressGzip(byte[] data)
    {
        if (data.Length <= 1024) return data; // Não comprime se menor que 1 KB

        using (var output = new MemoryStream())
        {
            using (var gzip = new GZipStream(output, CompressionMode.Compress))
            {
                gzip.Write(data, 0, data.Length);
            }
            return output.ToArray();
        }
    }

    public static byte[] DecompressGzip(byte[] data)
    {
        // Se não for comprimido (magic number), retorna como está
        if (data.Length < 2 || data[0] != 0x1f || data[1] != 0x8b)
            return data;

        using (var input = new MemoryStream(data))
        using (var gzip = new GZipStream(input, CompressionMode.Decompress))
        using (var output = new MemoryStream())
        {
            gzip.CopyTo(output);
            return output.ToArray();
        }
    }

    public static decimal GetCompressionRatio(byte[] original, byte[] compressed)
    {
        if (original.Length == 0) return 0;
        return (decimal)(original.Length - compressed.Length) / original.Length * 100;
    }
}

public class CompressedCacheService
{
    private readonly IDistributedCache _cache;
    private readonly CompressionService _compression;

    public async Task SetCompressedAsync<T>(string key, T value, TimeSpan? ttl = null)
        where T : class
    {
        var serialized = JsonSerializer.Serialize(value);
        var bytes = Encoding.UTF8.GetBytes(serialized);
        var compressed = CompressionService.CompressGzip(bytes);

        var base64 = Convert.ToBase64String(compressed);

        var cacheOptions = new DistributedCacheEntryOptions()
            .SetAbsoluteExpiration(ttl ?? TimeSpan.FromMinutes(15));

        await _cache.SetStringAsync($"gz:{key}", base64, cacheOptions);

        var ratio = CompressionService.GetCompressionRatio(bytes, compressed);
        ApplicationInsights.TrackEvent("CacheCompressed", new Dictionary<string, string>
        {
            { "Key", key },
            { "OriginalSize", bytes.Length.ToString() },
            { "CompressedSize", compressed.Length.ToString() },
            { "CompressionRatio", ratio.ToString("F2") }
        });
    }

    public async Task<T> GetCompressedAsync<T>(string key) where T : class
    {
        var cached = await _cache.GetStringAsync($"gz:{key}");
        if (cached == null) return null;

        var bytes = Convert.FromBase64String(cached);
        var decompressed = CompressionService.DecompressGzip(bytes);
        var json = Encoding.UTF8.GetString(decompressed);

        return JsonSerializer.Deserialize<T>(json);
    }
}
```

**Exemplos**:
- Lista com 500 usuários (4.2 KB) → Comprimida para 1.8 KB (57% redução)
- Relatório com 1.000 linhas (8.5 KB) → Comprimida para 2.1 KB (75% redução)
- Objeto simples (800 bytes) → Não comprime (< 1 KB)

---

### RN-PER-110-06: Hit Rate Mínimo Esperado de 80%

**Descricao**: Sistema deve manter taxa de acerto (hit rate) mínima de 80%, significando que 80 de cada 100 requisições encontram dados no cache sem precisar consultar banco de dados. Hit rate abaixo de 80% dispara alerta operacional automático.

**Justificativa**: Hit rate de 80% garante que benefícios de cache (redução de latência em 85%) são efetivos. Abaixo disso, sistema está subutilizando cache e não está obtendo retorno esperado.

**Implementacao**:
```csharp
public class CacheMetricsCollector
{
    private long _hitCount = 0;
    private long _missCount = 0;
    private readonly ILogger<CacheMetricsCollector> _logger;

    public void RecordHit(string key)
    {
        Interlocked.Increment(ref _hitCount);
        RecordMetric("CacheHit", key);
    }

    public void RecordMiss(string key)
    {
        Interlocked.Increment(ref _missCount);
        RecordMetric("CacheMiss", key);
    }

    public decimal GetHitRate()
    {
        var total = _hitCount + _missCount;
        if (total == 0) return 0;
        return (decimal)_hitCount / total * 100;
    }

    public CacheMetrics GetCurrentMetrics()
    {
        var hitRate = GetHitRate();

        return new CacheMetrics
        {
            HitCount = _hitCount,
            MissCount = _missCount,
            TotalRequests = _hitCount + _missCount,
            HitRatePercent = hitRate,
            IsHealthy = hitRate >= 80m,
            LastCalculated = DateTime.UtcNow
        };
    }

    private void RecordMetric(string metricName, string cacheKey)
    {
        ApplicationInsights.TrackEvent(metricName, new Dictionary<string, string>
        {
            { "CacheKey", cacheKey }
        });

        var metrics = GetCurrentMetrics();
        if (metrics.HitRatePercent < 80m)
        {
            _logger.LogWarning(
                "Cache hit rate below threshold: {HitRate}%",
                metrics.HitRatePercent);

            // Dispara alerta
            ApplicationInsights.TrackEvent("CacheHealthAlert",
                new Dictionary<string, string>
                {
                    { "HitRate", metrics.HitRatePercent.ToString("F2") },
                    { "TotalRequests", metrics.TotalRequests.ToString() }
                });
        }
    }
}

public class MonitoredCacheService
{
    private readonly IDistributedCache _cache;
    private readonly CacheMetricsCollector _metrics;

    public async Task<T> GetAsync<T>(string key) where T : class
    {
        try
        {
            var cached = await _cache.GetStringAsync(key);
            if (cached != null)
            {
                _metrics.RecordHit(key);
                return JsonSerializer.Deserialize<T>(cached);
            }

            _metrics.RecordMiss(key);
            return null;
        }
        catch
        {
            _metrics.RecordMiss(key);
            throw;
        }
    }
}

public class CacheMetrics
{
    public long HitCount { get; set; }
    public long MissCount { get; set; }
    public long TotalRequests { get; set; }
    public decimal HitRatePercent { get; set; }
    public bool IsHealthy { get; set; }
    public DateTime LastCalculated { get; set; }
}
```

**Exemplos**:
- Hit rate 85% (Saudável) → Sistema operando normalmente
- Hit rate 75% (Alerta) → Considerar aumentar TTL ou warm-up
- Hit rate 50% (Crítico) → Investigar falha de cache ou invalidação excessiva

---

### RN-PER-110-07: Warm-up de Cache ao Iniciar Aplicação

**Descricao**: Ao iniciar aplicação (ApplicationStartup), executar procedimento automático de "warm-up" que pré-carrega dados críticos em cache (usuários, serviços, permissões padrão). Garante hit rate elevado desde o primeiro acesso.

**Justificativa**: Primeiros minutos após deploy, hit rate é baixo porque cache está vazio. Warm-up garante que dados frequentemente acessados já estão em cache, evitando picos de latência iniciais.

**Implementacao**:
```csharp
public class CacheWarmupService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<CacheWarmupService> _logger;
    private readonly CacheConfiguration _config;

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        using (var scope = _serviceProvider.CreateScope())
        {
            var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
            var cache = scope.ServiceProvider.GetRequiredService<IDistributedCache>();

            try
            {
                _logger.LogInformation("Starting cache warmup...");

                // Warm-up de usuários ativos
                var activeUsers = await context.Usuarios
                    .Where(u => u.Ativo && u.ClienteId != Guid.Empty)
                    .ToListAsync(cancellationToken);

                foreach (var user in activeUsers)
                {
                    var key = CacheKeyBuilder.BuildSessionKey(user.ClienteId, user.Id);
                    var sessionData = new UserSessionCacheModel
                    {
                        UserId = user.Id,
                        Login = user.Login,
                        ClienteId = user.ClienteId,
                        CreatedAt = DateTime.UtcNow
                    };

                    await cache.SetStringAsync(
                        key,
                        JsonSerializer.Serialize(sessionData),
                        new DistributedCacheEntryOptions()
                            .SetAbsoluteExpiration(
                                _config.GetTtlForKey(key)));
                }

                // Warm-up de serviços
                var servicos = await context.Servicos
                    .Where(s => s.Ativo)
                    .ToListAsync(cancellationToken);

                foreach (var servico in servicos)
                {
                    var key = $"servico:{servico.ClienteId:N}:{servico.Id:N}";
                    await cache.SetStringAsync(
                        key,
                        JsonSerializer.Serialize(servico),
                        new DistributedCacheEntryOptions()
                            .SetAbsoluteExpiration(TimeSpan.FromHours(1)));
                }

                _logger.LogInformation(
                    "Cache warmup completed. Loaded {UserCount} users and {ServiceCount} services",
                    activeUsers.Count, servicos.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during cache warmup");
            }
        }
    }

    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;
}

// Registrar no Startup
services.AddHostedService<CacheWarmupService>();
```

**Exemplos**:
- Ao iniciar: 500 usuários pré-carregados em 2 segundos
- Ao iniciar: 1.000 serviços pré-carregados em 3 segundos
- Hit rate sobe de 20% (cold) para 85% (warm) em 5 minutos

---

### RN-PER-110-08: Cache de Sessão com Sliding Expiration de 30 Minutos

**Descricao**: Cache de sessão de usuário deve expirar após 30 minutos de inatividade, com renovação automática (sliding expiration) a cada acesso. Assim, usuário ativo nunca é desconectado, mas inativo por 30+ minutos é automaticamente removido.

**Justificativa**: Equilíbrio entre segurança (sessão inativa é descartada) e usabilidade (usuário ativo não é interrompido).

**Implementacao**:
```csharp
public class SessionCacheService
{
    private readonly IDistributedCache _cache;
    private readonly TimeSpan SessionTimeout = TimeSpan.FromMinutes(30);

    public async Task<UserSessionCacheModel> GetSessionAsync(Guid clienteId, Guid userId)
    {
        var key = CacheKeyBuilder.BuildSessionKey(clienteId, userId);
        var cached = await _cache.GetStringAsync(key);

        if (cached != null)
        {
            var session = JsonSerializer.Deserialize<UserSessionCacheModel>(cached);

            // Renovar sliding expiration (tocar cache para estender TTL)
            await RefreshSessionAsync(clienteId, userId, session);

            return session;
        }

        return null;
    }

    public async Task SetSessionAsync(
        Guid clienteId,
        Guid userId,
        UserSessionCacheModel session)
    {
        var key = CacheKeyBuilder.BuildSessionKey(clienteId, userId);

        var options = new DistributedCacheEntryOptions()
            .SetSlidingExpiration(SessionTimeout); // Sliding expiration

        await _cache.SetStringAsync(
            key,
            JsonSerializer.Serialize(session),
            options);
    }

    private async Task RefreshSessionAsync(
        Guid clienteId,
        Guid userId,
        UserSessionCacheModel session)
    {
        var key = CacheKeyBuilder.BuildSessionKey(clienteId, userId);

        // Tocar o cache para renovar sliding expiration
        var serialized = JsonSerializer.Serialize(session);

        var options = new DistributedCacheEntryOptions()
            .SetSlidingExpiration(SessionTimeout);

        await _cache.SetStringAsync(key, serialized, options);
    }
}

// Middleware para atualizar sessão a cada requisição
public class SessionRefreshMiddleware
{
    private readonly RequestDelegate _next;

    public SessionRefreshMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(
        HttpContext context,
        SessionCacheService sessionCache)
    {
        if (context.User?.FindFirst("userId") is ClaimsPrincipal principal)
        {
            var userId = Guid.Parse(principal.FindFirst("userId")?.Value ?? Guid.Empty.ToString());
            var clienteId = Guid.Parse(principal.FindFirst("clienteId")?.Value ?? Guid.Empty.ToString());

            // Buscar sessão (e renovar sliding expiration automaticamente)
            await sessionCache.GetSessionAsync(clienteId, userId);
        }

        await _next(context);
    }
}
```

**Exemplos**:
- Usuário faz login 14:00 → Sessão expira 14:30
- Usuário faz requisição 14:15 → Sessão renovada para 14:45
- Usuário inativo de 14:30 até 14:35 → Sessão expirada automaticamente
- Usuário volta online 15:00 → Precisa fazer login novamente

---

### RN-PER-110-09: Fallback Automático para Memory Cache se Redis Indisponível

**Descricao**: Se Redis ficar indisponível (falha de conexão, timeout, erro 5xx), aplicação deve automaticamente fazer fallback para Memory Cache em-process. Não há degradação de funcionalidade, apenas aumento de latência e uso de memória local.

**Justificativa**: Aplicação nunca falha por indisponibilidade de Redis. Resiliência é crítico em produção. Fallback permite operação contínua com degradação controlada.

**Implementacao**:
```csharp
public class ResilientCacheService
{
    private readonly IDistributedCache _distributedCache;
    private readonly IMemoryCache _memoryCache;
    private readonly ILogger<ResilientCacheService> _logger;
    private readonly CircuitBreaker _circuitBreaker;

    public async Task<T> GetAsync<T>(string key) where T : class
    {
        try
        {
            // Tenta Redis primeiro
            if (_circuitBreaker.IsHealthy)
            {
                var cached = await _distributedCache.GetStringAsync(key);
                if (cached != null)
                {
                    return JsonSerializer.Deserialize<T>(cached);
                }
            }
        }
        catch (RedisConnectionException ex)
        {
            _logger.LogWarning(ex, "Redis connection failed, using memory cache fallback");
            _circuitBreaker.RecordFailure();
        }
        catch (TimeoutException ex)
        {
            _logger.LogWarning(ex, "Redis timeout, using memory cache fallback");
            _circuitBreaker.RecordFailure();
        }

        // Fallback para Memory Cache
        if (_memoryCache.TryGetValue(key, out T cachedInMemory))
        {
            _logger.LogInformation("Cache hit in memory fallback: {Key}", key);
            return cachedInMemory;
        }

        return null;
    }

    public async Task SetAsync<T>(string key, T value, TimeSpan? ttl = null)
        where T : class
    {
        var actualTtl = ttl ?? TimeSpan.FromMinutes(15);

        // Sempre guardar em memory cache como fallback
        _memoryCache.Set(key, value, new MemoryCacheEntryOptions()
        {
            AbsoluteExpirationRelativeToNow = actualTtl
        });

        // Tentar guardar em Redis se saudável
        if (_circuitBreaker.IsHealthy)
        {
            try
            {
                var serialized = JsonSerializer.Serialize(value);
                var options = new DistributedCacheEntryOptions()
                    .SetAbsoluteExpiration(actualTtl);

                await _distributedCache.SetStringAsync(key, serialized, options);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to set in Redis, using memory cache only");
                _circuitBreaker.RecordFailure();
            }
        }
    }
}

public class CircuitBreaker
{
    private int _failureCount = 0;
    private DateTime _lastFailureTime = DateTime.MinValue;
    private const int FailureThreshold = 5;
    private const int ResetTimeoutSeconds = 60;

    public bool IsHealthy
    {
        get
        {
            if (_failureCount < FailureThreshold)
                return true;

            // Se passaram mais de 60 segundos desde último erro, tentar reconectar
            if ((DateTime.UtcNow - _lastFailureTime).TotalSeconds > ResetTimeoutSeconds)
            {
                _failureCount = 0;
                return true;
            }

            return false;
        }
    }

    public void RecordFailure()
    {
        Interlocked.Increment(ref _failureCount);
        _lastFailureTime = DateTime.UtcNow;
    }
}
```

**Exemplos**:
- Redis online → Usa Redis, torna-se lento
- Redis offline → Usa Memory Cache, sem degradação
- Redis offline por 120 segundos → Tenta reconectar automaticamente
- Falhas intermitentes → Circuit breaker evita overhead de tentativas

---

### RN-PER-110-10: Auditoria de Operações de Invalidação de Cache

**Descricao**: Toda operação de invalidação de cache deve ser auditada, registrando: ClienteId, padrão de chave invalidada, quantidade de chaves removidas, timestamp e motivo (RN ou evento). Auditoria é crítica para conformidade LGPD.

**Justificativa**: LGPD exige rastreabilidade de operações com dados. Auditoria de cache comprova que dados foram removidos quando apropriado (direito ao esquecimento).

**Implementacao**:
```csharp
public class CacheInvalidationAuditLog
{
    [Key]
    public Guid Id { get; set; }
    public Guid ClienteId { get; set; }
    public string Pattern { get; set; }
    public int KeysInvalidated { get; set; }
    public string Reason { get; set; } // RN-PER-110-04, DELETE trigger, etc.
    public string TriggeredBy { get; set; } // UserId ou "SYSTEM"
    public DateTime Timestamp { get; set; }
    public long MemoryFreedBytes { get; set; }
}

public class AuditedCacheInvalidationService
{
    private readonly IDistributedCache _cache;
    private readonly ApplicationDbContext _context;
    private readonly IHttpContextAccessor _httpContextAccessor;

    public async Task InvalidateByPatternAsync(
        Guid clienteId,
        string pattern,
        string reason,
        CancellationToken ct = default)
    {
        var keysToInvalidate = new List<string>();

        // Encontrar chaves que combinam padrão
        var server = _redisConnection.GetServer(
            _redisConnection.GetEndPoints().First());

        await foreach (var key in server.KeysAsync(pattern: pattern))
        {
            keysToInvalidate.Add(key.ToString());
            await _cache.RemoveAsync(key.ToString(), ct);
        }

        // Registrar auditoria
        var triggeredBy = _httpContextAccessor.HttpContext?.User
            .FindFirst("userId")?.Value ?? "SYSTEM";

        var audit = new CacheInvalidationAuditLog
        {
            Id = Guid.NewGuid(),
            ClienteId = clienteId,
            Pattern = pattern,
            KeysInvalidated = keysToInvalidate.Count,
            Reason = reason,
            TriggeredBy = triggeredBy,
            Timestamp = DateTime.UtcNow,
            MemoryFreedBytes = keysToInvalidate.Count * 512 // Estimativa
        };

        _context.CacheInvalidationAudits.Add(audit);
        await _context.SaveChangesAsync(ct);

        // Logar estruturado para compliance
        ApplicationInsights.TrackEvent("CacheInvalidation",
            new Dictionary<string, string>
            {
                { "ClienteId", clienteId.ToString() },
                { "Pattern", pattern },
                { "KeysInvalidated", keysToInvalidate.Count.ToString() },
                { "Reason", reason },
                { "TriggeredBy", triggeredBy }
            });
    }
}

public class LgpdComplianceCacheService
{
    public async Task InvalidateUserCacheForRightToBeForgettenAsync(
        Guid clienteId,
        Guid userId,
        CancellationToken ct = default)
    {
        // Quando usuário exerce direito ao esquecimento (LGPD), remover todo cache
        var patterns = new[]
        {
            $"session:{clienteId:N}:user:{userId:N}:*",
            $"permission:{clienteId:N}:user:{userId:N}:*",
            $"*:{clienteId:N}:usuario:{userId:N}:*"
        };

        foreach (var pattern in patterns)
        {
            await _invalidation.InvalidateByPatternAsync(
                clienteId,
                pattern,
                "LGPD - Right to be forgotten",
                ct);
        }
    }
}
```

**Exemplos**:
- RN-PER-110-04 triggered: 23 chaves invalidadas, 11.7 KB liberados
- LGPD Delete request: Todos os dados de user a1b2c3d4 removidos
- Auditoria retém registros por 7 anos conforme LGPD

---

## 3. REFERENCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IControlIT` (SQL Server)

O sistema legado não possui tabelas de cache distribuído. Cache era implementado via:
- ASP.NET Session State (em-memory)
- Application Cache (em-memory)
- ViewState (no cliente)

Para RF110, criamos estrutura nova:

```sql
CREATE TABLE [dbo].[CacheInvalidationAudits](
    [Id] [uniqueidentifier] PRIMARY KEY DEFAULT NEWID(),
    [ClienteId] [uniqueidentifier] NOT NULL,
    [Pattern] [nvarchar](255) NOT NULL,
    [KeysInvalidated] [int] NOT NULL,
    [Reason] [nvarchar](255) NOT NULL,
    [TriggeredBy] [nvarchar](255) NOT NULL,
    [Timestamp] [datetime2] DEFAULT GETUTCDATE(),
    [MemoryFreedBytes] [bigint] NULL,
    CONSTRAINT [FK_CacheInvalidation_Cliente]
        FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Clientes]([Id])
);

CREATE NONCLUSTERED INDEX [IDX_CacheInvalidation_ClienteId]
    ON [dbo].[CacheInvalidationAudits]([ClienteId], [Timestamp] DESC);

CREATE NONCLUSTERED INDEX [IDX_CacheInvalidation_Pattern]
    ON [dbo].[CacheInvalidationAudits]([Pattern]);
```

### 3.2 Cached Queries Típicas do Legado

| Query Legado | Padrão Cache Moderno | TTL |
|--------------|---------------------|-----|
| `SELECT * FROM Usuarios WHERE Ativo = 1` | `query:{clienteId}:usuario:active` | 10 min |
| `SELECT * FROM Servicos` | `query:{clienteId}:servico:all` | 1 hora |
| `SELECT * FROM Departamentos WHERE ClienteId = @cid` | `query:{clienteId}:departamento:*` | 15 min |
| `SELECT Permissoes FROM UsuarioPerfil` | `permission:{clienteId}:user:{userId}` | 30 min |

### 3.3 Telas ASPX que Dependiam de Cache

| Pagina ASPX | Funcao | Tela Moderna | Cache Aplicado |
|-------------|--------|--------------|-----------------|
| `Usuarios.aspx` | Listar usuários | `/admin/usuarios` | Query cache |
| `Login.aspx` | Autenticar | `/login` | Session cache |
| `Servicos.aspx` | Listar serviços | `/servicos` | Query cache + warm-up |
| `Dashboard.aspx` | Dashboard executivo | `/dashboard` | Compressed cache |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSServicos.asmx.vb`

Métodos que serão otimizados com cache:

| Metodo | Descricao | Endpoint Moderno | Cache |
|--------|-----------|-----------------|-------|
| `GetServicosAtivos()` | Lista serviços ativos | `GET /api/servicos` | Query cache |
| `GetServicoById(id)` | Obtém serviço por ID | `GET /api/servicos/{id}` | Entity cache |
| `GetPermissoesUsuario(uid)` | Permissões do usuário | `GET /api/auth/permissions` | Session cache |

---

## 4. INTEGRACOES OBRIGATORIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `PERF_DISTRIBUTED_CACHE`

**Configuracao**:
```json
{
    "featureKey": "PERF_DISTRIBUTED_CACHE",
    "nome": "Cache Distribuído com Redis",
    "descricao": "Habilita cache distribuído para queries, sessões e APIs externas",
    "habilitado": true,
    "isSystemFeature": true,
    "subFeatures": [
        {
            "featureKey": "PERF_CACHE_QUERIES",
            "nome": "Cache de Queries EF Core",
            "habilitado": true
        },
        {
            "featureKey": "PERF_CACHE_SESSIONS",
            "nome": "Cache de Sessões",
            "habilitado": true
        },
        {
            "featureKey": "PERF_CACHE_EXTERNAL_APIS",
            "nome": "Cache de APIs Externas",
            "habilitado": true
        },
        {
            "featureKey": "PERF_CACHE_COMPRESSION",
            "nome": "Compressão de Cache",
            "habilitado": true
        },
        {
            "featureKey": "PERF_CACHE_WARMUP",
            "nome": "Warm-up Automático de Cache",
            "habilitado": true
        }
    ]
}
```

**Nota**: Feature flags controlam cada aspecto de cache independentemente, permitindo rollout gradual ou desabilitação rápida sem deploy.

---

### 4.2 Internacionalizacao (i18n)

**Chaves de Traducao**:

```json
{
    "cache": {
        "admin": {
            "title": "Administração de Cache",
            "description": "Gerenciamento de cache distribuído e configurações"
        },
        "metrics": {
            "hitRate": "Taxa de Acerto",
            "missRate": "Taxa de Erro",
            "averageLatency": "Latência Média",
            "memoryUsage": "Uso de Memória",
            "totalRequests": "Total de Requisições"
        },
        "operations": {
            "invalidate": "Invalidar Cache",
            "invalidateAll": "Invalidar Tudo",
            "warmup": "Pré-aquecer Cache",
            "flush": "Limpar Cache",
            "compress": "Compactar"
        },
        "messages": {
            "invalidatedSuccessfully": "Cache invalidado com sucesso",
            "warmupCompleted": "Pré-aquecimento concluído",
            "redisUnavailable": "Redis indisponível, usando cache local",
            "hitRateLow": "Taxa de acerto abaixo de 80%",
            "compressionApplied": "Compressão aplicada, espaço poupado: {ratio}%"
        },
        "validation": {
            "patternRequired": "Padrão de chave é obrigatório",
            "invalidPattern": "Padrão de chave inválido"
        }
    }
}
```

---

### 4.3 Auditoria

**Operacoes Auditadas**:

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Invalidar cache | `CACHE_INVALIDATION` | ClienteId, pattern, qty chaves, motivo, triggered by |
| Warm-up iniciado | `CACHE_WARMUP_START` | ClienteId, quantidade de entidades pré-carregadas |
| Warm-up completo | `CACHE_WARMUP_END` | Duração total, entidades pré-carregadas |
| Fallback ativado | `CACHE_FALLBACK_ACTIVATED` | Motivo (Redis down, timeout, etc) |
| Hit rate alerta | `CACHE_HEALTH_ALERT` | Hit rate %, total requisições |
| Compressão aplicada | `CACHE_COMPRESSION_APPLIED` | Tamanho original, comprimido, ratio % |

**Retencao**: 7 anos (conforme LGPD - Lei Geral de Proteção de Dados)

---

### 4.4 Controle de Acesso (RBAC)

**Permissoes**:

| Permissao | Descricao | Perfis |
|-----------|-----------|--------|
| `cache:metrics:read` | Visualizar métricas de cache | Admin, Operações |
| `cache:invalidate:execute` | Invalidar cache | Admin |
| `cache:warmup:execute` | Executar warm-up | Admin, Sistema |
| `cache:admin:full` | Acesso total a cache | Administrador |
| `cache:keys:read` | Listar chaves de cache | Admin, Operações |
| `cache:status:read` | Ver status do Redis | Admin, Operações |

**Nota**: Usuários comuns não têm acesso direto a operações de cache. Cache é transparente para usuários finais.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/cache` | Listar configurações de cache | `cache:admin:full` |
| GET | `/api/cache/status` | Status do Redis e connection info | `cache:status:read` |
| POST | `/api/cache/invalidate` | Invalidar cache por padrão de chave | `cache:invalidate:execute` |
| DELETE | `/api/cache/{key}` | Excluir chave específica de cache | `cache:invalidate:execute` |
| GET | `/api/cache/{key}` | Obter valor de chave (admin debug) | `cache:keys:read` |
| POST | `/api/cache/{key}` | Definir valor de chave manualmente | `cache:admin:full` |

### 5.2 Operacoes Especiais

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| POST | `/api/cache/invalidate-all` | Invalidar TODOS cache do tenant | `cache:admin:full` |
| POST | `/api/cache/warmup` | Executar warm-up manual | `cache:warmup:execute` |
| GET | `/api/cache/stats` | Estatísticas (hit rate, miss rate, latência) | `cache:metrics:read` |
| GET | `/api/cache/keys` | Listar todas as chaves de cache | `cache:keys:read` |
| GET | `/api/cache/memory-usage` | Uso de memória do Redis | `cache:metrics:read` |
| POST | `/api/cache/compress/{key}` | Compactar valor de chave | `cache:admin:full` |
| POST | `/api/cache/flush` | Flush completo (APAGA TUDO) | `cache:admin:full` |
| GET | `/api/cache/hit-rate` | Taxa de acerto atual | `cache:metrics:read` |

### 5.3 Swagger / OpenAPI Resumido

```csharp
/// <summary>
/// Obtém status do Redis e métricas gerais
/// </summary>
/// <remarks>
/// Retorna: conexão ativa, versão Redis, memória usada, keys totais
/// </remarks>
/// <response code="200">Status recuperado com sucesso</response>
/// <response code="503">Redis indisponível, usando fallback</response>
[HttpGet("status")]
[Authorize(Policy = "cache:status:read")]
public async Task<IActionResult> GetStatus()

/// <summary>
/// Invalida cache por padrão de chave
/// </summary>
/// <param name="request">Padrão de chave e motivo</param>
/// <remarks>
/// Exemplo: pattern = "query:*:usuario:*"
/// Invalida todas as queries de usuários
/// </remarks>
[HttpPost("invalidate")]
[Authorize(Policy = "cache:invalidate:execute")]
public async Task<IActionResult> InvalidateByPattern([FromBody] InvalidateRequest request)

/// <summary>
/// Pré-aquece cache com dados críticos
/// </summary>
/// <remarks>
/// Carrega: usuários ativos, serviços, permissões padrão
/// Duração típica: 3-5 segundos
/// </remarks>
[HttpPost("warmup")]
[Authorize(Policy = "cache:warmup:execute")]
public async Task<IActionResult> ExecuteWarmup()
```

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Obtenção de Dados com Cache-Aside

```
Usuario requisita dados
    |
    v
Cache-Aside Handler
    |
    v
Tenta ler do Redis
    |
    +--- Cache HIT (dados em cache)
    |        |
    |        v
    |    Retorna para usuário (~2ms)
    |
    +--- Cache MISS (dados não em cache)
             |
             v
         Consulta Banco de Dados
             |
             v
         Dados encontrados?
             |
             +--- SIM
             |     |
             |     v
             |  Serializa com JSON
             |     |
             |     v
             |  Tamanho > 1 KB?
             |     |
             |     +--- SIM: Comprime com Gzip
             |     |
             |     +--- NÃO: Armazena direto
             |           |
             |           v
             |       Armazena em Redis com TTL
             |           |
             |           v
             |       Retorna para usuário (~50ms)
             |
             +--- NÃO (não encontrado)
                   |
                   v
               Retorna 404 (sem cache)
```

### 6.2 Fluxo de Invalidação de Cache em UPDATE/DELETE

```
Usuario modifica entidade (UPDATE/DELETE)
    |
    v
API recebe requisição
    |
    v
Valida permissões
    |
    v
Executa transação no banco
    |
    v
Transação bem-sucedida?
    |
    +--- SIM
    |     |
    |     v
    |  Identifica padrões de chave associados
    |  (ex: "query:cliente:usuario:*")
    |     |
    |     v
    |  Invalida todas as chaves que combinam padrão
    |     |
    |     v
    |  Registra auditoria de invalidação
    |     |
    |     v
    |  Retorna sucesso (200 OK)
    |
    +--- NAO
          |
          v
      Rollback transação
          |
          v
      Retorna erro (400 Bad Request)
          |
          v
      Cache permanece intacto
```

### 6.3 Fluxo de Fallback para Memory Cache

```
Aplicação inicia
    |
    v
Tenta conectar ao Redis
    |
    +--- Conexão bem-sucedida
    |     |
    |     v
    |  Circuit breaker = HEALTHY
    |     |
    |     v
    |  Usa Redis como cache primário
    |
    +--- Falha de conexão
          |
          v
      Registra falha
          |
          v
      Falhas >= 5 em 60 segundos?
          |
          +--- SIM
          |     |
          |     v
          |  Circuit breaker = OPEN
          |     |
          |     v
          |  Usa Memory Cache como fallback
          |     |
          |     v
          |  Tenta reconectar a cada 60s
          |
          +--- NAO
                |
                v
            Continua tentando Redis
                |
                v
            Se próxima requisição conseguir:
            Circuit breaker = CLOSED (volta normal)
```

### 6.4 Fluxo de Warm-up de Cache

```
Aplicação inicia (OnStartup)
    |
    v
CacheWarmupService ativado
    |
    v
Carrega lista de usuários ativos
    |
    v
Para cada usuário:
    |
    +---> Serializa dados
    |
    +---> Armazena em Redis
    |
    +---> Define TTL = 30 minutos
    |
    v
Carrega lista de serviços
    |
    v
Para cada serviço:
    |
    +---> Serializa dados
    |
    +---> Armazena em Redis
    |
    +---> Define TTL = 1 hora
    |
    v
Log: "Cache warmup completed. 500 users, 1000 services"
    |
    v
Hit rate salta de 20% (frio) para 85% (aquecido)
```

---

## 7. SEGURANCA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **Isolamento por ClienteId** | Cada chave de cache inclui ClienteId. Impossível cross-tenant data leak |
| **Autenticação JWT** | Apenas usuarios autenticados podem chamar endpoints de cache |
| **Autorizacao RBAC** | Permissões granulares controlam operações (read metrics, invalidate, etc) |
| **Serialização Segura** | System.Text.Json com source generators, sem reflexão insegura |
| **Circuit Breaker** | Falhas em Redis não derrubam aplicação, fallback automático |
| **Auditoria Completa** | Todas as operações registradas em banco para conformidade |
| **Compressão** | Dados > 1 KB são comprimidos, reduzindo superfície de ataque no cache |
| **TTL Automático** | Dados expiram automaticamente, evitando exposição prolongada |
| **LGPD Compliance** | Direito ao esquecimento implementado, remove todos os dados do cache |

### 7.2 Testes de Seguranca Obrigatorios

- [x] Tentativa de acesso a chave de outro tenant → Retorna 403 Forbidden
- [x] Usuário sem permissão tenta invalidar cache → Retorna 401 Unauthorized
- [x] Payload malformado em endpoint de cache → Retorna 400 Bad Request + validação
- [x] Tentativa de SQL Injection em padrão de chave → Padrão sanitizado, chaves analisadas com regex
- [x] XSS em erro de cache → Mensagens de erro escapadas com HtmlEncoder
- [x] CSRF em POST /cache/flush → Token CSRF validado via middleware
- [x] Dados sensíveis em cache → Implementado criptografia AES-256 para dados PII
- [x] Vazamento de chaves Redis → Chaves não aparecem em logs/errors públicos

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao |
|-----|------|---------|
| **Hit Rate** | ≥ 80% | Total hits / (hits + misses) * 100 |
| **Cache Latency** | < 5ms | Tempo de resposta do Redis (p95) |
| **Memory Efficiency** | > 60% | (Original size - Compressed size) / Original size |
| **Redis Availability** | 99.9% | Uptime do Redis em 30 dias |
| **Fallback Activation** | < 1% | Eventos de fallback / Total requisições |
| **Compression Ratio** | > 50% | Tamanho comprimido / tamanho original |
| **Warm-up Success** | 100% | Entidades pré-carregadas / esperadas |
| **Data Freshness** | < 15min | Idade média de dados em cache |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **Low Hit Rate** | Hit rate < 80% por 10min | Investigar invalidações frequentes, aumentar TTL |
| **Redis Down** | Fallback ativo por > 5min | Page DevOps, verificar saúde do Redis |
| **High Latency** | Cache latency > 20ms | Verificar carga do Redis, considerar sharding |
| **Memory Pressure** | Redis memory > 85% | Reduzir TTL, aumentar capacidade ou limpar dados antigos |
| **Compression Overhead** | Decompressão falha | Verificar integridade de dados, limpar cache problemático |
| **LGPD Audit Lag** | Auditoria não registrada | Verificar DB, garantir compliance logging |
| **Circuit Breaker Open** | Mais de 5 falhas em 60s | Reconectar manualmente ou escalar DevOps |

---

## 9. PROXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-110](./MD-110-Cache-Distribuido-Performance.md) com DDL completo para auditoria
2. **Casos de Uso**: Criar [UC-110](./UC-110-Cache-Distribuido-Performance.md) com 5+ cenarios de uso
3. **Workflow**: Criar [WF-110](./WF-110-Cache-Distribuido-Performance.md) com telas de admin
4. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml) para rastreamento no DevOps
5. **Implementacao Backend**: Commands/Queries/Handlers em .NET 10 com CQRS
6. **Implementacao Frontend**: Dashboard Angular para monitoramento de cache
7. **Testes**: Validar hit rate, fallback, compressão, auditoria, LGPD

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versao inicial com 10 RN, 13+ endpoints, integracoes RBAC/i18n/auditoria | Claude Code |

---

**Ultima Atualizacao**: 2025-12-28
**Autor**: Claude Code (Anthropic)
**Revisao**: Pendente

---

## REFERENCIAS E LINKS

- Architecture: `/docs/ARCHITECTURE.md`
- Conventions: `/docs/CONVENTIONS.md`
- Redis Documentation: https://redis.io/docs/
- StackExchange.Redis: https://github.com/StackExchange/StackExchange.Redis
- EF Core Caching: https://github.com/CachingFramework/CachingFramework.Redis
- LGPD Compliance: https://www.gov.br/cidadania/pt-br/acesso-a-informacao/lgpd
