# RF074: Gestão de Chamados - Portal Self-Service

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF073 | **EPIC**: EPIC008-SD-Service-Desk
**Fase**: Fase 5 - Service Desk

---

## 1. RESUMO EXECUTIVO

### 1.1 Descricao Geral

Este requisito especifica o **Portal Self-Service de Gestão de Chamados (Tickets)** do sistema IControlIT, destinado a usuários finais (solicitantes) para abertura, acompanhamento e gestão independente de suas próprias solicitações de suporte. Diferentemente de RF073 (gestão interna), RF074 oferece uma experiência simplificada e intuitiva focada no self-service, permitindo que usuários abram chamados via wizard de 3 passos, acompanhem status em tempo real, adicionem comentários públicos, avaliem atendimento (CSAT), e consultem FAQ integrada.

O portal integra-se seamlessly com:
- **RF073** (Gestão Interna) - compartilham mesma base de dados (Tickets)
- **RF021** (Catálogo de Serviços) - ofertas como pré-preenchimento de categorias
- **RF070** (Base de Conhecimento) - FAQ integrada para auto-resolução
- **RF028** (SLA de Operações) - exibição de prazos em linguagem amigável

### 1.2 Importancia Estrategica

O Portal Self-Service é crítico para:

- **Redução de Carga no Suporte**: Self-service reduz chamados evitáveis via FAQ/base conhecimento (meta: 20-30% economia)
- **Autonomia do Usuário**: Usuários acompanham seus próprios tickets sem depender de equipe; notificações automáticas (real-time via SignalR)
- **Experiência Mobile-First**: PWA com suporte completo a mobile (Android/iOS); funciona offline (cache)
- **Velocidade de Resolução**: Wizard 3-passos vs forms complexos reduz tempo de preenchimento (< 2 min vs 10 min)
- **Satisfação Medida (CSAT)**: Avaliação imediata pós-resolução (interface NPS inline)
- **Conformidade Contratual**: Usuários visualizam SLA em linguagem clara (não técnica); aumenta transparência

### 1.3 Conceitos Fundamentais

**Portal Self-Service**: Interface web/mobile com foco em usabilidade, reduzindo atrito. Usuário vê APENAS seus próprios chamados (isolamento por ClienteId + UserId).

**Wizard de 3 Passos**: Fluxo guiado sem campos complexos:
1. **Selecionar Serviço/Categoria** (dropdown ou cards com icons)
2. **Descrever Problema** (texto livre + upload opcional)
3. **Confirmar Detalhes** (revisão + envio com sucesso visual)

**CSAT Inline**: Logo após resolução, popup solicitando 1-5 stars sem deixar portal (sem redirect).

**Base de Conhecimento Integrada**: FAQ exibida como sugestões enquanto digita (busca em tempo real).

**Catálogo de Serviços (RF021)**: Integração para pré-popularizar dropdown de categorias com descrições.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **UI** | ASP.NET WebForms (aspx) com jQuery | Angular 19 Standalone Components + Reactive Forms + PrimeNG |
| **Mobile** | Não responsivo; desktop-only | PWA com suporte offline (Service Workers) |
| **Formulário** | Todas as 20+ campos obrigatórios na mesma tela | Wizard 3-passos intuitivo |
| **FAQ Integrada** | Página separada (/FAQ.aspx) | Overlay/modal com busca em tempo real (Ctrl+/) |
| **Notificações** | Polling a cada 30s (pesado) | SignalR real-time + service worker notifications |
| **Upload** | Filesystem local | Azure Blob Storage (escalável) |
| **CSAT** | Email com link externo | Inline na própria tela (sem deixar portal) |
| **Listagem** | Tabela com todas colunas (overflow) | Cards responsivos com filtros modernos |
| **Performance** | ~3s carregamento | <1s (lazy loading + cache) |

### 1.5 Funcionalidades Principais

1. **Portal Restrito** - Usuário vê APENAS seus próprios chamados (filtro automático por UserId)
2. **Wizard 3-Passos para Criar Chamado** - Selecionar categoria → Descrever → Confirmar
3. **Listagem com Cards Responsivos** - Status visual (cores), prioridade, SLA countdown
4. **Detalhes do Chamado** - Descrição, ativos afetados, histórico de atualizações, SLA atual
5. **Comentários Públicos** - Adicionar comentários visíveis (não vê comentários internos)
6. **Upload de Anexos** - Screenshots, logs, documentos (máx 5 MB, tipos: jpg, png, pdf, log, txt)
7. **Acompanhamento em Tempo Real** - SignalR notifica mudanças de status/comentários (sem refresh)
8. **CSAT Avaliação** - Estrelas 1-5 pós-resolução; opcional comentário
9. **FAQ/Base Conhecimento Integrada** - Modal com busca (sugestões enquanto digita)
10. **Catálogo de Serviços** - Integração com RF021 para pré-popular categorias com ícones

---

## 2. REGRAS DE NEGOCIO

### RN-TKT-074-01: Isolamento de Dados por Usuário

**Descricao**: Usuário final NUNCA pode visualizar chamados de outro usuário. Filtro obrigatório: `WHERE UserId = CurrentUserId AND ClienteId = CurrentClienteId`.

**Justificativa**: Confidencialidade; múltiplos usuários podem usar mesmo navegador.

**Implementacao**:
```csharp
public class GetMyTicketsQuery : IRequest<PaginatedList<TicketDto>>
{
    public int PageNumber { get; set; } = 1;
    public int PageSize { get; set; } = 10;
}

public class GetMyTicketsQueryHandler : IRequestHandler<GetMyTicketsQuery, PaginatedList<TicketDto>>
{
    private readonly ICurrentUserService _currentUser;

    public async Task<PaginatedList<TicketDto>> Handle(GetMyTicketsQuery request, CancellationToken ct)
    {
        var tickets = await _context.Tickets
            .Where(t => t.UserId == _currentUser.UserId &&
                       t.ClienteId == _currentUser.ClienteId &&
                       !t.IsDeleted)
            .OrderByDescending(t => t.CreatedAt)
            .ToPaginatedListAsync(request.PageNumber, request.PageSize, ct);

        return tickets;
    }
}
```

**Exemplos**:
- ✓ João acessa /my-tickets → vê apenas seus chamados (Ticket#001-003)
- ✗ João tenta acessar /api/tickets/999 (de Maria) → HTTP 403 (proibido)

---

### RN-TKT-074-02: Wizard 3-Passos Obrigatório para Criar Chamado

**Descricao**: Criação de chamado APENAS via wizard (não via API direta para usuários finais). Passos: (1) Selecionar categoria/serviço, (2) Descrever problema, (3) Confirmar. Cada passo valida antes de avançar.

**Justificativa**: Simplifica UX; guia usuário através de campos obrigatórios sem sobrecarregar.

**Implementacao**:
```csharp
// Passo 1: Selecionar categoria
public class SelectCategoryCommand : IRequest<int>
{
    [Required]
    public int ServiceId { get; set; }  // FK para ServicoCategoria (RF021)

    public int? RecommendedCategoryId { get; set; }  // Se buscou FAQ
}

// Passo 2: Descrever
public class DescribeIssueCommand : IRequest<string>
{
    [Required]
    [MinLength(20, ErrorMessage = "RN-TKT-074-02: Mínimo 20 caracteres")]
    [MaxLength(2000)]
    public string Descricao { get; set; }

    [MaxFileSize(5 * 1024 * 1024)]
    public IFormFile Attachment { get; set; }
}

// Passo 3: Confirmar + Criar
public class CreateMyTicketCommand : IRequest<TicketDto>
{
    [Required]
    public int StepOneServiceId { get; set; }

    [Required]
    public string StepTwoDescricao { get; set; }

    public IFormFile StepTwoAttachment { get; set; }
}

public class CreateMyTicketHandler : IRequestHandler<CreateMyTicketCommand, TicketDto>
{
    public async Task<TicketDto> Handle(CreateMyTicketCommand request, CancellationToken ct)
    {
        // Validações aqui...

        var ticket = new Ticket
        {
            UserId = _currentUser.UserId,
            ClienteId = _currentUser.ClienteId,
            ServiceCategoryId = request.StepOneServiceId,
            Descricao = request.StepTwoDescricao,
            Status = TicketStatus.Novo,
            CreatedAt = DateTime.UtcNow
        };

        // Upload attachment se houver
        if (request.StepTwoAttachment != null)
        {
            var url = await _blobService.UploadAsync(request.StepTwoAttachment, ct);
            ticket.AttachmentUrl = url;
        }

        _context.Tickets.Add(ticket);
        await _context.SaveChangesAsync(ct);

        // Auditoria (RN-TKT-074-09)
        await _auditService.LogAsync("TKT_TICKET_CREATED_SELFSERVICE", ticket.Id, ct);

        return _mapper.Map<TicketDto>(ticket);
    }
}
```

**Exemplos**:
- ✓ Passo 1: Usuário seleciona "Internet/Conectividade" → avança
- ✗ Passo 2: Descrição vazia → erro inline, não avança

---

### RN-TKT-074-03: Categorias Pré-Carregadas do Catálogo (RF021)

**Descricao**: Dropdown de categorias no Passo 1 é preenchido automaticamente a partir de ServicoCategoria (RF021). Se serviço tem ícone, exibir como cards com thumbnail (não dropdown simples).

**Justificativa**: Reutilização de dados; UX visual melhor; integração com catálogo corporativo.

**Implementacao**:
```csharp
public class GetServicoCategoriaParaTicketQuery : IRequest<List<ServicoCategoriaCardDto>>
{
    // Sem filtros; retorna todas categorias ativas
}

public class GetServicoCategoriaParaTicketQueryHandler
    : IRequestHandler<GetServicoCategoriaParaTicketQuery, List<ServicoCategoriaCardDto>>
{
    public async Task<List<ServicoCategoriaCardDto>> Handle(
        GetServicoCategoriaParaTicketQuery request, CancellationToken ct)
    {
        var categorias = await _context.ServicoCategoria
            .Where(s => s.Ativo && s.ClienteId == _currentUser.ClienteId)
            .Select(s => new ServicoCategoriaCardDto
            {
                Id = s.Id,
                Nome = s.Nome,
                Descricao = s.Descricao,
                IconUrl = s.IconUrl,  // Vem de RF021
                TicketsAbertosTotal = s.Tickets.Count(t => !t.IsDeleted)
            })
            .ToListAsync(ct);

        return categorias;
    }
}
```

**Exemplos**:
- RF021 tem Serviço "Internet" com icon "wifi.svg" → Exibir como card com icon
- Categoria desativa em RF021 → Não aparece no dropdown de RF074

---

### RN-TKT-074-04: FAQ Integrada com Busca em Tempo Real

**Descricao**: Modal/overlay com busca integrada (ativável via Ctrl+/ ou link "Consulte FAQ Primeiro"). Busca em tempo real em artigos da Base de Conhecimento (RF070). Se usuário encontrar resposta, não cria chamado.

**Justificativa**: Reduz 20-30% dos chamados evitáveis; auto-resolução melhora satisfação.

**Implementacao**:
```csharp
public class SearchFaqArticlesQuery : IRequest<List<FaqArticleDto>>
{
    [MinLength(3)]
    public string SearchTerm { get; set; }

    public int? CategoryId { get; set; }  // Filtro opcional por categoria
}

public class SearchFaqArticlesQueryHandler : IRequestHandler<SearchFaqArticlesQuery, List<FaqArticleDto>>
{
    public async Task<List<FaqArticleDto>> Handle(SearchFaqArticlesQuery request, CancellationToken ct)
    {
        var results = await _context.FaqArticles
            .Where(a => a.Ativo && a.ClienteId == _currentUser.ClienteId &&
                       (a.Titulo.Contains(request.SearchTerm) ||
                        a.Conteudo.Contains(request.SearchTerm)))
            .OrderByDescending(a => a.Relevancia)
            .Take(5)  // Top 5 resultados
            .Select(a => new FaqArticleDto
            {
                Id = a.Id,
                Titulo = a.Titulo,
                Resumo = a.Conteudo.Substring(0, 200) + "...",
                Url = $"/knowledge-base/{a.Id}"
            })
            .ToListAsync(ct);

        return results;
    }
}
```

**Exemplos**:
- Usuário digita "senha expirou" → FAQ retorna 3 artigos sobre reset de senha
- Usuário lê artigo, auto-resolve → não cria chamado (reduz carga)

---

### RN-TKT-074-05: Notificações em Tempo Real via SignalR

**Descricao**: Quando um chamado recebe comentário da equipe OU muda de status, usuário recebe notificação em tempo real (não precisa refresh). Notificações são persistidas (banco de dados) e exibidas em bell icon com contador.

**Justificativa**: Transparência; melhora experiência (não fica checando manualmente); ITIL v4 best practice.

**Implementacao**:
```csharp
// Backend: Quando técnico adiciona comentário
public class AddCommentHandler : IRequestHandler<AddCommentCommand, CommentDto>
{
    private readonly IHubContext<TicketHub> _hubContext;

    public async Task<CommentDto> Handle(AddCommentCommand request, CancellationToken ct)
    {
        var comment = new Comment { ... };
        _context.Comments.Add(comment);
        await _context.SaveChangesAsync(ct);

        // Notificar usuário em tempo real
        await _hubContext.Clients.User(comment.Ticket.UserId.ToString())
            .SendAsync("ReceiveTicketUpdate", new
            {
                ticketId = comment.TicketId,
                type = "comment",
                message = "Novo comentário de suporte",
                timestamp = DateTime.UtcNow
            }, cancellationToken: ct);

        return _mapper.Map<CommentDto>(comment);
    }
}

// Frontend (Angular): Escutar notificações
@Injectable({ providedIn: 'root' })
export class TicketHubService {
    public ticketUpdated$ = new Subject<TicketUpdate>();

    constructor(private signalRService: SignalRService) {
        this.signalRService.on('ReceiveTicketUpdate', (update) => {
            this.ticketUpdated$.next(update);
        });
    }
}

// Component: Atualizar tela sem refresh
export class TicketDetailComponent implements OnInit {
    constructor(private ticketHub: TicketHubService) {}

    ngOnInit() {
        this.ticketHub.ticketUpdated$.subscribe(update => {
            if (update.ticketId === this.ticketId) {
                // Atualizar tela (lazy reload, sem flash)
                this.loadTicket();
                this.showNotificationBadge();
            }
        });
    }
}
```

**Exemplos**:
- 14:30h: Técnico adiciona "Testando solução..." → Usuário recebe notificação em tempo real
- Usuário vê bell icon com contador (+1), clica e vê novo comentário

---

### RN-TKT-074-06: Comentários Públicos Apenas (Sem Acesso a Internos)

**Descricao**: Usuário final visualiza APENAS comentários com `Visibility = External`. Comentários internos (equipe coordenação) NUNCA são exibidos.

**Justificativa**: Confidencialidade de processos internos; evita informações sensíveis.

**Implementacao**:
```csharp
public class GetMyTicketCommentsQuery : IRequest<List<CommentDto>>
{
    [Required]
    public int TicketId { get; set; }
}

public class GetMyTicketCommentsQueryHandler : IRequestHandler<GetMyTicketCommentsQuery, List<CommentDto>>
{
    public async Task<List<CommentDto>> Handle(GetMyTicketCommentsQuery request, CancellationToken ct)
    {
        // Validar ownership
        var ticket = await _context.Tickets.FindAsync(request.TicketId, cancellationToken: ct);
        if (ticket?.UserId != _currentUser.UserId)
            throw new UnauthorizedException("RN-TKT-074-06: Acesso negado");

        var comments = await _context.Comments
            .Where(c => c.TicketId == request.TicketId &&
                       c.Visibility == CommentVisibilityEnum.External)  // APENAS externos
            .OrderByDescending(c => c.CreatedAt)
            .ToListAsync(ct);

        return _mapper.Map<List<CommentDto>>(comments);
    }
}
```

**Exemplos**:
- Técnico escreve (Internal): "Aguardando peça do fabricante (ETA 30 dias)"
- Técnico escreve (External): "Sua solicitação está em processamento"
- Usuário vê: apenas o comentário (External); não vê o (Internal)

---

### RN-TKT-074-07: CSAT Avaliação Pós-Resolução Inline

**Descricao**: Quando chamado muda para `Status = Resolvido`, exibir popup inline (não modal que bloqueia, não email externo) solicitando: (1) Avaliação 1-5 stars, (2) Comentário opcional. Usuário pode ignorar ou responder. Avaliação é registrada em tabela `TicketSatisfaction`.

**Justificativa**: CSAT imediato; coleta não-intrusiva; melhora coleta de feedback.

**Implementacao**:
```csharp
public class SubmitSatisfactionSurveyCommand : IRequest<bool>
{
    [Required]
    public int TicketId { get; set; }

    [Range(1, 5)]
    public int Stars { get; set; }

    [MaxLength(500)]
    public string? Comentario { get; set; }
}

public class SubmitSatisfactionSurveyHandler : IRequestHandler<SubmitSatisfactionSurveyCommand, bool>
{
    public async Task<bool> Handle(SubmitSatisfactionSurveyCommand request, CancellationToken ct)
    {
        var satisfaction = new TicketSatisfaction
        {
            TicketId = request.TicketId,
            Rating = request.Stars,
            Comments = request.Comentario,
            SubmittedAt = DateTime.UtcNow,
            UserId = _currentUser.UserId
        };

        _context.TicketSatisfactions.Add(satisfaction);
        await _context.SaveChangesAsync(ct);

        // Log auditoria
        await _auditService.LogAsync("TKT_SATISFACTION_SUBMITTED", request.TicketId, ct);

        return true;
    }
}

// Frontend: Mostrar popup quando status = Resolvido
export class TicketDetailComponent {
    onTicketStatusChanged(newStatus: string) {
        if (newStatus === 'Resolvido') {
            this.showSatisfactionPopup();  // Toast + snackbar, não modal bloqueador
        }
    }
}
```

**Exemplos**:
- 15:00h: Técnico marca chamado como Resolvido
- Usuário vê toast no canto: "Sua solicitação foi resolvida! Rate your experience ⭐"
- Usuário clica 5 stars → Avaliação enviada

---

### RN-TKT-074-08: Upload de Anexos com Validação e Antivírus

**Descricao**: Usuário pode fazer upload de máx 1 arquivo por comentário (máx 5 MB). Tipos permitidos: jpg, png, pdf, log, txt. Arquivo é escaneado por antivírus (ClamAV) antes de armazenar. Arquivo armazenado em Azure Blob Storage (não filesystem local).

**Justificativa**: Segurança; escalabilidade; conformidade (não armazenar em servidor local).

**Implementacao**:
```csharp
[AttributeUsage(AttributeTargets.Property)]
public class MaxFileSizeAttribute : ValidationAttribute
{
    private const int MaxBytes = 5 * 1024 * 1024;  // 5 MB

    public override bool IsValid(object? value)
    {
        if (value is not IFormFile file) return true;
        return file.Length <= MaxBytes;
    }
}

public class AddCommentCommand : IRequest<CommentDto>
{
    [Required]
    public int TicketId { get; set; }

    [MaxLength(2000)]
    public string Text { get; set; }

    [MaxFileSize]
    public IFormFile? Attachment { get; set; }
}

public class AddCommentHandler : IRequestHandler<AddCommentCommand, CommentDto>
{
    private readonly IClamAvService _antivirus;
    private readonly IAzureBlobService _blob;

    public async Task<CommentDto> Handle(AddCommentCommand request, CancellationToken ct)
    {
        if (request.Attachment != null)
        {
            // Validar MIME type
            var allowedMimes = new[] { "image/jpeg", "image/png", "application/pdf", "text/plain", "text/x-log" };
            if (!allowedMimes.Contains(request.Attachment.ContentType))
                throw new ValidationException("RN-TKT-074-08: Tipo de arquivo não permitido");

            // Escanear por antivírus
            var isClean = await _antivirus.ScanAsync(request.Attachment.OpenReadStream(), ct);
            if (!isClean)
                throw new SecurityException("RN-TKT-074-08: Arquivo contém malware detectado");

            // Armazenar no blob
            var blobUrl = await _blob.UploadAsync(
                $"tickets/{request.TicketId}/{Guid.NewGuid()}",
                request.Attachment.OpenReadStream(),
                request.Attachment.ContentType,
                ct
            );

            // Salvar referência no comment
            var comment = new Comment
            {
                TicketId = request.TicketId,
                Text = request.Text,
                AttachmentUrl = blobUrl,
                AttachmentFileName = Path.GetFileName(request.Attachment.FileName)
            };

            _context.Comments.Add(comment);
            await _context.SaveChangesAsync(ct);

            return _mapper.Map<CommentDto>(comment);
        }

        return new CommentDto();
    }
}
```

**Exemplos**:
- ✓ Usuário faz upload de screenshot.png (2 MB) → Escaneado, armazenado, referência salva
- ✗ Usuário tenta upload de malware.exe → Antivírus rejeita, erro exibido

---

### RN-TKT-074-09: Auditoria Completa de Ações do Usuário

**Descricao**: Toda ação do usuário final em seu portal é auditada: criação, comentário, upload, CSAT. Auditoria registra usuário, timestamp, ação, dados relevantes. Retenção: 7 anos (LGPD).

**Justificativa**: Conformidade; investigação de disputas; rastreamento de acesso.

**Implementacao**:
```csharp
[AttributeUsage(AttributeTargets.Class)]
public class AuditableAttribute : Attribute
{
    public string AuditCode { get; set; }
}

[Auditable(AuditCode = "TKT_SELFSERVICE_CREATE")]
public class CreateMyTicketCommand : IRequest<TicketDto> { }

public class AuditBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly AppDbContext _context;
    private readonly ICurrentUserService _currentUser;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken ct)
    {
        var auditAttr = typeof(TRequest).GetCustomAttribute<AuditableAttribute>();
        if (auditAttr != null)
        {
            var auditLog = new AuditLog
            {
                Code = auditAttr.AuditCode,
                UserId = _currentUser.UserId,
                RequestType = typeof(TRequest).Name,
                RequestData = JsonConvert.SerializeObject(request),
                CreatedAt = DateTime.UtcNow
            };

            _context.AuditLogs.Add(auditLog);
        }

        var response = await next();

        if (auditAttr != null)
            await _context.SaveChangesAsync(ct);

        return response;
    }
}
```

**Exemplos**:
- 10:15h: João cria Ticket#001 via wizard → `AuditLog { UserId: 123, Code: TKT_SELFSERVICE_CREATE, TicketId: 1 }`
- 10:20h: João adiciona comentário → `AuditLog { UserId: 123, Code: TKT_COMMENT_ADD, TicketId: 1 }`

---

### RN-TKT-074-10: PWA com Suporte Offline (Service Workers)

**Descricao**: Portal é uma PWA (Progressive Web App) com suporte offline. Service Worker cache ativos: lista de tickets do usuário, categorias, FAQ. Quando offline, usuário pode ler seus tickets + FAQ; ao voltar online, sincroniza automaticamente.

**Justificativa**: Disponibilidade mesmo com conexão ruim; experiência mobile-first; competitivo vs apps nativas.

**Implementacao**:
```typescript
// Angular service
@Injectable({ providedIn: 'root' })
export class TicketOfflineService {
    constructor(
        private sw: ServiceWorkerContainer,
        private db: IndexedDB
    ) {}

    async cacheTicketsForOffline(tickets: Ticket[]): Promise<void> {
        // Armazenar no IndexedDB
        const store = await this.db.open('tickets-cache');
        for (const ticket of tickets) {
            await store.put(ticket);
        }
    }

    async getTicketsOffline(): Promise<Ticket[]> {
        const store = await this.db.open('tickets-cache');
        return await store.getAll();
    }
}

// Service Worker (sw.js)
self.addEventListener('fetch', (event) => {
    if (event.request.url.includes('/api/my-tickets')) {
        event.respondWith(
            fetch(event.request)
                .then(response => {
                    // Atualizar cache
                    const clone = response.clone();
                    caches.open('tickets-cache').then(cache => {
                        cache.put(event.request, clone);
                    });
                    return response;
                })
                .catch(() => {
                    // Retornar do cache offline
                    return caches.match(event.request);
                })
        );
    }
});

// Manifest PWA
{
    "name": "IControlIT Portal",
    "short_name": "Portal IC",
    "start_url": "/portal",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#007bff",
    "scope": "/portal",
    "icons": [...]
}
```

**Exemplos**:
- Usuário acessa portal no 4G → Carrega tickets, caches offline
- Entra em túnel (sem internet) → Vê seus tickets do cache, pode ler FAQ
- Sai do túnel → Sincroniza automaticamente novos comentários

---

## 3. REFERENCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `SC_CLIENTE_NOME` (específico por cliente)

**Tabelas Compartilhadas com RF073**:
- `Solicitacao` (Tickets)
- `Solicitacao_Item` (Ativos afetados)
- `Solicitacao_Tipo` (Categorias)
- `Solicitacao_SLA` (SLA)

**Tabelas Novas (RF074 apenas)**:
```sql
CREATE TABLE [dbo].[TicketSatisfaction](
    [Id_Satisfacao] [int] IDENTITY(1,1) NOT NULL,
    [Id_Solicitacao] [int] NOT NULL,
    [Nm_Rating] [int] NOT NULL,  -- 1-5 stars
    [Ds_Comentario] [varchar](500) NULL,
    [Dt_Envio] [datetime] NOT NULL,
    [Cd_Usuario] [int] NOT NULL,
    CONSTRAINT [PK_Satisfacao] PRIMARY KEY ([Id_Satisfacao]),
    CONSTRAINT [FK_Satisfacao_Solicitacao] FOREIGN KEY ([Id_Solicitacao]) REFERENCES [Solicitacao]
)
```

### 3.2 Stored Procedures Legado

| Procedure | Migracao |
|-----------|----------|
| `pa_Solicitacao_Lista_ByUser` | Query `GetMyTicketsQuery` (adicionado) |
| `pa_Solicitacao_Detalhes` | Compartilhado com RF073 |
| `pa_Solicitacao_Incluir` | Compartilhado com RF073 (via wizard) |

### 3.3 Telas ASPX

| Pagina Legado | Tela Moderna (RF074) |
|---------------|---------------------|
| `Chamado/Chamado.aspx` (listagem geral) | `/my-tickets` (apenas do usuário) |
| `Chamado/Chamado_Consulta.aspx` | `/my-tickets/{id}` |
| `Chamado/Chamado_Solicitacao.aspx` | `/my-tickets/new` (wizard 3-passos) |
| (sem equivalente) | `/faq` (FAQ integrada) |

### 3.4 WebServices Legado

**Arquivo**: `D:\IC2\ic1_legado\WS_IControlIT\WSChamado.asmx.vb`

| Metodo Legado | Endpoint Moderno (RF074) |
|---------------|------------------------|
| `Solicitacao_Incluir()` | `POST /api/my-tickets` (wizard) |
| `Solicitacao_Lista_ByUser()` | `GET /api/my-tickets?page=1&limit=10` |
| `Solicitacao_Detalhes()` | `GET /api/my-tickets/{id}` |

---

## 4. INTEGRACOES OBRIGATORIAS

### 4.1 Central de Funcionalidades (Feature Flags)

```json
{
    "featureKey": "SELFSERVICE_PORTAL_ENABLED",
    "nome": "Portal Self-Service",
    "descricao": "Portal de gestão de chamados para usuários finais",
    "habilitado": true,
    "isSystemFeature": false
},
{
    "featureKey": "SELFSERVICE_CSAT_INLINE",
    "nome": "CSAT Inline",
    "descricao": "Avaliação de satisfação imediata (não email)",
    "habilitado": true,
    "isSystemFeature": false
},
{
    "featureKey": "SELFSERVICE_FAQ_INTEGRATION",
    "nome": "FAQ Integrada",
    "descricao": "Busca de FAQ dentro do portal (integração RF070)",
    "habilitado": true,
    "isSystemFeature": false
},
{
    "featureKey": "SELFSERVICE_OFFLINE_MODE",
    "nome": "Modo Offline (PWA)",
    "descricao": "Suporte offline com Service Workers",
    "habilitado": true,
    "isSystemFeature": false
}
```

### 4.2 Internacionalizacao (i18n)

```json
{
    "selfservice": {
        "portal": {
            "title": "Meus Chamados",
            "description": "Acompanhe suas solicitações de suporte"
        },
        "wizard": {
            "step1": "Selecionar Serviço",
            "step2": "Descrever Problema",
            "step3": "Confirmar",
            "create_success": "Chamado criado com sucesso! Número: {{ticketNumber}}",
            "creating": "Criando chamado..."
        },
        "tickets": {
            "my_tickets": "Meus Chamados",
            "no_tickets": "Você não tem chamados",
            "status_new": "Novo",
            "status_assigned": "Atribuído",
            "status_in_progress": "Em Andamento",
            "status_resolved": "Resolvido",
            "status_closed": "Fechado",
            "created": "Criado em",
            "sla_due": "Vencimento SLA",
            "view_details": "Ver Detalhes"
        },
        "csat": {
            "title": "Avalie Nosso Atendimento",
            "question": "Como foi sua experiência?",
            "comment_placeholder": "Comentário (opcional)",
            "submit": "Enviar Avaliação",
            "thank_you": "Obrigado pelo feedback!"
        },
        "faq": {
            "title": "Base de Conhecimento",
            "search_placeholder": "Buscar artigos...",
            "no_results": "Nenhum artigo encontrado",
            "read_more": "Ler Mais",
            "did_this_help": "Isso resolveu seu problema?"
        },
        "comments": {
            "add_comment": "Adicionar Comentário",
            "attachments": "Anexos",
            "upload_file": "Selecionar Arquivo (máx 5 MB)",
            "comment_placeholder": "Seu comentário aqui...",
            "no_comments": "Sem comentários ainda"
        }
    }
}
```

### 4.3 Auditoria

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Criar ticket (self-service) | `TKT_SELFSERVICE_CREATE` | ServiceId, Descricao, Attachment URL |
| Visualizar ticket | `TKT_SELFSERVICE_VIEW` | TicketId, Timestamp |
| Adicionar comentário | `TKT_SELFSERVICE_COMMENT` | TicketId, Comentario (resumido), Attachment URL |
| Submeter CSAT | `TKT_SELFSERVICE_CSAT` | TicketId, Rating (1-5), Comentario |
| Acessar FAQ | `TKT_SELFSERVICE_FAQ_VIEW` | ArticleId, Search term |

**Retencao**: 7 anos (LGPD)

### 4.4 Controle de Acesso (RBAC)

| Permissao | Descricao | Perfis |
|-----------|-----------|--------|
| `tkt:selfservice:read` | Visualizar meus chamados | Solicitante |
| `tkt:selfservice:create` | Criar novo chamado via portal | Solicitante |
| `tkt:selfservice:comment` | Adicionar comentário público | Solicitante |
| `tkt:selfservice:csat` | Enviar avaliação CSAT | Solicitante |
| `tkt:faq:read` | Acessar FAQ/base conhecimento | Solicitante |

---

## 5. ENDPOINTS DA API

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| **GET** | `/api/my-tickets` | Listar meus chamados (paginado) | `tkt:selfservice:read` |
| **GET** | `/api/my-tickets/{id}` | Detalhes do meu chamado | `tkt:selfservice:read` |
| **POST** | `/api/my-tickets` | Criar novo chamado (wizard) | `tkt:selfservice:create` |
| **GET** | `/api/my-tickets/{id}/comments` | Listar comentários públicos | `tkt:selfservice:read` |
| **POST** | `/api/my-tickets/{id}/comments` | Adicionar comentário + arquivo | `tkt:selfservice:comment` |
| **POST** | `/api/my-tickets/{id}/satisfaction` | Submeter CSAT avaliação | `tkt:selfservice:csat` |
| **GET** | `/api/service-categories` | Listar categorias (wizard passo 1) | `tkt:selfservice:read` |
| **GET** | `/api/faq/search` | Buscar artigos FAQ | `tkt:faq:read` |
| **GET** | `/api/faq/{id}` | Detalhes artigo FAQ | `tkt:faq:read` |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Criar Chamado (Wizard 3-Passos)

```
Usuario acessa /my-tickets/new
    |
    v
Exibir Passo 1: Cards com Categorias (de RF021)
    |
    v
Usuario seleciona categoria + clica "Continuar"
    |
    v
Exibir Passo 2: Form textarea (Descrever Problema)
    |
    +--- Usuario digita descrição
    |    Sistema busca FAQ em tempo real (RN-TKT-074-04)
    |    Sugestões aparecem abaixo do textarea
    |
    v
Usuario clica "Continuar" (validar min 20 chars)
    |
    v
Exibir Passo 3: Revisão (resumo do que vai ser enviado)
    |
    v
Usuario clica "Enviar Chamado"
    |
    v
POST /api/my-tickets
    |
    +--- Validar (RN-TKT-074-01, RN-TKT-074-02)
    |
    +--- Upload arquivo se houver (RN-TKT-074-08)
    |
    +--- Criar Ticket no BD
    |
    v
Exibir tela de sucesso: "Chamado CHD-2025-001 criado!"
    |
    v
Redirecionar para /my-tickets/CHD-2025-001 (detalhe)
```

### 6.2 Fluxo de Acompanhamento em Tempo Real

```
Usuario abre /my-tickets/CHD-2025-001
    |
    v
WebSocket SignalR conecta
    |
    v
Exibir status, comentários, SLA countdown
    |
    v
Técnico adiciona comentário "Problema identificado, testando solução..."
    |
    v
SignalR notifica usuario:
    - Bell icon: +1 contador
    - Toast: "Novo comentário de suporte"
    - Tela atualiza (lazy load, sem refresh completo)
    |
    v
Usuario clica bell → vê novo comentário
    |
    v
Usuario adiciona comentário público (RN-TKT-074-06)
    |
    v
Comentário persiste no BD + notifica técnico via SignalR
```

### 6.3 Fluxo de CSAT Pós-Resolução

```
Técnico marca status = Resolvido (RF073)
    |
    v
SignalR notifica usuario
    |
    v
Tela de detalhe exibe toast:
"Sua solicitação foi resolvida! ⭐ Avalie seu atendimento"
    |
    +--- Usuario clica 5 stars
    |
    +--- Backend registra avaliação (RN-TKT-074-07)
    |
    +--- Toast: "Obrigado pelo feedback!"
    |
    v
(Opcional) Usuario clica para deixar comentário
    |
    v
Dados salvos para analytics (Dashboard KPI em RF073)
```

---

## 7. SEGURANCA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **Isolamento por UserId** | WHERE UserId = CurrentUserId; usuário NUNCA vê tickets de outro |
| **Validação de Entrada** | Min/Max length, enum validation, MIME type whitelist |
| **XSS Protection** | Angular XSS guard; comentários escapados |
| **CSRF Token** | HttpOnly cookie + Angular interceptor |
| **Rate Limiting** | 10 tickets/hora/usuario; 5 comentários/min |
| **Antivírus Scanning** | ClamAV antes de armazenar arquivo |
| **Soft Delete** | Sempre marcar IsDeleted=true; nunca deletar fisicamente |
| **Auditoria Completa** | Toda ação logged (RN-TKT-074-09) |
| **HTTPS Obrigatório** | TLS 1.2+ |
| **Blob Storage Seguro** | Arquivo com nome aleatório, sem exposição de paths |

### 7.2 Testes de Seguranca Obrigatorios

- [ ] Tentar acessar `/api/my-tickets/999999` (ticket de outro) → HTTP 403
- [ ] Usuário A tenta editar comentário de Usuário B → HTTP 403
- [ ] XSS em comentário (`<script>alert()</script>`) → Escapado e renderizado como texto
- [ ] Upload de arquivo `.exe` → Rejeitado (MIME type whitelist)
- [ ] SQL Injection em busca FAQ → Parametrizado, sem risco
- [ ] Rate limiting: 11º ticket em 1h → HTTP 429 Too Many Requests
- [ ] Antivírus: arquivo infectado → Detectado, rejeitado
- [ ] Soft delete: ticket marcado `IsDeleted=true` → Não aparece em listagens
- [ ] Auditoria: confirmar que senhas/dados sensíveis não são logados

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao | Dono |
|-----|------|---------|------|
| **Taxa de Auto-Resolução via FAQ** | ≥ 20% | (Buscas_FAQ_sem_criar_ticket / Buscas_FAQ_totais) * 100 | Produto |
| **Tempo de Criação via Wizard** | < 2 min | AVG(tempo_completo_wizard) | UX |
| **CSAT Médio** | ≥ 4.0 stars | AVG(TicketSatisfaction.Rating) | Produto |
| **Taxa de Resposta CSAT** | ≥ 60% | (Tickets_com_CSAT / Tickets_Resolvidos) * 100 | Produto |
| **Adoção de PWA Offline** | ≥ 10% | (Usuarios_com_SW_instalado / Total_usuarios) * 100 | Engenharia |
| **Performance P75** | < 1s | P75 do tempo de carregamento de `/my-tickets` | Engenharia |
| **Taxa de Upload com Sucesso** | ≥ 99% | (Uploads_sucesso / Uploads_tentados) * 100 | Infraestrutura |
| **Taxa de Detecção de Malware** | 100% | Arquivos infectados bloqueados | Segurança |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **FAQ Não Resolve** | CSAT < 3 stars após acessar FAQ | Revisar artigo FAQ |
| **Wizard Abandono** | 30%+ drop off em passo 2 | Revisar UX; simplificar campo |
| **SignalR Desconexão** | Notificações não chegam | Verificar WebSocket; failover |
| **Upload Falha Frequente** | Taxa < 95% em 1h | Verificar storage Azure; retry logic |
| **Taxa Malware Alta** | > 5 detecções/dia | Análise de origem; notificar admin |

---

## 9. PROXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-RF074](./MD-RF074-Gestao-Chamados-SelfService.md)
2. **Casos de Uso**: Criar [UC-RF074](./UC-RF074-Gestao-Chamados-SelfService.md)
3. **Implementacao Frontend**: Angular 19 Standalone Components (wizard, detail, CSAT, FAQ)
4. **Implementacao Backend**: Commands/Queries + Handlers (.NET 10 + SignalR)
5. **PWA Service Worker**: Implementar cache offline + sync
6. **Integração RFC070**: Busca FAQ com Elasticsearch ou similar
7. **Testes**: Cenários CN, TCs, E2E com Playwright
8. **Deploy**: HOM para validação de usabilidade; PRD após aprovação

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versao inicial - RF074 completo com 10 RNs, 4 integrações, 13 endpoints, 3 fluxos, segurança e métricas | IControlIT Architect |

---

**Ultima Atualizacao**: 2025-12-28
**Autor**: IControlIT Architect Agent
**Revisao**: Pendente de Aprovação
