# RF056 - Gestão de Filas de Atendimento

## 1. RESUMO EXECUTIVO

### 1.1 Visão Geral
Sistema de gestão de filas inteligentes para distribuição automática de solicitações entre atendentes com base em especialidade, carga de trabalho, SLA e prioridade. Suporta múltiplas filas por tipo de serviço, balanceamento automático, escalação e métricas em tempo real.

### 1.2 Importância Estratégica
- **Eficiência:** Redução de 40% no tempo médio de atendimento
- **Justiça:** Distribuição equilibrada de carga entre atendentes
- **SLA:** Priorização automática de solicitações urgentes
- **Especialização:** Routing inteligente por skill dos atendentes
- **Métricas:** Dashboards em tempo real de performance

### 1.3 Funcionalidades Principais

1. **Filas Inteligentes**
   - Múltiplas filas por tipo (Mobile, Desktop, Rede, Licenças)
   - Priorização automática por SLA
   - Routing baseado em skills dos atendentes
   - Balanceamento de carga dinâmico

2. **Distribuição Automática**
   - Round-robin com pesos por skill level
   - Menor carga de trabalho primeiro
   - Skill matching obrigatório
   - Escalonamento automático se não atendido

3. **Gestão de Disponibilidade**
   - Status de atendentes (Disponível, Ocupado, Ausente, Pausa)
   - Pausas automáticas (almoço, café)
   - Indisponibilidade agendada
   - Distribuição para substitutos

4. **Métricas e KPIs**
   - Tempo médio de espera na fila
   - Taxa de atendimento dentro do SLA
   - Quantidade de atendimentos por atendente
   - Tempo médio de resolução

---

## 2. REGRAS DE NEGÓCIO

### RN001: Priorização Automática na Fila
**Descrição:** Solicitações na fila devem ser ordenadas por: 1) Prioridade, 2) % SLA consumido, 3) Tempo de espera.

**Implementação:**
```csharp
public List<Solicitacao> OrdenarFila(List<Solicitacao> solicitacoes)
{
    return solicitacoes.OrderByDescending(s => (int)s.Prioridade)
        .ThenByDescending(s => s.PercentualSLAConsumido)
        .ThenBy(s => s.DataAbertura)
        .ToList();
}
```

---

### RN002: Routing por Skills
**Descrição:** Solicitações só podem ser atribuídas a atendentes com skill adequada.

**Implementação:**
```csharp
public class Atendente
{
    public List<Skill> Skills { get; set; }
    public int CargaAtual { get; set; } // Solicitações abertas
    public string Status { get; set; }
}

public async Task<Atendente> SelecionarAtendente(Solicitacao solicitacao)
{
    var atendentesElegiveis = await _context.Atendentes
        .Where(a => a.Status == "DISPONIVEL")
        .Where(a => a.Skills.Any(s => s.Categoria == solicitacao.Categoria))
        .OrderBy(a => a.CargaAtual)
        .ToListAsync();

    return atendentesElegiveis.FirstOrDefault();
}
```

---

### RN003: Balanceamento de Carga
**Descrição:** Distribuir solicitações priorizando atendentes com menor carga atual.

**Implementação:**
```csharp
public async Task DistribuirProximaSolicitacao()
{
    var proximaSolicitacao = await ObterProximaDaFila();
    var atendente = await SelecionarAtendente(proximaSolicitacao);

    if (atendente == null)
    {
        // Sem atendente disponível, manter na fila
        await NotificarSupervisor("Fila sem atendentes disponíveis");
        return;
    }

    proximaSolicitacao.AtendenteId = atendente.Id;
    proximaSolicitacao.Status = "EM_ATENDIMENTO";
    atendente.CargaAtual++;

    await _context.SaveChangesAsync();
    await NotificarAtendente(atendente.Id, proximaSolicitacao);
}
```

---

### RN004: Escalonamento Automático
**Descrição:** Se solicitação ficar >30 min na fila sem atribuição, escalonar para supervisor.

**Implementação:**
```csharp
[Hangfire.RecurringJob("*/10 * * * *")] // A cada 10 min
public async Task VerificarEscalonamentoFila()
{
    var limiteEspera = DateTime.UtcNow.AddMinutes(-30);

    var solicitacoesAtrasadas = await _context.Solicitacoes
        .Where(s => s.Status == "AGUARDANDO_ATENDIMENTO")
        .Where(s => s.DataAbertura < limiteEspera)
        .ToListAsync();

    foreach (var solicitacao in solicitacoesAtrasadas)
    {
        await EscalonarParaSupervisor(solicitacao);
    }
}
```

---

### RN005: Status de Disponibilidade
**Descrição:** Atendentes podem alterar status (Disponível, Pausa, Ausente).

**Implementação:**
```csharp
public async Task AlterarStatus(Guid atendenteId, string novoStatus, string motivo)
{
    var atendente = await _context.Atendentes.FindAsync(atendenteId);
    var statusAnterior = atendente.Status;

    atendente.Status = novoStatus;

    // Log de mudança
    _context.AtendenteHistoricoStatus.Add(new AtendenteHistoricoStatus
    {
        AtendenteId = atendenteId,
        StatusAnterior = statusAnterior,
        StatusNovo = novoStatus,
        Motivo = motivo,
        DataAlteracao = DateTime.UtcNow
    });

    // Se ficou indisponível, redistribuir solicitações
    if (novoStatus != "DISPONIVEL" && atendente.CargaAtual > 0)
    {
        await RedistribuirSolicitacoes(atendenteId);
    }

    await _context.SaveChangesAsync();
}
```

---

### RN006: Pausas Automáticas
**Descrição:** Marcar automaticamente atendentes como "PAUSA" em horários de almoço configurados.

**Implementação:**
```csharp
[Hangfire.RecurringJob("0 12 * * *")] // Meio-dia
public async Task IniciarPausaAlmoco()
{
    var atendentes = await _context.Atendentes
        .Where(a => a.Status == "DISPONIVEL")
        .ToListAsync();

    foreach (var atendente in atendentes)
    {
        await AlterarStatus(atendente.Id, "PAUSA_ALMOCO", "Pausa automática");
    }
}

[Hangfire.RecurringJob("0 13 * * *")] // 13h
public async Task FinalizarPausaAlmoco()
{
    var atendentes = await _context.Atendentes
        .Where(a => a.Status == "PAUSA_ALMOCO")
        .ToListAsync();

    foreach (var atendente in atendentes)
    {
        await AlterarStatus(atendente.Id, "DISPONIVEL", "Retorno de pausa");
    }
}
```

---

### RN007: Limite de Solicitações Simultâneas
**Descrição:** Cada atendente pode ter no máximo 5 solicitações abertas simultaneamente.

**Implementação:**
```csharp
public async Task<Result> AtribuirSolicitacao(Guid solicitacaoId, Guid atendenteId)
{
    var atendente = await _context.Atendentes.FindAsync(atendenteId);

    if (atendente.CargaAtual >= 5)
        return Result.Failure("Atendente atingiu limite de 5 solicitações simultâneas");

    // Atribuir...
}
```

---

### RN008: Métricas em Tempo Real
**Descrição:** Dashboard deve mostrar métricas atualizadas via SignalR a cada 30 segundos.

**Implementação:**
```csharp
[Hangfire.RecurringJob("*/30 * * * * *")] // A cada 30 segundos
public async Task AtualizarDashboard()
{
    var metricas = new MetricasFila
    {
        TotalNaFila = await _context.Solicitacoes.CountAsync(s => s.Status == "AGUARDANDO"),
        TempoMedioEspera = await CalcularTempoMedioEspera(),
        AtendentesDisponiveis = await _context.Atendentes.CountAsync(a => a.Status == "DISPONIVEL"),
        TaxaSLA = await CalcularTaxaSLA()
    };

    await _hubContext.Clients.All.SendAsync("AtualizarMetricas", metricas);
}
```

---

### RN009: Redistribuição em Caso de Ausência
**Descrição:** Se atendente ficar "AUSENTE", redistribuir suas solicitações automaticamente.

**Implementação:**
```csharp
public async Task RedistribuirSolicitacoes(Guid atendenteAusenteId)
{
    var solicitacoesAbertas = await _context.Solicitacoes
        .Where(s => s.AtendenteId == atendenteAusenteId)
        .Where(s => s.Status == "EM_ATENDIMENTO")
        .ToListAsync();

    foreach (var solicitacao in solicitacoesAbertas)
    {
        solicitacao.AtendenteId = null;
        solicitacao.Status = "AGUARDANDO_ATENDIMENTO";

        // Retornar para a fila
        await AdicionarNaFila(solicitacao);
    }

    await _context.SaveChangesAsync();
}
```

---

### RN010: Fila por Especialidade
**Descrição:** Manter filas separadas por categoria (Mobile, Desktop, Rede, etc).

**Implementação:**
```csharp
public class Fila
{
    public Guid Id { get; set; }
    public string Categoria { get; set; } // "MOBILE", "DESKTOP", "REDE"
    public List<Solicitacao> Solicitacoes { get; set; }
    public int TamanhoAtual => Solicitacoes.Count;
    public TimeSpan TempoMedioEspera { get; set; }
}

public async Task<Fila> ObterFila(string categoria)
{
    var solicitacoes = await _context.Solicitacoes
        .Where(s => s.Categoria == categoria && s.Status == "AGUARDANDO")
        .ToListAsync();

    return new Fila
    {
        Categoria = categoria,
        Solicitacoes = OrdenarFila(solicitacoes)
    };
}
```

---

### RN011: Priorização de VIPs
**Descrição:** Solicitações de diretores/CEOs devem ter prioridade máxima na fila.

**Implementação:**
```csharp
public async Task AdicionarNaFila(Solicitacao solicitacao)
{
    var solicitante = await _context.Usuarios.FindAsync(solicitacao.SolicitanteId);

    if (solicitante.Cargo == "CEO" || solicitante.Cargo == "Diretor")
    {
        solicitacao.Prioridade = PrioridadeSolicitacao.Critica;
        solicitacao.VIP = true;
    }

    _context.Solicitacoes.Add(solicitacao);
    await _context.SaveChangesAsync();

    // Notificar próximo atendente disponível imediatamente
    if (solicitacao.VIP)
        await NotificarProximoAtendente();
}
```

---

### RN012: Transferência entre Atendentes
**Descrição:** Atendente pode transferir solicitação para outro atendente com skill adequada.

**Implementação:**
```csharp
public async Task<Result> TransferirSolicitacao(Guid solicitacaoId, Guid novoAtendenteId, string motivo)
{
    var solicitacao = await _context.Solicitacoes.FindAsync(solicitacaoId);
    var novoAtendente = await _context.Atendentes.FindAsync(novoAtendenteId);

    // Validar skill
    if (!novoAtendente.Skills.Any(s => s.Categoria == solicitacao.Categoria))
        return Result.Failure("Atendente destino não possui skill necessária");

    var atendenteAnterior = solicitacao.AtendenteId;

    solicitacao.AtendenteId = novoAtendenteId;

    // Registrar transferência
    _context.TransferenciasSolicitacao.Add(new TransferenciaSolicitacao
    {
        SolicitacaoId = solicitacaoId,
        AtendenteOrigemId = atendenteAnterior.Value,
        AtendenteDestinoId = novoAtendenteId,
        Motivo = motivo,
        DataTransferencia = DateTime.UtcNow
    });

    await _context.SaveChangesAsync();
    return Result.Success();
}
```

---

### RN013: Relatório de Produtividade
**Descrição:** Gerar relatório mensal de produtividade por atendente.

**Implementação:**
```csharp
public async Task<RelatorioAtendente> GerarRelatorio(Guid atendenteId, DateTime mes)
{
    var inicio = new DateTime(mes.Year, mes.Month, 1);
    var fim = inicio.AddMonths(1).AddDays(-1);

    var solicitacoes = await _context.Solicitacoes
        .Where(s => s.AtendenteId == atendenteId)
        .Where(s => s.DataFechamento >= inicio && s.DataFechamento <= fim)
        .ToListAsync();

    return new RelatorioAtendente
    {
        AtendenteId = atendenteId,
        Periodo = mes,
        TotalAtendimentos = solicitacoes.Count,
        TempoMedioResolucao = TimeSpan.FromMinutes(solicitacoes.Average(s => (s.DataFechamento.Value - s.DataAbertura).TotalMinutes)),
        TaxaSLA = (solicitacoes.Count(s => s.DataFechamento <= s.DataLimiteSLA) / (double)solicitacoes.Count) * 100,
        PesquisaSatisfacaoMedia = solicitacoes.Average(s => s.PesquisaSatisfacao?.Nota ?? 0)
    };
}
```

---

### RN014: Fila de Retorno (Follow-up)
**Descrição:** Solicitações reabertas devem retornar automaticamente para o mesmo atendente original.

**Implementação:**
```csharp
public async Task ReabrirSolicitacao(Guid solicitacaoId)
{
    var solicitacao = await _context.Solicitacoes.FindAsync(solicitacaoId);

    solicitacao.Status = "EM_ATENDIMENTO";
    solicitacao.DataReabertura = DateTime.UtcNow;

    // Tentar retornar para mesmo atendente
    var atendenteOriginal = await _context.Atendentes.FindAsync(solicitacao.AtendenteId);

    if (atendenteOriginal.Status == "DISPONIVEL" && atendenteOriginal.CargaAtual < 5)
    {
        await NotificarAtendente(atendenteOriginal.Id, solicitacao);
    }
    else
    {
        // Atendente indisponível, voltar para fila
        solicitacao.AtendenteId = null;
        solicitacao.Status = "AGUARDANDO_ATENDIMENTO";
        await AdicionarNaFila(solicitacao);
    }

    await _context.SaveChangesAsync();
}
```

---

### RN015: SLA Pausado Durante Pendência Externa
**Descrição:** Se atendente marcar solicitação como "Aguardando Cliente", pausar SLA automaticamente.

**Implementação:**
```csharp
public async Task MarcarPendenciaExterna(Guid solicitacaoId, string motivo)
{
    var solicitacao = await _context.Solicitacoes.FindAsync(solicitacaoId);

    solicitacao.Status = "AGUARDANDO_CLIENTE";
    solicitacao.MotivoPendencia = motivo;
    solicitacao.SLA.PausarSLA(motivo);

    await _context.SaveChangesAsync();

    // Notificar cliente
    await _notificationService.Notificar(solicitacao.SolicitanteId,
        $"Sua solicitação #{solicitacao.Numero} está aguardando retorno sobre: {motivo}");
}
```

---

## 3. REQUISITOS NÃO FUNCIONAIS

- Performance: Processar atribuição de fila em < 500ms
- Escalabilidade: Suportar 100 atendentes e 10.000 solicitações/dia
- Disponibilidade: 99.5% uptime
- Tempo real: Atualização de métricas via SignalR < 1s

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades
```sql
INSERT INTO SistemaFuncionalidade (Codigo, Nome, Modulo)
VALUES ('GES.FILAS', 'Gestão de Filas de Atendimento', 'Gestão');
```

### 4.2 RBAC
```csharp
public static class FilasPermissions
{
    public const string ViewQueue = "GES.FILAS.VIEW";
    public const string ManageQueue = "GES.FILAS.MANAGE";
    public const string Transfer = "GES.FILAS.TRANSFER";
}
```

---

## 5. MODELO DE DADOS

```csharp
public class Atendente : AuditableEntity
{
    public Guid Id { get; set; }
    public Guid UsuarioId { get; set; }
    public string Status { get; set; } // DISPONIVEL, OCUPADO, PAUSA, AUSENTE
    public int CargaAtual { get; set; }
    public int LimiteSimultaneo { get; set; } = 5;
    public List<Skill> Skills { get; set; }
    public Guid EmpresaId { get; set; }
}

public class Skill
{
    public Guid Id { get; set; }
    public string Categoria { get; set; } // MOBILE, DESKTOP, REDE
    public int Nivel { get; set; } // 1-Junior, 2-Pleno, 3-Senior
}
```

---

**Documento gerado em:** 2025-01-14
**Versão:** 1.0
**Status:** Aprovado
