# RF057 - Gestão de Itens de Rateio

## 1. RESUMO EXECUTIVO

### 1.1 Visão Geral
Sistema de configuração granular de itens que serão rateados (linhas móveis, licenças software, links de dados, equipamentos) com regras individuais por item, categoria ou grupo. Permite exceções, rateios customizados por item específico e controle detalhado de alocação de custos.

### 1.2 Importância Estratégica
- **Granularidade:** Controle fino de qual item ratear e como
- **Flexibilidade:** Regras diferentes para itens específicos
- **Exceções:** Tratamento especial para VIPs, projetos, áreas
- **Rastreabilidade:** Histórico completo de quem consumiu o quê
- **Transparência:** Relatórios detalhados por item

### 1.3 Funcionalidades Principais

1. **Categorização de Itens**
   - Linhas móveis (voz + dados separados)
   - Licenças de software (Office 365, Adobe, Salesforce)
   - Links de internet (dedicados, compartilhados)
   - Equipamentos (laptops, desktops, monitores)

2. **Regras por Item**
   - Rateio dedicado (100% para um centro de custo)
   - Rateio compartilhado (% fixo entre múltiplos CCs)
   - Rateio proporcional ao uso
   - Exceções e overrides

3. **Gestão de Custos Variáveis**
   - Franquias vs excedentes
   - Custos fixos vs variáveis
   - Ajustes e créditos por item
   - Multas e penalidades

4. **Análises e Relatórios**
   - Custo total por item
   - Top itens mais caros
   - Itens sem uso (candidatos a cancelamento)
   - Evolução de custo por item

---

## 2. REGRAS DE NEGÓCIO

### RN001: Categorias de Itens Rateáveis
**Descrição:** Sistema deve suportar 4 categorias principais de itens.

**Categorias:**
```csharp
public enum CategoriaItem
{
    LinhaMobile,        // Celulares (voz + dados)
    LicencaSoftware,    // Office, Adobe, Salesforce
    LinkDados,          // Internet, MPLS, VPN
    Equipamento         // Laptops, desktops, monitores
}
```

---

### RN002: Rateio Dedicado vs Compartilhado
**Descrição:** Item pode ser alocado 100% para um CC (dedicado) ou dividido entre múltiplos (compartilhado).

**Implementação:**
```csharp
public class ItemRateio
{
    public Guid Id { get; set; }
    public string Numero { get; set; } // Número da linha, ID da licença
    public CategoriaItem Categoria { get; set; }
    public TipoRateio Tipo { get; set; } // DEDICADO, COMPARTILHADO
    public List<AlocacaoItem> Alocacoes { get; set; }
}

public class AlocacaoItem
{
    public string CentroCusto { get; set; }
    public decimal Percentual { get; set; } // Soma deve ser 100%
}
```

---

### RN003: Separação de Custos Fixos e Variáveis
**Descrição:** Franquias (fixo) e excedentes (variável) devem ser rateados separadamente.

**Implementação:**
```csharp
public class CustoItem
{
    public Guid ItemId { get; set; }
    public DateTime Periodo { get; set; }
    public decimal CustoFixo { get; set; }      // Franquia mensal
    public decimal CustoVariavel { get; set; }  // Excedente de uso
    public decimal CustoTotal => CustoFixo + CustoVariavel;
}

public async Task RatearCustoItem(CustoItem custo)
{
    var item = await _context.ItensRateio.Include(i => i.Alocacoes).FirstAsync(i => i.Id == custo.ItemId);

    foreach (var alocacao in item.Alocacoes)
    {
        var custoAlocado = new CustoAlocado
        {
            CentroCusto = alocacao.CentroCusto,
            CustoFixo = custo.CustoFixo * (alocacao.Percentual / 100m),
            CustoVariavel = custo.CustoVariavel * (alocacao.Percentual / 100m)
        };

        _context.CustosAlocados.Add(custoAlocado);
    }

    await _context.SaveChangesAsync();
}
```

---

### RN004: Exceções de Rateio
**Descrição:** Permitir exceções temporárias ou permanentes (ex: CEO não participa de rateio).

**Implementação:**
```csharp
public class ExcecaoRateio
{
    public Guid Id { get; set; }
    public Guid ItemId { get; set; }
    public string Motivo { get; set; }
    public bool ExcluirTotalmente { get; set; } // Se true, não ratear esse item
    public DateTime? DataInicio { get; set; }
    public DateTime? DataFim { get; set; } // Null = permanente
}

public async Task<bool> ItemPossuiExcecao(Guid itemId, DateTime periodo)
{
    return await _context.ExcecoesRateio
        .AnyAsync(e => e.ItemId == itemId
            && (e.DataInicio == null || e.DataInicio <= periodo)
            && (e.DataFim == null || e.DataFim >= periodo));
}
```

---

### RN005: Histórico de Mudanças de Alocação
**Descrição:** Todas as mudanças de alocação devem ser versionadas com vigência.

**Implementação:**
```csharp
public async Task AlterarAlocacao(Guid itemId, List<AlocacaoItem> novasAlocacoes)
{
    var item = await _context.ItensRateio.Include(i => i.Alocacoes).FirstAsync(i => i.Id == itemId);

    // Arquivar alocações atuais
    foreach (var alocacao in item.Alocacoes)
    {
        _context.HistoricoAlocacoes.Add(new HistoricoAlocacao
        {
            ItemId = itemId,
            CentroCusto = alocacao.CentroCusto,
            Percentual = alocacao.Percentual,
            DataInicio = alocacao.DataInicio,
            DataFim = DateTime.Today.AddDays(-1),
            UsuarioAlteracaoId = _currentUser.Id
        });
    }

    // Aplicar novas alocações
    item.Alocacoes = novasAlocacoes;
    foreach (var alocacao in novasAlocacoes)
    {
        alocacao.DataInicio = DateTime.Today;
    }

    await _context.SaveChangesAsync();
}
```

---

### RN006: Rateio Proporcional ao Uso Real
**Descrição:** Para itens compartilhados, permitir rateio baseado em consumo individual medido.

**Implementação:**
```csharp
public async Task RatearPorUsoReal(Guid itemId, DateTime periodo)
{
    var consumos = await _context.Consumos
        .Where(c => c.ItemId == itemId && c.Periodo == periodo)
        .GroupBy(c => c.UsuarioId)
        .Select(g => new
        {
            UsuarioId = g.Key,
            ConsumoTotal = g.Sum(c => c.Quantidade)
        })
        .ToListAsync();

    var totalConsumo = consumos.Sum(c => c.ConsumoTotal);
    var custo = await ObterCustoItem(itemId, periodo);

    foreach (var consumo in consumos)
    {
        var usuario = await _context.Usuarios.FindAsync(consumo.UsuarioId);
        var percentual = (consumo.ConsumoTotal / totalConsumo) * 100;
        var custoAlocado = custo * (percentual / 100);

        // Alocar para centro de custo do usuário
        await AlocarCusto(usuario.CentroCusto, custoAlocado);
    }
}
```

---

### RN007: Itens sem Uso (Candidatos a Cancelamento)
**Descrição:** Detectar automaticamente itens sem uso > 3 meses e sugerir cancelamento.

**Implementação:**
```csharp
[Hangfire.RecurringJob("0 2 1 * *")] // 1º dia do mês, 02:00
public async Task DetectarItensSemUso()
{
    var tresMesesAtras = DateTime.Today.AddMonths(-3);

    var itensSemUso = await _context.ItensRateio
        .Where(i => i.Status == "ATIVO")
        .Where(i => !_context.Consumos.Any(c => c.ItemId == i.Id && c.Periodo >= tresMesesAtras))
        .ToListAsync();

    foreach (var item in itensSemUso)
    {
        var alerta = new AlertaItem
        {
            ItemId = item.Id,
            Tipo = "SEM_USO_3_MESES",
            Descricao = $"Item {item.Numero} sem uso há 3 meses. Custo mensal: R$ {item.CustoMensal:N2}",
            SugestaoAcao = "CANCELAR",
            EconomiaPotencial = item.CustoMensal
        };

        _context.AlertasItens.Add(alerta);
        await NotificarGestor(item, alerta);
    }

    await _context.SaveChangesAsync();
}
```

---

### RN008: Grupos de Itens para Rateio em Lote
**Descrição:** Permitir criar grupos de itens e aplicar mesma regra de rateio para todos.

**Implementação:**
```csharp
public class GrupoItens
{
    public Guid Id { get; set; }
    public string Nome { get; set; } // "Celulares Vendas", "Licenças Marketing"
    public List<ItemRateio> Itens { get; set; }
    public RegraRateio RegraGrupo { get; set; }
}

public async Task AplicarRegraGrupo(Guid grupoId)
{
    var grupo = await _context.GruposItens
        .Include(g => g.Itens)
        .Include(g => g.RegraGrupo)
        .FirstAsync(g => g.Id == grupoId);

    foreach (var item in grupo.Itens)
    {
        await AplicarRegra(item, grupo.RegraGrupo);
    }
}
```

---

### RN009: Ajustes e Créditos por Item
**Descrição:** Permitir lançar ajustes (multas, créditos, descontos) vinculados a item específico.

**Implementação:**
```csharp
public class AjusteItem
{
    public Guid Id { get; set; }
    public Guid ItemId { get; set; }
    public DateTime Periodo { get; set; }
    public string Tipo { get; set; } // MULTA, CREDITO, DESCONTO, AJUSTE
    public decimal Valor { get; set; }
    public string Justificativa { get; set; }
}

public async Task LancarAjuste(Guid itemId, string tipo, decimal valor, string justificativa)
{
    var ajuste = new AjusteItem
    {
        ItemId = itemId,
        Periodo = DateTime.Today,
        Tipo = tipo,
        Valor = valor,
        Justificativa = justificativa
    };

    _context.AjustesItens.Add(ajuste);
    await _context.SaveChangesAsync();

    // Ratear ajuste proporcionalmente às alocações
    await RatearAjuste(ajuste);
}
```

---

### RN010: Dashboard de Itens
**Descrição:** Dashboard com análises de itens: top mais caros, sem uso, evolução de custos.

**Implementação:**
```csharp
public async Task<DashboardItens> GerarDashboard(DateTime periodo)
{
    var itens = await _context.ItensRateio
        .Where(i => i.Status == "ATIVO")
        .ToListAsync();

    var custos = await _context.CustosItens
        .Where(c => c.Periodo == periodo)
        .ToListAsync();

    return new DashboardItens
    {
        TotalItens = itens.Count,
        CustoTotalMes = custos.Sum(c => c.CustoTotal),

        TopItensMaisCaros = custos
            .OrderByDescending(c => c.CustoTotal)
            .Take(10)
            .Select(c => new { Item = itens.First(i => i.Id == c.ItemId), Custo = c.CustoTotal })
            .ToList(),

        ItensSemUso = await DetectarItensSemUso(),

        EvolucaoCustos = await ObterEvolucaoCustos(12) // 12 meses
    };
}
```

---

### RN011: Validação de Alocação 100%
**Descrição:** Soma dos percentuais de alocação de um item deve ser exatamente 100%.

**Implementação:**
```csharp
public async Task<Result> ValidarAlocacao(List<AlocacaoItem> alocacoes)
{
    var soma = alocacoes.Sum(a => a.Percentual);

    if (Math.Abs(soma - 100m) > 0.01m)
        return Result.Failure($"Soma das alocações {soma}% diferente de 100%");

    return Result.Success();
}
```

---

### RN012: Transferência de Item entre CCs
**Descrição:** Permitir transferir item 100% dedicado de um CC para outro.

**Implementação:**
```csharp
public async Task<Result> TransferirItem(Guid itemId, string novoCentroCusto, string motivo)
{
    var item = await _context.ItensRateio.Include(i => i.Alocacoes).FirstAsync(i => i.Id == itemId);

    if (item.Tipo != TipoRateio.Dedicado)
        return Result.Failure("Apenas itens dedicados podem ser transferidos");

    var alocacaoAtual = item.Alocacoes.First();
    var ccAnterior = alocacaoAtual.CentroCusto;

    // Registrar transferência
    _context.TransferenciasItem.Add(new TransferenciaItem
    {
        ItemId = itemId,
        CentroCustoOrigem = ccAnterior,
        CentroCustoDestino = novoCentroCusto,
        Motivo = motivo,
        DataTransferencia = DateTime.UtcNow,
        UsuarioId = _currentUser.Id
    });

    // Atualizar alocação
    alocacaoAtual.CentroCusto = novoCentroCusto;
    alocacaoAtual.DataInicio = DateTime.Today;

    await _context.SaveChangesAsync();
    return Result.Success();
}
```

---

### RN013: Import em Massa de Itens
**Descrição:** Permitir importar planilha CSV com múltiplos itens e suas alocações.

**Implementação:**
```csharp
public async Task<ResultadoImport> ImportarItens(Stream csvStream)
{
    var resultado = new ResultadoImport();

    using var reader = new StreamReader(csvStream);
    using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

    var registros = csv.GetRecords<ItemRateioImport>().ToList();

    foreach (var registro in registros)
    {
        try
        {
            var item = new ItemRateio
            {
                Numero = registro.Numero,
                Categoria = Enum.Parse<CategoriaItem>(registro.Categoria),
                Tipo = Enum.Parse<TipoRateio>(registro.TipoRateio),
                CustoMensal = registro.CustoMensal
            };

            // Parse alocações (formato: "CC1:40;CC2:30;CC3:30")
            item.Alocacoes = registro.Alocacoes.Split(';')
                .Select(a =>
                {
                    var partes = a.Split(':');
                    return new AlocacaoItem
                    {
                        CentroCusto = partes[0],
                        Percentual = decimal.Parse(partes[1])
                    };
                })
                .ToList();

            // Validar
            var validacao = await ValidarAlocacao(item.Alocacoes);
            if (validacao.IsSuccess)
            {
                _context.ItensRateio.Add(item);
                resultado.Sucessos++;
            }
            else
            {
                resultado.Erros.Add($"Linha {registro.Numero}: {validacao.Error}");
            }
        }
        catch (Exception ex)
        {
            resultado.Erros.Add($"Linha {registro.Numero}: {ex.Message}");
        }
    }

    await _context.SaveChangesAsync();
    return resultado;
}
```

---

### RN014: Comparativo de Custo por Item
**Descrição:** Comparar custo do item mês atual vs mês anterior e alertar variações > 30%.

**Implementação:**
```csharp
public async Task CompararCustos(Guid itemId, DateTime mesAtual)
{
    var mesAnterior = mesAtual.AddMonths(-1);

    var custoAtual = await _context.CustosItens.FirstOrDefaultAsync(c => c.ItemId == itemId && c.Periodo == mesAtual);
    var custoAnterior = await _context.CustosItens.FirstOrDefaultAsync(c => c.ItemId == itemId && c.Periodo == mesAnterior);

    if (custoAtual == null || custoAnterior == null)
        return;

    var variacao = ((custoAtual.CustoTotal - custoAnterior.CustoTotal) / custoAnterior.CustoTotal) * 100;

    if (Math.Abs(variacao) > 30)
    {
        var alerta = new AlertaItem
        {
            ItemId = itemId,
            Tipo = "VARIACAO_ANORMAL",
            Descricao = $"Custo variou {variacao:N2}% em relação ao mês anterior",
            ValorAtual = custoAtual.CustoTotal,
            ValorAnterior = custoAnterior.CustoTotal
        };

        _context.AlertasItens.Add(alerta);
        await NotificarGestor(itemId, alerta);
        await _context.SaveChangesAsync();
    }
}
```

---

### RN015: Relatório Detalhado por Item
**Descrição:** Gerar relatório completo de um item: histórico de custos, alocações, transferências, ajustes.

**Implementação:**
```csharp
public async Task<RelatorioItem> GerarRelatorio(Guid itemId, int meses = 12)
{
    var item = await _context.ItensRateio
        .Include(i => i.Alocacoes)
        .FirstAsync(i => i.Id == itemId);

    var dataLimite = DateTime.Today.AddMonths(-meses);

    return new RelatorioItem
    {
        Item = item,
        HistoricoCustos = await _context.CustosItens
            .Where(c => c.ItemId == itemId && c.Periodo >= dataLimite)
            .OrderBy(c => c.Periodo)
            .ToListAsync(),

        HistoricoAlocacoes = await _context.HistoricoAlocacoes
            .Where(h => h.ItemId == itemId)
            .OrderByDescending(h => h.DataFim)
            .ToListAsync(),

        Transferencias = await _context.TransferenciasItem
            .Where(t => t.ItemId == itemId)
            .OrderByDescending(t => t.DataTransferencia)
            .ToListAsync(),

        Ajustes = await _context.AjustesItens
            .Where(a => a.ItemId == itemId && a.Periodo >= dataLimite)
            .ToListAsync(),

        CustoTotalPeriodo = await _context.CustosItens
            .Where(c => c.ItemId == itemId && c.Periodo >= dataLimite)
            .SumAsync(c => c.CustoTotal)
    };
}
```

---

## 3. REQUISITOS NÃO FUNCIONAIS

- Performance: Processar rateio de 50.000 itens em < 10 minutos
- Precisão: Cálculos com 4 casas decimais
- Auditoria: Histórico completo 7 anos
- Segurança: Apenas gestores podem alterar alocações

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades
```sql
INSERT INTO SistemaFuncionalidade (Codigo, Nome, Modulo)
VALUES ('GES.ITENS_RATEIO', 'Gestão de Itens de Rateio', 'Gestão');
```

### 4.2 RBAC
```csharp
public static class ItensRateioPermissions
{
    public const string Create = "GES.ITENS_RATEIO.CREATE";
    public const string Edit = "GES.ITENS_RATEIO.EDIT";
    public const string Transfer = "GES.ITENS_RATEIO.TRANSFER";
    public const string ViewCosts = "GES.ITENS_RATEIO.VIEW_COSTS";
}
```

---

## 5. MODELO DE DADOS

```csharp
public class ItemRateio : AuditableEntity
{
    public Guid Id { get; set; }
    public string Numero { get; set; } // Linha móvel, ID licença
    public CategoriaItem Categoria { get; set; }
    public TipoRateio Tipo { get; set; }
    public decimal CustoMensal { get; set; }
    public string Status { get; set; } // ATIVO, INATIVO, CANCELADO
    public List<AlocacaoItem> Alocacoes { get; set; }
    public Guid EmpresaId { get; set; }
}

public class AlocacaoItem
{
    public Guid Id { get; set; }
    public Guid ItemId { get; set; }
    public string CentroCusto { get; set; }
    public decimal Percentual { get; set; } // 0-100
    public DateTime DataInicio { get; set; }
    public DateTime? DataFim { get; set; }
}
```

---

**Documento gerado em:** 2025-01-14
**Versão:** 1.0
**Status:** Aprovado
