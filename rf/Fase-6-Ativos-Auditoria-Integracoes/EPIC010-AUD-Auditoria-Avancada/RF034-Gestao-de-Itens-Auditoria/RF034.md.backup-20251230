# RF034: Gestão de Itens de Auditoria

**Versão**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF035, RF032 | **EPIC**: EPIC010-AUD-Auditoria-Avançada
**Fase**: Fase 6 - Ativos, Auditoria e Integrações

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

Este requisito especifica o módulo **Gestão de Itens de Auditoria** do sistema IControlIT, responsável pelo controle detalhado e análise linha-a-linha de divergências identificadas na auditoria de faturas de telecomunicações.

O sistema registra cada bilhete (item de consumo) auditado, compara valores cobrados versus valores contratuais, identifica cobranças a maior e gera base documental estruturada para contestações formais junto às operadoras telecom. A funcionalidade é essencial para recuperação de valores indevidos, análise de qualidade de faturamento e cumprimento de conformidade contratual.

O módulo integra-se com RF035 (Resumos de Auditoria) e RF032 (Gestão de Faturas) para fornecer rastreabilidade completa do processo de auditoria, desde captura de divergências até geração de contestações.

### 1.2 Importância Estratégica

O módulo de Gestão de Itens de Auditoria é crítico para:

- **Recuperação Financeira**: Identificação precisa e documentada de valores cobrados a maior (glosas), possibilitando contestação formal junto às operadoras e recuperação de receita
- **Conformidade Contratual**: Garantia de que faturamento das operadoras respeita tarifas, quantidades e períodos negociados, validando cumprimento de SLAs comerciais
- **Análise de Qualidade**: Identificação de padrões recorrentes de erros por operadora, tipo de serviço e período, subsidiando negociação e revisão contratual
- **Evidência Regulatória**: Manutenção de registro completo de auditoria para cumprimento LGPD, SOX e auditorias externas de compliance
- **Otimização de Custos**: Redução de despesas operacionais através da recuperação sistêmica de cobranças indevidas
- **Rastreabilidade Total**: Histórico completo de todas as operações (criação, edição, exclusão) com identificação de usuário e timestamp para conformidade regulatória

### 1.3 Conceitos Fundamentais

**Auditoria de Fatura**: Processo sistemático de validação linha-a-linha de bilhetes de consumo de telecomunicação, comparando valores, quantidades e tarifas cobradas contra valores contratuais negociados.

- Ocorre após captura de fatura (RF032)
- Identifica divergências (cobranças indevidas, quantidades erradas, tarifas não autorizadas)
- Gera glosas (valores a recuperar) documentadas

**Bilhete**: Registro individual de consumo (ligação telefônica, tráfego de dados, SMS, roaming) com informações de origem, destino, quantidade e tarifa cobrada.

- Identifica consumo específico em uma data/horário
- Vinculado a um ativo (telefone ou circuito)
- Faz parte de uma fatura (RF032) de um período específico

**Glosa**: Valor cobrado indevidamente pela operadora, resultante da divergência entre valor cobrado e valor contratual correto.

- Calculada automaticamente como: Glosa = Valor Cobrado - Valor Correto
- Documentada com justificativa técnica
- Base para contestação formal junto à operadora

**Divergência**: Diferença percentual entre valor cobrado e valor correto.

- Permite identificar padrões de erro
- Classifica itens para análise (crítica, alta, média, baixa)
- Auxilia identificação de operadoras com maior índice de erro

**Resumo de Auditoria**: Agregação de itens auditados em um período, com totalizadores de valores, quantidades e análises consolidadas (RF035).

- Correlaciona múltiplos bilhetes sob um escopo comum
- Facilita análise gerencial e geração de contestações em lote
- Permite rastreabilidade de processo de auditoria

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET + ASPX) | Modernizado (.NET 10 + Angular 19) |
|---------|------------------------|-------------------------------------|
| **Arquitetura de Dados** | Tabelas simples sem relacionamentos complexos | Clean Architecture com Domain-Driven Design, Aggregates, Value Objects |
| **Cálculos de Glosa** | Manuais, campos soltos sem validação | Cálculos automáticos com regras de negócio encapsuladas em Entities |
| **Relacionamentos** | Foreign keys simples sem validações de integridade | Validações completas bidirecionais com sincronização de agregados |
| **Rastreamento de Alterações** | Sem auditoria ou rastreamento manual | Auditoria automática via ShadowProperties e Domain Events |
| **Contestações** | Tabela separada sem integração de fluxo | Workflow integrado com eventos de domínio e transições de estado |
| **Relatórios** | Queries SQL complexas manuais com performance variável | Queries otimizadas com índices específicos e projeções desnormalizadas |
| **Isolamento de Dados** | Campo Id_Conglomerado sem Row-Level Security | Row-Level Security automático via Global Query Filters |
| **Validação de Entrada** | Validações esparsas em múltiplos pontos | FluentValidation centralizado com testes de violação de contrato |
| **Notificações** | Sem sistema de notificação real-time | SignalR para notificações de divergências críticas em tempo real |
| **Processamento Batch** | Jobs SQL Server custom sem escalabilidade | Hangfire para processamento robusto de lotes de auditoria |
| **Integração Multi-tenant** | Sem isolamento real de dados | Isolamento automático por ClienteId com feature flags por cliente |

### 1.5 Funcionalidades Principais

1. **CRUD Completo de Itens de Auditoria** - Criar, visualizar, editar e excluir itens auditados com validações automáticas de integridade referencial e cálculos de divergências

2. **Detecção Automática de Divergências** - Comparação automática de valores cobrados versus contratuais, gerando glosas com precisão de até 8 casas decimais conforme padrão telecomunicações

3. **Classificação de Divergências** - Categorização automática conforme criticidade (crítica > 10%, alta 5-10%, média 1-5%, baixa < 1%) para priorização de análise

4. **Cálculo de Economia Gerada** - Agregação automática de glosas aprovadas por período, operadora e tipo de serviço para demonstração de ROI da auditoria

5. **Vinculação Inteligente** - Relacionamento automático com bilhetes, ativos, contratos, operadoras e faturas com validação de períodos e status

6. **Sincronização com Resumos** - Atualização automática de totalizadores do resumo de auditoria (RF035) ao criar/editar/excluir itens

7. **Workflow de Aprovação** - Suporte a transições de estado (pendente → análise → aprovado → contestado → recuperado) com registro de aprovadores e datas

8. **Exportação para Contestação** - Geração de documentos estruturados (PDF, Excel) com itens agrupados por operadora e justificativas para contestação formal

9. **Relatórios Gerenciais** - Análises por operadora, tipo de serviço, período, divergência, status e usuário responsável

10. **Dashboard de Glosas** - Visualização em tempo real de valores pendentes, aprovados, contestados e recuperados com gráficos de evolução

11. **Auditoria Completa** - Rastreamento de todas as operações (criar, editar, excluir, aprovar) com identificação de usuário, timestamp e valores antes/depois

12. **Notificações de Divergências Críticas** - Alertas automáticos via SignalR para divergências acima de limite configurado para escalação rápida

13. **Integração LGPD+SOX** - Conformidade automática com retenção de 7 anos, direito ao esquecimento, criptografia de dados sensíveis

14. **Multi-tenancy com Row-Level Security** - Isolamento automático de dados por ClienteId com feature flags por cliente para habilitação/desabilitação

---

## 2. REGRAS DE NEGÓCIO

### RN-AUD-034-01: Vinculação Obrigatória a Resumo e Bilhete

**Descrição**: Todo item de auditoria deve estar obrigatoriamente vinculado a um resumo de auditoria válido e a um bilhete específico válido.

**Justificativa**: Garante rastreabilidade completa e relacionamento bidirecional correto. Evita órfãos de dados e facilita análises consolidadas.

**Implementação**:
```csharp
public class CreateAuditoriaItemCommandValidator : AbstractValidator<CreateAuditoriaItemCommand>
{
    public CreateAuditoriaItemCommandValidator()
    {
        RuleFor(x => x.AuditoriaResumoId)
            .NotEmpty().WithMessage("Resumo de auditoria é obrigatório")
            .MustAsync(async (id, ct) =>
                await _context.AuditoriasResumos
                    .AnyAsync(r => r.Id == id && !r.FlExcluido, ct))
            .WithMessage("Resumo de auditoria não encontrado ou inativo");

        RuleFor(x => x.BilheteId)
            .NotEmpty().WithMessage("Bilhete é obrigatório")
            .MustAsync(async (id, ct) =>
                await _context.Bilhetes
                    .AnyAsync(b => b.Id == id && !b.FlExcluido, ct))
            .WithMessage("Bilhete não encontrado ou inativo");
    }
}
```

**Exemplos**:
- ✅ Item auditado vinculado a resumo RESUMO-202512-OI e bilhete BIL-001
- ❌ Tentativa de criar item com AuditoriaResumoId nulo → Rejeição HTTP 400

---

### RN-AUD-034-02: Cálculo Automático de Valor Cobrado a Mais (Glosa)

**Descrição**: O sistema calcula automaticamente `ValorCobradoAMais = ValorCobrado - ValorCorreto` sem necessidade de entrada manual do usuário.

**Justificativa**: Elimina inconsistências de cálculo, garante precisão matemática e facilita auditoria (não há campo editável diretamente pelo usuário).

**Implementação**:
```csharp
public class AuditoriaItem : BaseAuditableEntity
{
    public decimal ValorCobrado { get; private set; }
    public decimal ValorCorreto { get; private set; }

    // Propriedade calculada (somente leitura)
    public decimal ValorCobradoAMais => ValorCobrado - ValorCorreto;

    public decimal PercentualDivergencia => ValorCorreto > 0
        ? ((ValorCobrado - ValorCorreto) / ValorCorreto) * 100
        : 0;

    public void AtualizarValores(decimal valorCobrado, decimal valorCorreto)
    {
        ValorCobrado = valorCobrado;
        ValorCorreto = valorCorreto;
        // ValorCobradoAMais é calculado automaticamente
    }
}
```

**Exemplos**:
- Item com ValorCobrado=100.50, ValorCorreto=95.00 → ValorCobradoAMais=5.50 (automático)
- Item com ValorCobrado=85.75, ValorCorreto=85.75 → ValorCobradoAMais=0.00 (sem divergência)

---

### RN-AUD-034-03: Validação de Precisão Numérica Conforme Padrão Telecomunicações

**Descrição**: Todos os valores monetários devem ter precisão numérica de até 8 casas decimais (NUMERIC(13,8)) conforme padrão de faturamento telecomunicações brasileiro.

**Justificativa**: Compatibilidade com padrão ABNT de telecomunicações e com legado. Evita erros de arredondamento em cálculos financeiros críticos.

**Implementação**:
```csharp
public class AuditoriaItemValidator : AbstractValidator<AuditoriaItem>
{
    public AuditoriaItemValidator()
    {
        RuleFor(x => x.ValorCobrado)
            .NotNull().WithMessage("Valor cobrado é obrigatório")
            .GreaterThanOrEqualTo(0).WithMessage("Valor cobrado não pode ser negativo")
            .PrecisionScale(13, 8, true).WithMessage("Máximo 8 casas decimais");

        RuleFor(x => x.ValorCorreto)
            .NotNull().WithMessage("Valor correto é obrigatório")
            .GreaterThanOrEqualTo(0).WithMessage("Valor correto não pode ser negativo")
            .PrecisionScale(13, 8, true).WithMessage("Máximo 8 casas decimais");
    }
}
```

**Exemplos**:
- ✅ ValorCobrado = 123.45678901 (8 decimais) → Aceito
- ❌ ValorCobrado = 123.456789012 (9 decimais) → Rejeição HTTP 400

---

### RN-AUD-034-04: Quantidade de Consumo Deve Ser Positiva

**Descrição**: A quantidade de consumo (minutos, MB, SMS, etc.) deve ser obrigatoriamente maior que zero.

**Justificativa**: Lógica de negócio: não há consumo de zero ou negativo. Detecta dados corrompidos ou entrada manual errada.

**Implementação**:
```csharp
RuleFor(x => x.QuantidadeConsumo)
    .NotNull().WithMessage("Quantidade de consumo é obrigatória")
    .GreaterThan(0).WithMessage("Quantidade de consumo deve ser maior que zero")
    .PrecisionScale(13, 8, true);
```

**Exemplos**:
- ✅ QuantidadeConsumo = 1500 (minutos de ligação)
- ✅ QuantidadeConsumo = 250.5 (MB de dados)
- ❌ QuantidadeConsumo = 0 → Rejeição
- ❌ QuantidadeConsumo = -100 → Rejeição

---

### RN-AUD-034-05: Validação de Relacionamentos Obrigatórios

**Descrição**: Todos os relacionamentos (ativo, contrato, operadora, tipo de bilhete) devem referenciar registros válidos e ativos. Soft delete (FlExcluido = true) torna o relacionamento inválido.

**Justificativa**: Garante integridade referencial forte. Evita análises sobre dados órfãos ou desatualizados.

**Implementação**:
```csharp
RuleFor(x => x.AtivoId)
    .NotEmpty().WithMessage("Ativo é obrigatório")
    .MustAsync(async (ativoId, ct) =>
        await _context.Ativos
            .AnyAsync(a => a.Id == ativoId && !a.FlExcluido, ct))
    .WithMessage("Ativo não encontrado ou excluído");

RuleFor(x => x.ContratoId)
    .NotEmpty().WithMessage("Contrato é obrigatório")
    .MustAsync(async (contratoId, ct) =>
        await _context.Contratos
            .AnyAsync(c => c.Id == contratoId && !c.FlExcluido, ct))
    .WithMessage("Contrato não encontrado ou excluído");

RuleFor(x => x.BilheteTipoId)
    .NotEmpty()
    .MustAsync(async (tipId, ct) =>
        await _context.BilhetesTipos
            .AnyAsync(t => t.Id == tipId && !t.FlExcluido, ct));
```

**Exemplos**:
- ✅ Item vinculado a Ativo 5 (ativo, não excluído)
- ❌ Item vinculado a Ativo 99 (não existe) → Rejeição HTTP 400
- ❌ Item vinculado a Ativo 5 (FlExcluido = true) → Rejeição HTTP 400

---

### RN-AUD-034-06: Sincronização Automática com Resumo de Auditoria

**Descrição**: Ao criar, editar ou excluir um item de auditoria, os totalizadores do resumo associado (RF035) devem ser recalculados automaticamente via Domain Events.

**Justificativa**: Mantém consistência de dados agregados em tempo real. Elimina necessidade de jobs de sincronização.

**Implementação**:
```csharp
// Domain Event disparado quando item é criado
public class AuditoriaItemCriadoDomainEvent : INotification
{
    public Guid AuditoriaItemId { get; init; }
    public Guid AuditoriaResumoId { get; init; }
}

// Handler que recalcula totalizadores do resumo
public class RecalcularResumoAoItemCriadoHandler
    : INotificationHandler<AuditoriaItemCriadoDomainEvent>
{
    public async Task Handle(AuditoriaItemCriadoDomainEvent notification,
        CancellationToken cancellationToken)
    {
        var resumo = await _context.AuditoriasResumos
            .Include(r => r.Itens)
            .FirstAsync(r => r.Id == notification.AuditoriaResumoId, cancellationToken);

        resumo.TotalValorCobrado = resumo.Itens
            .Where(i => !i.FlExcluido)
            .Sum(i => i.ValorCobrado);

        resumo.TotalValorCorreto = resumo.Itens
            .Where(i => !i.FlExcluido)
            .Sum(i => i.ValorCorreto);

        resumo.TotalGlosa = resumo.TotalValorCobrado - resumo.TotalValorCorreto;
        resumo.TotalItens = resumo.Itens.Count(i => !i.FlExcluido);

        await _context.SaveChangesAsync(cancellationToken);
    }
}
```

**Exemplos**:
- Crio item com glosa 100.00 → Resumo.TotalGlosa atualizado automaticamente
- Edito item alterando glosa para 150.00 → Resumo.TotalGlosa recalculado
- Deleto item com glosa 100.00 → Resumo.TotalGlosa reduzido automaticamente

---

### RN-AUD-034-07: Validação de Lote (Formato AAAAMM)

**Descrição**: O campo Lote deve estar no formato AAAAMM (6 dígitos) representando um período válido de faturamento.

**Justificativa**: Garante consistência de período. Facilita agrupamento por mês/ano nas análises.

**Implementação**:
```csharp
RuleFor(x => x.Lote)
    .NotEmpty().WithMessage("Lote é obrigatório")
    .Length(6).WithMessage("Lote deve ter exatamente 6 caracteres (AAAAMM)")
    .Matches(@"^\d{6}$").WithMessage("Lote deve conter apenas dígitos")
    .Must(BeValidLote).WithMessage("Lote deve representar data válida");

private bool BeValidLote(string lote)
{
    if (lote.Length != 6) return false;

    var ano = int.Parse(lote[..4]);
    var mes = int.Parse(lote[4..]);

    return (mes >= 1 && mes <= 12) && (ano >= 2000 && ano <= 2100);
}
```

**Exemplos**:
- ✅ Lote = "202512" (dezembro/2025)
- ✅ Lote = "202501" (janeiro/2025)
- ❌ Lote = "2025-12" (formato inválido)
- ❌ Lote = "202513" (mês 13 inválido)

---

### RN-AUD-034-08: Exportação Estruturada para Contestação

**Descrição**: Itens de auditoria devem ser exportáveis em formato estruturado (PDF, Excel) agrupados por operadora, com cálculo de subtotais, justificativas técnicas e referência de bilhete.

**Justificativa**: Prepara documentação formal para contestação junto à operadora. Deve ser auto-explicativo e completo.

**Implementação**:
```csharp
public class ExportarItemsContestacaoCommand : IRequest<byte[]>
{
    public Guid AuditoriaResumoId { get; init; }
    public List<Guid> ItemIds { get; init; }
    public ExportFormat Formato { get; init; } // PDF, Excel, CSV
}

public class ExportarItemsContestacaoHandler
    : IRequestHandler<ExportarItemsContestacaoCommand, byte[]>
{
    public async Task<byte[]> Handle(ExportarItemsContestacaoCommand request,
        CancellationToken cancellationToken)
    {
        var items = await _context.AuditoriasItens
            .Where(i => request.ItemIds.Contains(i.Id) && !i.FlExcluido)
            .Include(i => i.Bilhete)
            .Include(i => i.Ativo)
            .Include(i => i.Operadora)
            .ToListAsync(cancellationToken);

        var agrupoPorOperadora = items
            .GroupBy(i => i.Operadora.Nome)
            .OrderBy(g => g.Key);

        var documento = new ContestacaoDocumento
        {
            DataGeracao = DateTime.UtcNow,
            TotalItens = items.Count,
            ValorTotalGlosa = items.Sum(i => i.ValorCobradoAMais),
            Grupos = agrupoPorOperadora.Select(g => new GrupoOperadora
            {
                Nome = g.Key,
                Itens = g.Select(i => new ItemExportado
                {
                    Bilhete = i.Bilhete.Numero,
                    Data = i.Bilhete.Data,
                    Ativo = i.Ativo.Numero,
                    ValorCobrado = i.ValorCobrado,
                    ValorCorreto = i.ValorCorreto,
                    Glosa = i.ValorCobradoAMais,
                    Divergencia = i.PercentualDivergencia,
                    Justificativa = GerarJustificativa(i)
                }).ToList(),
                SubtotalGlosa = g.Sum(i => i.ValorCobradoAMais)
            }).ToList()
        };

        return request.Formato switch
        {
            ExportFormat.PDF => _pdfService.Gerar(documento),
            ExportFormat.Excel => _excelService.Gerar(documento),
            ExportFormat.CSV => _csvService.Gerar(documento),
            _ => throw new InvalidOperationException()
        };
    }

    private string GerarJustificativa(AuditoriaItem item)
    {
        var diferenca = item.ValorCobrado - item.ValorCorreto;
        var pct = item.PercentualDivergencia;

        return pct switch
        {
            >= 10 => "Cobrança acima de 10% do valor contratual",
            >= 5 => "Cobrança acima de 5% do valor contratual",
            >= 1 => "Cobrança acima de 1% do valor contratual",
            > 0 => "Cobrança acima do valor contratual",
            _ => "Sem divergência"
        };
    }
}
```

**Exemplos**:
- Export PDF de 50 itens agrupados por 3 operadoras com subtotais
- Export Excel com sheet separada por operadora
- Export CSV para importação em sistema de contestação

---

### RN-AUD-034-09: Auditoria Completa de Operações

**Descrição**: Todas as operações (criar, editar, excluir, aprovar, contestar) devem ser auditadas com registro de usuário, timestamp, valores antes/depois via Shadow Properties do EF Core.

**Justificativa**: Conformidade LGPD (7 anos). Rastreabilidade de mudanças para investigação e compliance.

**Implementação**:
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<AuditoriaItem>()
        .Property(a => a.DataCriacao)
        .HasDefaultValueSql("GETUTCDATE()");

    modelBuilder.Entity<AuditoriaItem>()
        .Property(a => a.DataAlteracao)
        .ValueGeneratedOnAddOrUpdate();

    // Shadow Properties para auditoria
    modelBuilder.Entity<AuditoriaItem>()
        .Property<string>("UsuarioCriacao")
        .IsRequired();

    modelBuilder.Entity<AuditoriaItem>()
        .Property<string>("UsuarioAlteracao");

    // Listener para preencher dados de auditoria
    modelBuilder.Entity<AuditoriaItem>()
        .HasQueryFilter(x => x.ConglomeradoId == _currentClienteId);
}

// Interceptor para preencher auditoria automaticamente
public class AuditoriaInterceptor : SaveChangesInterceptor
{
    public override ValueTask<int> SavedChangesAsync(SaveChangesCompletedEventArgs eventArgs,
        CancellationToken cancellationToken = default)
    {
        var entries = eventArgs.Context.ChangeTracker
            .Entries<AuditoriaItem>();

        foreach (var entry in entries)
        {
            if (entry.State == EntityState.Added)
            {
                entry.Property("UsuarioCriacao").CurrentValue = _usuarioAtual;
                entry.Property<DateTime>("DataCriacao").CurrentValue = DateTime.UtcNow;
            }
            else if (entry.State == EntityState.Modified)
            {
                entry.Property("UsuarioAlteracao").CurrentValue = _usuarioAtual;
                entry.Property<DateTime>("DataAlteracao").CurrentValue = DateTime.UtcNow;
            }
        }

        return base.SavedChangesAsync(eventArgs, cancellationToken);
    }
}
```

**Exemplos**:
- Criação: {UsuarioCriacao: "auditor@empresa.com", DataCriacao: "2025-12-28 14:30:00Z"}
- Edição: {UsuarioAlteracao: "gestor@empresa.com", DataAlteracao: "2025-12-28 15:45:00Z"}
- Exclusão: {UsuarioAlteracao: "admin@empresa.com", DataAlteracao: "2025-12-28 16:00:00Z", FlExcluido: true}

---

### RN-AUD-034-10: Filtros Avançados por Unidade de Consumo

**Descrição**: Os itens devem ser filtrável por unidade de consumo (minutos, MB, SMS, franquia) para análises segmentadas por tipo de serviço.

**Justificativa**: Diferentes tipos de erro ocorrem em diferentes serviços. Filtragem facilita análise de padrão.

**Implementação**:
```csharp
public enum UnidadeConsumo
{
    Minutos = 1,
    MegaBytes = 2,
    SMS = 3,
    Franquia = 4
}

public class GetAuditoriasItensQuery : IRequest<PaginatedList<AuditoriaItemDto>>
{
    public Guid? AuditoriaResumoId { get; init; }
    public UnidadeConsumo? Unidade { get; init; }
    public decimal? DivergenciaMinima { get; init; }
    public int PageNumber { get; init; } = 1;
    public int PageSize { get; init; } = 50;
}

public class GetAuditoriasItensQueryHandler
    : IRequestHandler<GetAuditoriasItensQuery, PaginatedList<AuditoriaItemDto>>
{
    public async Task<PaginatedList<AuditoriaItemDto>> Handle(
        GetAuditoriasItensQuery request, CancellationToken cancellationToken)
    {
        var query = _context.AuditoriasItens
            .Where(i => !i.FlExcluido);

        if (request.AuditoriaResumoId.HasValue)
            query = query.Where(i => i.AuditoriaResumoId == request.AuditoriaResumoId);

        if (request.Unidade.HasValue)
            query = query.Where(i => i.Unidade == (int)request.Unidade);

        if (request.DivergenciaMinima.HasValue)
            query = query.Where(i => i.ValorCobradoAMais >= request.DivergenciaMinima);

        return await query
            .OrderByDescending(i => i.ValorCobradoAMais)
            .Paginate(request.PageNumber, request.PageSize)
            .ToListAsync(cancellationToken);
    }
}
```

**Exemplos**:
- Filtro: Unidade = Minutos → Apenas chamadas de voz
- Filtro: Unidade = MegaBytes E DivergenciaMinima = 50.00 → Apenas dados com glosa > R$ 50
- Filtro: Unidade = SMS → Apenas mensagens de texto

---

### RN-AUD-034-11: Validação de Valores Conforme Tipo de Bilhete

**Descrição**: Validações de unidade de consumo e tipo de serviço devem respeitar relacionamento com tipo de bilhete (VOZ usa minutos, DADOS usa MB, etc.).

**Justificativa**: Detecta erros de entrada. Garante consistência de dados.

**Implementação**:
```csharp
RuleFor(x => x)
    .MustAsync(async (item, cancellation) =>
    {
        var bilheteTipo = await _context.BilhetesTipos
            .AsNoTracking()
            .FirstAsync(t => t.Id == item.BilheteTipoId, cancellation);

        return (bilheteTipo.Codigo, item.Unidade) switch
        {
            ("VOZ", UnidadeConsumo.Minutos) => true,
            ("DADOS", UnidadeConsumo.MegaBytes) => true,
            ("SMS", UnidadeConsumo.SMS) => true,
            ("FRANQUIA", UnidadeConsumo.Franquia) => true,
            _ => false
        };
    })
    .WithMessage("Unidade de consumo incompatível com tipo de bilhete");
```

**Exemplos**:
- ✅ Tipo=VOZ, Unidade=Minutos, Quantidade=1500
- ❌ Tipo=VOZ, Unidade=MegaBytes → Rejeição (incompatível)
- ✅ Tipo=DADOS, Unidade=MegaBytes, Quantidade=250.5
- ❌ Tipo=DADOS, Unidade=Minutos → Rejeição

---

### RN-AUD-034-12: Índices para Performance em Consultas Analíticas

**Descrição**: Criar índices não-clusterizados otimizados para consultas de auditoria, relatórios e exportações.

**Justificativa**: Relatórios sobre milhares de itens requerem performance. Índices reduzem tempo de execução de O(n) para O(log n).

**Implementação**:
```sql
-- Índice para busca por resumo
CREATE NONCLUSTERED INDEX IX_AuditoriasItens_AuditoriaResumoId
ON dbo.AuditoriasItens(AuditoriaResumoId)
INCLUDE (ValorCobrado, ValorCorreto, ValorCobradoAMais)
WHERE FlExcluido = 0;

-- Índice para busca por bilhete
CREATE NONCLUSTERED INDEX IX_AuditoriasItens_BilheteId
ON dbo.AuditoriasItens(BilheteId)
WHERE FlExcluido = 0;

-- Índice para filtros por lote e multi-tenancy
CREATE NONCLUSTERED INDEX IX_AuditoriasItens_Lote_ConglomeradoId
ON dbo.AuditoriasItens(Lote, ConglomeradoId)
INCLUDE (ValorCobrado, ValorCorreto, ValorCobradoAMais)
WHERE FlExcluido = 0;

-- Índice para análise por unidade e período
CREATE NONCLUSTERED INDEX IX_AuditoriasItens_Unidade_DataCriacao
ON dbo.AuditoriasItens(Unidade, DataCriacao DESC)
INCLUDE (ValorCobradoAMais)
WHERE FlExcluido = 0;

-- Índice para ordenação por divergência (análise de criticidade)
CREATE NONCLUSTERED INDEX IX_AuditoriasItens_Divergencia DESC
ON dbo.AuditoriasItens(ValorCobradoAMais DESC)
WHERE FlExcluido = 0 AND ValorCobradoAMais > 0;
```

---

### RN-AUD-034-13: Soft Delete com Recálculo de Agregados

**Descrição**: Exclusão lógica (soft delete) deve definir FlExcluido=true e disparar evento para recálculo automático de totalizadores do resumo.

**Justificativa**: Preserva auditoria (registro não é perdido). Mantém consistência de agregados.

**Implementação**:
```csharp
public async Task<Unit> Handle(DeleteAuditoriaItemCommand request,
    CancellationToken cancellationToken)
{
    var item = await _context.AuditoriasItens
        .Include(i => i.Resumo)
        .FirstAsync(i => i.Id == request.Id, cancellationToken);

    if (item.FlExcluido)
        throw new InvalidOperationException("Item já foi excluído");

    // Soft delete
    item.FlExcluido = true;

    // Disparar evento de domínio
    item.AddDomainEvent(new AuditoriaItemExcluidoDomainEvent(
        item.Id,
        item.AuditoriaResumoId,
        item.ValorCobradoAMais));

    await _context.SaveChangesAsync(cancellationToken);

    return Unit.Value;
}

// Handler que recalcula resumo
public class AuditoriaItemExcluidoHandler
    : INotificationHandler<AuditoriaItemExcluidoDomainEvent>
{
    public async Task Handle(AuditoriaItemExcluidoDomainEvent notification,
        CancellationToken cancellationToken)
    {
        var resumo = await _context.AuditoriasResumos
            .Include(r => r.Itens)
            .FirstAsync(r => r.Id == notification.AuditoriaResumoId, cancellationToken);

        // Recalcular totalizadores (exclui itens com FlExcluido = true)
        resumo.TotalValorCobrado = resumo.Itens
            .Where(i => !i.FlExcluido)
            .Sum(i => i.ValorCobrado);

        resumo.TotalValorCorreto = resumo.Itens
            .Where(i => !i.FlExcluido)
            .Sum(i => i.ValorCorreto);

        resumo.TotalGlosa = resumo.TotalValorCobrado - resumo.TotalValorCorreto;

        await _context.SaveChangesAsync(cancellationToken);
    }
}
```

**Exemplos**:
- Delete item com glosa 100.00 → Resumo.TotalGlosa reduzido em 100.00, item ainda visível em auditoria

---

### RN-AUD-034-14: Exportação para Excel com Detalhamento Completo

**Descrição**: Exportação para Excel deve incluir todas as colunas relevantes em formatação legível, com subtotais por operadora e divergência.

**Justificativa**: Facilita análise offline e compartilhamento com stakeholders.

**Implementação**:
```csharp
public class ExportAuditoriasItensQuery : IRequest<byte[]>
{
    public Guid? AuditoriaResumoId { get; init; }
    public string? Lote { get; init; }
    public DateTime? DataInicio { get; init; }
    public DateTime? DataFim { get; init; }
}

public class ExportAuditoriasItensHandler
    : IRequestHandler<ExportAuditoriasItensQuery, byte[]>
{
    public async Task<byte[]> Handle(ExportAuditoriasItensQuery request,
        CancellationToken cancellationToken)
    {
        var query = _context.AuditoriasItens
            .Where(i => !i.FlExcluido)
            .Include(i => i.Bilhete)
            .Include(i => i.BilheteTipo)
            .Include(i => i.Ativo)
            .Include(i => i.Contrato)
            .Include(i => i.Operadora);

        if (request.AuditoriaResumoId.HasValue)
            query = query.Where(i => i.AuditoriaResumoId == request.AuditoriaResumoId);

        if (!string.IsNullOrEmpty(request.Lote))
            query = query.Where(i => i.Lote == request.Lote);

        var dados = await query
            .OrderBy(i => i.Operadora.Nome)
            .ThenByDescending(i => i.ValorCobradoAMais)
            .Select(i => new
            {
                Lote = i.Lote,
                DataAuditoria = i.DataCriacao.ToString("dd/MM/yyyy HH:mm"),
                Bilhete = i.Bilhete.Numero,
                TipoBilhete = i.BilheteTipo.Nome,
                Ativo = i.Ativo.Numero,
                Operadora = i.Operadora.Nome,
                Contrato = i.Contrato.Numero,
                QuantidadeConsumo = i.QuantidadeConsumo.ToString("N2"),
                Unidade = GetUnidadeLabel(i.Unidade),
                ValorCobrado = i.ValorCobrado.ToString("N8"),
                ValorContrato = i.ValorContrato.ToString("N8"),
                ValorCorreto = i.ValorCorreto.ToString("N8"),
                Glosa = i.ValorCobradoAMais.ToString("N8"),
                Divergencia = i.PercentualDivergencia.ToString("N2") + "%"
            })
            .ToListAsync(cancellationToken);

        var workbook = new ExcelWorkbook();
        var sheet = workbook.AddWorksheet("Itens de Auditoria");

        // Adicionar headers
        var headers = typeof(dynamic).GetProperties()
            .Select(p => p.Name)
            .ToList();

        for (int col = 0; col < headers.Count; col++)
        {
            sheet.Cell(1, col + 1).Value = headers[col];
            sheet.Cell(1, col + 1).Style.Font.Bold = true;
            sheet.Cell(1, col + 1).Style.Fill.BackgroundColor = XLColor.LightGray;
        }

        // Adicionar dados
        int row = 2;
        foreach (var item in dados)
        {
            sheet.Cell(row, 1).Value = item.Lote;
            sheet.Cell(row, 2).Value = item.DataAuditoria;
            // ... continuar para outras colunas
            row++;
        }

        // Autoajustar colunas
        sheet.Columns().AdjustToContents();

        return workbook.ToByteArray();
    }
}
```

---

### RN-AUD-034-15: Multi-Tenancy Obrigatório com Row-Level Security

**Descrição**: Todos os itens de auditoria devem estar obrigatoriamente isolados por ConglomeradoId (ClienteId). Global Query Filters garantem isolamento automático em todas as queries.

**Justificativa**: Conformidade multi-tenancy. Evita vazamento de dados entre clientes.

**Implementação**:
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<AuditoriaItem>()
        .HasQueryFilter(x => x.ConglomeradoId == _currentClientId);
}

public class AuditoriaItemsController : ApiControllerBase
{
    [HttpGet]
    public async Task<ActionResult<PaginatedList<AuditoriaItemDto>>> GetItems(
        [FromQuery] GetAuditoriasItensQuery query)
    {
        // Classe assegura que apenas itens do cliente atual são retornados
        // Global Query Filter está aplicado automaticamente
        return Ok(await _mediator.Send(query));
    }
}
```

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `Cliente_Modelo`

**Tabela Principal**: `dbo.Auditoria_Item`

```sql
CREATE TABLE [dbo].[Auditoria_Item](
    [Id_Auditoria_Item] [int] IDENTITY(1,1) NOT NULL,
    [Id_Auditoria_Resumo] [int] NOT NULL,
    [Id_Bilhete] [int] NOT NULL,
    [Id_Bilhete_Tipo] [int] NOT NULL,
    [Id_Ativo] [int] NOT NULL,
    [Id_Contrato] [int] NOT NULL,
    [Id_Conglomerado] [int] NOT NULL,
    [Unidade] [int] NOT NULL,
    [DT_Lote] [varchar](6) NOT NULL,
    [QTD_Consumo] [float] NOT NULL,
    [Valor_Cobrado] [numeric](13, 8) NULL,
    [Valor_Contrato] [numeric](13, 8) NULL,
    [Valor_Correto] [float] NULL,
    [Valor_Cobrado_A_Mais] [float] NULL,
    [Total_Fatura] [numeric](13, 8) NULL,
    [Fatura] [varchar](50) NOT NULL,
    CONSTRAINT [PK_Auditoria_Item] PRIMARY KEY CLUSTERED ([Id_Auditoria_Item] ASC)
) ON [PRIMARY]
```

**Tabela de Relacionamento**: `dbo.Auditoria_Resumo`

```sql
CREATE TABLE [dbo].[Auditoria_Resumo](
    [Id_Auditoria_Resumo] [int] IDENTITY(1,1) NOT NULL,
    [Id_Conglomerado] [int] NOT NULL,
    [DT_Lote] [varchar](6) NOT NULL,
    [Total_Valor_Cobrado] [numeric](13, 8) NULL,
    [Total_Valor_Correto] [numeric](13, 8) NULL,
    [Total_Glosa] [numeric](13, 8) NULL,
    [Total_Itens] [int] NULL,
    [Data_Criacao] [datetime] DEFAULT GETDATE() NOT NULL,
    CONSTRAINT [PK_Auditoria_Resumo] PRIMARY KEY CLUSTERED ([Id_Auditoria_Resumo] ASC),
    CONSTRAINT [FK_Auditoria_Resumo_Conglomerado]
        FOREIGN KEY([Id_Conglomerado]) REFERENCES [dbo].[Conglomerado]([Id_Conglomerado])
) ON [PRIMARY]
```

**Campos Importantes**:

| Campo Legado | Descrição | Mapeamento Modernizado |
|--------------|-----------|------------------------|
| `Id_Auditoria_Item` | Chave primária | `Id` (GUID) |
| `Id_Auditoria_Resumo` | FK para resumo | `AuditoriaResumoId` (GUID) |
| `Id_Bilhete` | FK para bilhete | `BilheteId` (GUID) |
| `Id_Bilhete_Tipo` | FK para tipo | `BilheteTipoId` (GUID) |
| `Id_Ativo` | FK para ativo | `AtivoId` (GUID) |
| `Id_Contrato` | FK para contrato | `ContratoId` (GUID) |
| `Id_Conglomerado` | Multi-tenancy | `ConglomeradoId` (GUID) |
| `Unidade` | Tipo de consumo | `Unidade` (enum: 1=Min, 2=MB, 3=SMS, 4=Franquia) |
| `DT_Lote` | Período AAAAMM | `Lote` (string 6 chars) |
| `QTD_Consumo` | Quantidade | `QuantidadeConsumo` (decimal) |
| `Valor_Cobrado` | Valor operadora | `ValorCobrado` (decimal) |
| `Valor_Contrato` | Valor negociado | `ValorContrato` (decimal) |
| `Valor_Correto` | Valor calculado | `ValorCorreto` (decimal) |
| `Valor_Cobrado_A_Mais` | Glosa | `ValorCobradoAMais` (calculated) |
| `Total_Fatura` | Valor total | `TotalFatura` (decimal) |
| `Fatura` | Código fatura | `Fatura` (string) |

**Problemas Identificados**:
- ❌ Inconsistência de tipos: `float` para cálculos financeiros (impreciso)
- ❌ Campo `Valor_Cobrado_A_Mais` editável manualmente (não deve ser)
- ❌ Sem soft delete (FlExcluido)
- ❌ Sem auditoria de alterações (DataCriacao/UsuarioCriacao)
- ❌ `Id_Conglomerado` sem Row-Level Security
- ❌ Sem índices otimizados para relatórios

### 3.2 Stored Procedures Legado

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `sp_AuditarFatura` | Processa auditoria de fatura | Implementado como Command (CreateAuditoriaItemCommand) em Clean Architecture |
| `sp_CalcularGlosa` | Calcula divergências | Lógica encapsulada em Domain Model (propriedade calculada) |
| `sp_GerarRelatorioAuditoria` | Relatório consolidado | Query otimizada com projeções desnormalizadas |
| `sp_ExportarItens` | Exportação para Excel | ExportAuditoriasItensQuery com EPPlus |

### 3.3 Telas ASPX Legado

| Página | Descrição | Tela Moderna (Angular 19) |
|--------|-----------|--------------------------|
| `AuditoriaItens.aspx` | CRUD de itens | `/gestao/auditoria-itens` |
| `AuditoriaItensRelatorio.aspx` | Relatório consolidado | `/gestao/auditoria-itens/relatorios` |
| `AuditoriaItensExportar.aspx` | Exportação para Excel | POST `/api/auditoria-itens/export` |

### 3.4 WebServices Legado (VB.NET)

Não foram identificados WebServices específicos para auditoria de itens. Integração era via Stored Procedures diretas.

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `AUD_AUDITORIA_ITENS`

**Configuração**:
```json
{
    "featureKey": "AUD_AUDITORIA_ITENS",
    "nome": "Gestão de Itens de Auditoria",
    "descricao": "Módulo de controle detalhado de divergências em auditoria de faturas",
    "modulo": "Auditoria",
    "categoria": "Processamento",
    "habilitado": true,
    "isSystemFeature": false,
    "clientesPermitidos": ["*"],
    "permissaoMinima": "aud:itens:view",
    "notas": "Feature crítica. Ativar apenas após validação de banco de dados"
}
```

**Nota**: Feature flag permite desabilitação rápida sem deploy se houver problemas. Sistema deve tratar gracefully se desabilitado.

### 4.2 Internacionalização (i18n)

**Arquivo**: `src/assets/i18n/pt-BR.json`

```json
{
  "auditoria": {
    "itens": {
      "titulo": "Itens de Auditoria",
      "descricao": "Gestão detalhada de divergências identificadas na auditoria de faturas",
      "labels": {
        "bilhete": "Bilhete",
        "valorCobrado": "Valor Cobrado (R$)",
        "valorCorreto": "Valor Correto (R$)",
        "valorCobradoAMais": "Glosa (R$)",
        "percentualDivergencia": "Divergência (%)",
        "lote": "Lote (AAAAMM)",
        "ativo": "Ativo",
        "contrato": "Contrato",
        "operadora": "Operadora",
        "unidade": "Unidade",
        "quantidadeConsumo": "Quantidade",
        "status": "Status"
      },
      "placeholders": {
        "pesquisaBilhete": "Buscar por número de bilhete...",
        "filtroOperadora": "Selecionar operadora...",
        "filtroLote": "Selecionar período (AAAAMM)..."
      },
      "mensagens": {
        "sucesso": {
          "criar": "Item de auditoria criado com sucesso",
          "editar": "Item de auditoria atualizado com sucesso",
          "excluir": "Item de auditoria excluído com sucesso",
          "exportar": "Dados exportados com sucesso"
        },
        "erro": {
          "criar": "Erro ao criar item de auditoria",
          "editar": "Erro ao atualizar item de auditoria",
          "excluir": "Erro ao excluir item de auditoria",
          "validacao": "Erros de validação encontrados",
          "relacionamento": "Relacionamento inválido ou indisponível"
        }
      },
      "validacao": {
        "campoObrigatorio": "Campo obrigatório",
        "valorInvalido": "Valor inválido",
        "valorNegativo": "Valor não pode ser negativo",
        "quantidade": "Quantidade deve ser maior que zero",
        "loteInvalido": "Lote deve estar no formato AAAAMM",
        "relacionamentoInvalido": "Relacionamento inválido ou registro não encontrado"
      },
      "relatorios": {
        "titulo": "Relatórios de Auditoria",
        "porOperadora": "Divergências por Operadora",
        "porTipo": "Divergências por Tipo de Serviço",
        "porPeriodo": "Evolução por Período",
        "roi": "Retorno Financeiro da Auditoria"
      }
    }
  }
}
```

**Chaves de Tradução Obrigatórias**: 16 pontos (conforme CLAUDE.md)
- ✅ Títulos de seções (5)
- ✅ Labels de campos (10)
- ✅ Mensagens de sucesso/erro (1 grupo)

### 4.3 Auditoria

**Tabela de Auditoria**: `dbo.AuditoriaLogs` (centralizada, conforme RF003)

**Operações Auditadas**:

| Operação | Código | Dados Registrados |
|----------|--------|-------------------|
| Criar Item | `AUD_ITEM_CREATE` | Id, BilheteId, ValorCobrado, ValorCorreto, UsuarioCriacao, Timestamp |
| Editar Item | `AUD_ITEM_UPDATE` | Id, ValoresAntes, ValoresDepois, UsuarioAlteracao, Timestamp |
| Excluir Item | `AUD_ITEM_DELETE` | Id, UsuarioExclusao, ValoresExcluidos, Timestamp |
| Exportar Items | `AUD_ITEM_EXPORT` | Filtros, QuantidadeRegistros, FormatoExportacao, UsuarioExportacao, Timestamp |
| Gerar Contestação | `AUD_ITEM_CONTESTACAO` | ResumoId, ItemIds, ValorTotal, UsuarioGerador, Timestamp |

**Retenção**: 7 anos (conforme LGPD)

**Acesso**: Apenas usuários com permissão `aud:logs:view`

### 4.4 Controle de Acesso (RBAC)

**Permissões Definidas**:

| Permissão | Descrição | Super Admin | Auditor | Gestor Fin. | Analista |
|-----------|-----------|-------------|---------|-------------|----------|
| `aud:itens:view` | Visualizar itens | ✅ | ✅ | ✅ | ✅ |
| `aud:itens:create` | Criar itens | ✅ | ✅ | ❌ | ❌ |
| `aud:itens:edit` | Editar itens | ✅ | ✅ | ❌ | ❌ |
| `aud:itens:delete` | Excluir itens | ✅ | ❌ | ❌ | ❌ |
| `aud:itens:export` | Exportar para Excel/PDF | ✅ | ✅ | ✅ | ✅ |
| `aud:itens:contestacao` | Gerar contestação | ✅ | ✅ | ✅ | ❌ |

**Implementação**:
```csharp
[Authorize(Policy = "aud:itens:view")]
[HttpGet]
public async Task<IActionResult> GetItems() { }

[Authorize(Policy = "aud:itens:create")]
[HttpPost]
public async Task<IActionResult> CreateItem([FromBody] CreateAuditoriaItemCommand command) { }
```

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Método | Endpoint | Descrição | Permissão | Status Code |
|--------|----------|-----------|-----------|-------------|
| GET | `/api/v1/auditoria-itens` | Listar itens com paginação/filtros | `aud:itens:view` | 200, 400, 403 |
| GET | `/api/v1/auditoria-itens/{id}` | Obter item por ID | `aud:itens:view` | 200, 404, 403 |
| POST | `/api/v1/auditoria-itens` | Criar novo item | `aud:itens:create` | 201, 400, 403, 409 |
| PUT | `/api/v1/auditoria-itens/{id}` | Atualizar item existente | `aud:itens:edit` | 200, 400, 404, 403, 409 |
| DELETE | `/api/v1/auditoria-itens/{id}` | Excluir item (soft delete) | `aud:itens:delete` | 204, 404, 403 |

### 5.2 Operações Especiais

| Método | Endpoint | Descrição | Permissão | Status Code |
|--------|----------|-----------|-----------|-------------|
| GET | `/api/v1/auditoria-itens/export/excel` | Exportar para Excel com filtros | `aud:itens:export` | 200 (file), 400, 403 |
| POST | `/api/v1/auditoria-itens/export/pdf` | Exportar para PDF com filtros | `aud:itens:export` | 200 (file), 400, 403 |
| POST | `/api/v1/auditoria-itens/gerar-contestacao` | Gerar documento de contestação | `aud:itens:contestacao` | 200 (file), 400, 403 |
| GET | `/api/v1/auditoria-itens/relatorios/por-operadora` | Relatório consolidado por operadora | `aud:itens:view` | 200, 400, 403 |
| GET | `/api/v1/auditoria-itens/relatorios/por-tipo` | Relatório consolidado por tipo serviço | `aud:itens:view` | 200, 400, 403 |
| POST | `/api/v1/auditoria-itens/divergencias-criticas/notificar` | Notificar divergências críticas | `aud:itens:view` | 200, 400, 403 |
| GET | `/api/v1/auditoria-itens/resumo/{resumoId}` | Resumo de auditoria com itens | `aud:itens:view` | 200, 404, 403 |
| GET | `/api/v1/auditoria-itens/dashboard` | Dashboard com KPIs | `aud:itens:view` | 200, 400, 403 |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Criação e Análise de Item de Auditoria

```
1. Auditor acessa /gestao/auditoria-itens/novo
   |
   v
2. Preenche formulário:
   - Seleciona resumo de auditoria (dropdown, carrega bilhetes do resumo)
   - Seleciona bilhete (filtrado por resumo)
   - Insere valores: cobrado, contratual, correto
   |
   v
3. Sistema calcula automaticamente:
   - ValorCobradoAMais = ValorCobrado - ValorCorreto
   - PercentualDivergencia = (ValorCobradoAMais / ValorCorreto) * 100
   - Classifica divergência (crítica/alta/média/baixa)
   |
   v
4. Validações de negócio:
   - Bilhete existe e é ativo?
   - Resumo existe e é ativo?
   - Valores são precisão decimal válida?
   - Unidade de consumo é compatível com tipo de bilhete?
   |
   +--- [Validação FALHA] --> Retorna HTTP 400 com erros específicos
   |
   v (Validação PASSOU)
5. Salva item com auditoria:
   - FlExcluido = false
   - DataCriacao = NOW
   - UsuarioCriacao = usuário logado
   |
   v
6. Dispara Domain Event: AuditoriaItemCriadoDomainEvent
   |
   v
7. Handler recalcula resumo associado:
   - TotalValorCobrado = SUM itens ativos
   - TotalValorCorreto = SUM itens ativos
   - TotalGlosa = diferença
   - TotalItens = COUNT itens ativos
   |
   v
8. Retorna HTTP 201 + item criado
   |
   v
9. Frontend notifica usuário com mensagem de sucesso
   |
   v
10. Se divergência CRÍTICA (>10%), dispara notificação SignalR para gestores
```

### 6.2 Fluxo de Exportação para Contestação

```
1. Auditor seleciona múltiplos itens (checkboxes)
   |
   v
2. Clica botão "Gerar Contestação"
   |
   v
3. Abre modal com opções:
   - Formato: PDF / Excel / CSV
   - Agrupamento: Por Operadora / Por Tipo Serviço / Por Período
   |
   v
4. Frontend valida:
   - Pelo menos 1 item selecionado?
   - Resumo ID é válido?
   |
   v
5. Envia POST /api/auditoria-itens/gerar-contestacao
   {
     "auditoriaResumoId": "guid",
     "itemIds": ["guid1", "guid2", ...],
     "formato": "PDF",
     "agrupamento": "operadora"
   }
   |
   v
6. Backend busca items com validação de permissão e tenancy
   |
   v
7. Agrupa items conforme solicitado:
   - Por operadora: TIM / OI / Vivo / Algar
   - Calcula subtotal de glosas por grupo
   |
   v
8. Gera documento estruturado:
   - Cabeçalho com data, total geral
   - Tabela de itens agrupados
   - Justificativas técnicas
   - Assinatura eletrônica (timestamp)
   |
   v
9. Converte para formato solicitado (PDF / Excel / CSV)
   |
   v
10. Retorna HTTP 200 + arquivo binário
    Content-Type: application/pdf (ou excel/csv)
    Content-Disposition: attachment; filename="contestacao-202512.pdf"
   |
   v
11. Browser faz download automaticamente
```

### 6.3 Fluxo de Relatório por Operadora

```
1. Gestor acessa /gestao/auditoria-itens/relatorios
   |
   v
2. Seleciona filtros:
   - Período (data início/fim)
   - Operadora (multi-select ou todas)
   - Divergência mínima (0-100%)
   |
   v
3. Clica "Gerar Relatório"
   |
   v
4. GET /api/auditoria-itens/relatorios/por-operadora?
   &dataInicio=2025-01-01
   &dataFim=2025-12-31
   &operadoras=TIM,OI,Vivo
   &divergenciaMinima=5
   |
   v
5. Backend executa query otimizada com índices:
   - Agrupa por operadora
   - Calcula somas e médias por grupo
   - Ordena por glosa descendente
   |
   v
6. Retorna dados agregados:
   {
     "periodo": "Jan-Dez/2025",
     "totalGeral": 50000.00,
     "totalItens": 2500,
     "operadoras": [
       {
         "nome": "TIM",
         "glosa": 25000.00,
         "divergenciaMedia": 8.5%,
         "itens": 1200
       },
       {
         "nome": "OI",
         "glosa": 15000.00,
         "divergenciaMedia": 6.2%,
         "itens": 800
       }
     ]
   }
   |
   v
7. Frontend renderiza gráficos (Chart.js):
   - Gráfico pizza: Glosa por operadora
   - Gráfico barras: Itens por operadora
   - Tabela detalhada
   |
   v
8. Usuário pode exportar como Excel
```

---

## 7. SEGURANÇA

### 7.1 Proteções Implementadas

| Proteção | Descrição | Implementação |
|----------|-----------|----------------|
| **SQL Injection** | Previne injeção de SQL em queries | Uso exclusivo de EF Core com parametrizadas, sem concatenação de strings |
| **XSS (Cross-Site Scripting)** | Sanitização de campos de texto | DomSanitizer do Angular + validation rules no backend |
| **CSRF Protection** | Token CSRF obrigatório em POST/PUT/DELETE | Middleware CSRF global, tokens no header X-CSRF-TOKEN |
| **Autenticação** | Apenas usuários logados podem acessar | JWT Bearer Token + ValidateAntiforgeryToken attribute |
| **Autorização (RBAC)** | Validação de permissão em cada endpoint | [Authorize(Policy = "aud:itens:view")] |
| **Row-Level Security** | Isolamento automático por ConglomeradoId | Global Query Filter no DbContext |
| **Data Encryption** | Criptografia de dados sensíveis em repouso | EF Core with TDE (Transparent Data Encryption) |
| **Validação de Entrada** | Reject invalid payloads | FluentValidation com rejeição HTTP 400 |
| **Rate Limiting** | Previne abuso de API | Middleware AspNetCoreRateLimit (max 100 req/min por usuário) |
| **HTTPS** | Comunicação criptografada | Forced HTTPS, TLS 1.2+ |

### 7.2 Testes de Segurança Obrigatórios

- [ ] SQL Injection em campo Lote (teste de payload UNION SELECT)
- [ ] SQL Injection em campo Fatura (teste de payload DROP TABLE)
- [ ] XSS em campo ValorCobrado (teste de payload <script>alert()</script>)
- [ ] CSRF em POST /api/auditoria-itens (teste sem token)
- [ ] Autorização: Auditor tenta DELETE (sem permissão, deve retornar 403)
- [ ] Autorização: Gestor tenta CREATE (sem permissão, deve retornar 403)
- [ ] Row-Level Security: Cliente A tenta acessar dados de Cliente B (deve retornar vazio)
- [ ] Rate Limiting: 150 requisições em 1 minuto (deve retornar 429 após limite)
- [ ] Validação de precisão decimal: Payload com 9 decimais (deve retornar 400)
- [ ] Validação de FK: Bilhete inexistente (deve retornar 400 + erro específico)

---

## 8. MÉTRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medição | Frequência |
|-----|------|---------|-----------|
| **Glosa Recuperada (R$)** | 50% da glosa auditada | SUM(ValorCobradoAMais) onde Status=Recuperado / SUM(ValorCobradoAMais) total | Mensal |
| **Tempo Médio de Análise** | < 2 dias | DataAprovacao - DataCriacao | Mensal |
| **Taxa de Divergência Crítica** | < 5% | COUNT(Divergencia > 10%) / COUNT(total) | Mensal |
| **Performance de Query Lista** | < 500ms | Tempo resposta GET /api/auditoria-itens | Contínuo |
| **Taxa de Sucesso de Exportação** | > 99% | COUNT(exports com sucesso) / COUNT(exports totais) | Mensal |
| **Cobertura de Auditoria** | > 95% | COUNT(itens auditados) / COUNT(bilhetes carregados) | Mensal |
| **Acurácia de Glosa** | > 98% | COUNT(glosas confirmadas) / COUNT(glosas propostas) | Mensal |
| **Taxa de Erro de Validação** | < 2% | COUNT(erros de validação) / COUNT(tentativas de criação) | Mensal |

### 8.2 Alertas

| Alerta | Condição | Ação | Destinatário |
|--------|----------|------|-------------|
| **Divergência Crítica** | ValorCobradoAMais > 10% do contratual | Notificação SignalR em tempo real + Email | Gestores de Auditoria |
| **Query Performance** | Query > 2s | Log de aviso, análise de índice | DBA |
| **Falha de Exportação** | Export com erro após 3 tentativas | Log de erro, notificação ao administrador | Admin |
| **Falta de Sincronização** | Resumo não atualizado 5min após item criado | Retrigger handler, alerta se falhar novamente | Operações |
| **Retenção de Auditoria** | Logs com > 7 anos | Archive para blob storage, delete | Admin (automático) |

---

## 9. PRÓXIMOS PASSOS

1. **Especificação UC-RF034**: Criar documento [UC-RF034.md](./UC-RF034.md) com 5 casos de uso detalhados (UC00-UC04)

2. **Modelo de Dados**: Criar [MD-RF034.md](./MD-RF034.md) com DDL completo, relacionamentos, índices, auditoria, multi-tenancy

3. **Workflow/Telas**: Criar [WF-RF034.md](./WF-RF034.md) com layouts Angular, estados, transições, componentes

4. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml) com mínimo 2-3 stories com acceptance criteria detalhados

5. **Implementação Backend**:
   - Clean Architecture (Entities, Commands, Queries, Handlers, Validators)
   - Domain Events para sincronização de resumos
   - Repository Pattern com Generic Repository
   - Migração de dados do legado

6. **Implementação Frontend**:
   - Componente de Lista (angular-material table com sorting/paging/filtros)
   - Componente de Formulário (validação real-time)
   - Componente de Relatórios (gráficos com Chart.js)
   - Dashboard com KPIs

7. **Testes Automatizados**:
   - Unit Tests (FluentValidation, Domain Rules)
   - Integration Tests (API endpoints com dados de teste)
   - E2E Tests (Playwright: CRUD completo)

8. **Documentação de Testes**: Criar [TC-RF034-BACKEND.md](./TC-RF034-BACKEND.md), [TC-RF034-FRONTEND.md](./TC-RF034-FRONTEND.md), [TC-RF034-E2E.md](./TC-RF034-E2E.md)

---

## CHANGELOG

| Versão | Data | Descrição | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versão inicial completa seguindo RF.md rigorosamente | Claude Code |

---

**Última Atualização**: 2025-12-28
**Autor**: Claude Code (Anthropic)
**Revisão**: Pendente de aprovação por Arquiteto
