# RF113: Automação RPA e Bots

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF078 (Integrações ERPs), RF108 (CAPTCHA/MFA) | **EPIC**: EPIC011-INT-Integracoes
**Fase**: Fase 6 - Ativos, Auditoria e Integrações
**Módulo**: Robotic Process Automation e Chatbots

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

O módulo de **Automação RPA e Bots** do sistema IControlIT é responsável por automatizar processos repetitivos e de alta frequência, como download automático de faturas de operadoras, extração de dados de emails, preenchimento de formulários web, e atendimento inicial de usuários através de chatbot baseado em IA. Este requisito especifica a implementação de bots inteligentes, schedulables e monitoráveis que aumentam a eficiência operacional e reduzem erros manuais.

O módulo resolve o problema de processos manuais lentos e propensos a erros, permitindo automatização segura, auditada e governada. É destinado a administradores de sistema, operadores de Service Desk e usuários finais que necessitam de interação com o chatbot de suporte.

### 1.2 Importância Estratégica

O módulo de RPA e Bots é crítico para:

- **Eficiência Operacional**: Reduz tempo de processamento de faturas de 2 horas para 5 minutos através de bots de automação
- **Redução de Erros**: Automatização de validação elimina erros manuais na extração de dados (target: 99.9% acurácia)
- **Conformidade**: Todos os bots operam sob auditoria completa, rastreabilidade de ações e compliance com LGPD
- **Suporte 24/7**: Chatbot fornece FAQ e respostas automáticas, reduzindo tickets do Service Desk em até 40%
- **Escalabilidade**: RPA permite processar volumes crescentes de faturas e emails sem adição de headcount

### 1.3 Conceitos Fundamentais

**RPA (Robotic Process Automation)**: Automação de processos que envolvem interação com sistemas legados, websites e aplicações através de simulação de ações humanas (clicks, preenchimento de formulários, extração de dados).

**Bot de Download**: Agente autônomo que acessa portais de operadoras telecom, autentica-se, localiza e baixa faturas de forma automática, aplicando validações de integridade.

**Bot de Email**: Agente que monitora caixas de email compartilhadas, extrai anexos (faturas, NFs), realiza OCR e publica dados estruturados no sistema.

**Chatbot (Conversational AI)**: Interface de linguagem natural que entende perguntas e fornece respostas automáticas sobre FAQ, tickets de suporte, status de ativos, etc.

**OCR (Optical Character Recognition)**: Tecnologia de reconhecimento óptico que extrai texto de imagens e documentos digitalizados com alta acurácia (95%+).

**NLP (Natural Language Processing)**: Processamento de linguagem natural que permite ao chatbot compreender intenções do usuário e responder de forma contextualizada.

**LUIS (Language Understanding Intelligent Service)**: Serviço Azure que treina modelos de NLP para reconhecer intents e entities de forma acurada.

**Agendamento (Scheduling)**: Capacidade de agendar execução de bots em períodos específicos (ex: toda terça-feira às 2h da manhã) usando Hangfire.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Automação de Processos** | Scripts VB.NET manuais sem governança | Bots configuráveis com UI e scheduling via Hangfire |
| **Chatbot** | Não existe | Azure Bot Service + LUIS integrado |
| **OCR** | Não existe ou manual | Azure Form Recognizer + Tesseract.NET |
| **Auditoria de Bots** | Logs de arquivo não estruturados | Auditoria estruturada, queryable em BD relacional |
| **Monitoramento** | Nenhum | Dashboard de status, métricas, alertas em tempo real |
| **Integrações** | Hard-coded em SP/código | Feature flags, configuração centralizada |
| **Tratamento de Erros** | Try-catch genérico | Retry com backoff exponencial, circuit breakers |
| **Rate Limiting** | Manual | Automático com configuração por API externa |

### 1.5 Funcionalidades Principais

1. **Bot de Download Automático de Faturas** - Download agendado de faturas de operadoras (Vivo, Claro, TIM, Oi, Embratel) com validação e criptografia de credenciais
2. **Bot de Extração de Emails** - Monitoramento de caixas compartilhadas com extração de anexos, OCR e publicação de dados estruturados
3. **Bot de Preenchimento de Formulários Web** - Automação de interação com websites legados (portais de operadoras, seguradoras) através de Selenium/Playwright
4. **Chatbot de Atendimento** - Interface conversacional com FAQ, resolução de tickets, informações de ativos, integrada com Azure Bot Service
5. **Agendamento de Execução** - Interface para agendar bots (daily, weekly, monthly) usando Hangfire como scheduler backend
6. **Monitoramento de Bots** - Dashboard com status em tempo real, logs estruturados, métricas de execução, alertas de falha
7. **OCR e Validação de Documentos** - Extração de dados de faturas/NFs com validação automática usando Azure Form Recognizer
8. **Workflow de Aprovação** - Fluxo de aprovação humana para ações críticas (ex: pagamento de fatura) com notificações
9. **Criptografia de Credenciais** - Armazenamento seguro de credenciais de bots (usernames, passwords, API keys) usando AES-256
10. **Retry e Resilência** - Retry automático com backoff exponencial, circuit breakers para APIs externas, timeouts configuráveis

---

## 2. REGRAS DE NEGÓCIO

### RN-RPA-113-01: Criptografia de Credenciais do Bot

**Descrição**: Credenciais de bots (senhas de operadoras, API keys, tokens) devem ser armazenadas criptografadas usando AES-256-CBC com chave derivada de PBKDF2.

**Justificativa**: LGPD exige proteção de dados sensíveis. Bots acessam contas de terceiros que precisam de máxima proteção.

**Implementação**:
```csharp
public class BotCredentialEncryptor
{
    private const int KeySizeBytes = 32; // 256 bits
    private const int IvSizeBytes = 16;   // 128 bits
    private const int IterationCount = 100000;

    public string EncryptCredential(string plainText, string masterKey)
    {
        using (var deriveBytes = new Rfc2898DeriveBytes(masterKey, Encoding.UTF8.GetBytes("ICONTROLIT_SALT"), IterationCount, HashAlgorithmName.SHA256))
        {
            byte[] key = deriveBytes.GetBytes(KeySizeBytes);

            using (var aes = Aes.Create())
            {
                aes.Key = key;
                aes.Mode = CipherMode.CBC;
                aes.GenerateIV();

                using (var encryptor = aes.CreateEncryptor(aes.Key, aes.IV))
                using (var ms = new MemoryStream())
                {
                    ms.Write(aes.IV, 0, aes.IV.Length);
                    using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                    using (var sw = new StreamWriter(cs))
                    {
                        sw.Write(plainText);
                    }
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
        }
    }

    public string DecryptCredential(string encryptedText, string masterKey)
    {
        byte[] buffer = Convert.FromBase64String(encryptedText);

        using (var deriveBytes = new Rfc2898DeriveBytes(masterKey, Encoding.UTF8.GetBytes("ICONTROLIT_SALT"), IterationCount, HashAlgorithmName.SHA256))
        {
            byte[] key = deriveBytes.GetBytes(KeySizeBytes);

            using (var aes = Aes.Create())
            {
                aes.Key = key;
                aes.Mode = CipherMode.CBC;
                aes.IV = buffer.Take(IvSizeBytes).ToArray();

                using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
                using (var ms = new MemoryStream(buffer, IvSizeBytes, buffer.Length - IvSizeBytes))
                using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                using (var sr = new StreamReader(cs))
                {
                    return sr.ReadToEnd();
                }
            }
        }
    }
}
```

**Exemplos**:
- ✓ Credencial criptografada: "AQIDAHgx0kV+h1j...==" (Base64)
- ✗ Credencial em texto plano: "senha123" (VIOLAÇÃO)

---

### RN-RPA-113-02: Timeout de Execução do Bot

**Descrição**: Cada bot tem timeout máximo de 15 minutos. Se exceder, é interrompido com status ERROR e notificação de administrador.

**Justificativa**: Previne travamento de recursos, redireciona fluxo de erro para aprovação manual. APIs externas podem travar indefinidamente.

**Implementação**:
```csharp
public class BotExecutionService
{
    private const int TimeoutSeconds = 900; // 15 minutos

    public async Task<BotExecutionResult> ExecuteWithTimeoutAsync(IBot bot, CancellationToken cancellationToken = default)
    {
        try
        {
            using (var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
            {
                cts.CancelAfter(TimeoutSeconds * 1000);

                var result = await bot.ExecuteAsync(cts.Token);
                return result;
            }
        }
        catch (OperationCanceledException)
        {
            return BotExecutionResult.CreateError(
                $"Bot {bot.Id} excedeu timeout de {TimeoutSeconds} segundos",
                BotErrorCode.Timeout
            );
        }
    }
}
```

**Validação SQL**:
```sql
ALTER TABLE [dbo].[RPA_BotExecution] ADD CONSTRAINT [CHK_ExecutionDuration]
CHECK (DATEDIFF(SECOND, [DataInicio], [DataFim]) <= 900);
```

**Exemplos**:
- ✓ Bot executa em 8 minutos e completa com sucesso
- ✗ Bot tenta executar por 20 minutos e é cancelado com status ERROR

---

### RN-RPA-113-03: Retry Automático com Backoff Exponencial

**Descrição**: Falhas em execução de bot disparam até 2 tentativas de retry, com intervalo de 5 minutos entre tentativas. Retry é aplicável apenas para erros transitórios (timeout, 5xx).

**Justificativa**: APIs externas podem falhar temporariamente. Retry automático reduz intervenção manual e melhora taxa de sucesso.

**Implementação**:
```csharp
public class BotRetryPolicy
{
    private const int MaxRetries = 2;
    private const int InitialDelaySeconds = 300; // 5 minutos

    public async Task<BotExecutionResult> ExecuteWithRetryAsync(Func<Task<BotExecutionResult>> action)
    {
        int attempt = 0;
        int delaySeconds = InitialDelaySeconds;

        while (true)
        {
            try
            {
                var result = await action();
                if (result.IsSuccess || !IsTransientError(result.ErrorCode))
                {
                    return result;
                }

                attempt++;
                if (attempt >= MaxRetries)
                {
                    return result;
                }

                await Task.Delay(delaySeconds * 1000);
                delaySeconds = (int)(InitialDelaySeconds * Math.Pow(2, attempt)); // exponential backoff
            }
            catch (Exception ex) when (IsTransientException(ex) && attempt < MaxRetries)
            {
                attempt++;
                await Task.Delay(delaySeconds * 1000);
                delaySeconds = (int)(InitialDelaySeconds * Math.Pow(2, attempt));
            }
        }
    }

    private bool IsTransientError(BotErrorCode code) =>
        code == BotErrorCode.Timeout ||
        code == BotErrorCode.NetworkError ||
        code == BotErrorCode.ServiceUnavailable;

    private bool IsTransientException(Exception ex) =>
        ex is TimeoutException ||
        ex is HttpRequestException hrex && (int?)hrex.StatusCode >= 500;
}
```

**Exemplos**:
- ✓ Bot falha com timeout → aguarda 5 min → retry 1 → falha com timeout → aguarda 10 min → retry 2 → sucesso
- ✗ Bot falha com erro crítico (credencial inválida) → sem retry → status ERROR

---

### RN-RPA-113-04: Retenção de Logs de Execução

**Descrição**: Logs de execução de bots são mantidos por 180 dias. Após este período, são arquivados em Azure Blob Storage (cold tier) ou excluídos conforme política.

**Justificativa**: LGPD define período mínimo de auditoria. Logs antigos consomem espaço no BD.

**Validação SQL**:
```sql
ALTER TABLE [dbo].[RPA_BotExecutionLog] ADD CONSTRAINT [CK_LogRetention]
CHECK ([DataExclusao] IS NULL OR [DataExclusao] > DATEADD(DAY, -180, GETUTCDATE()));

-- Index para limpeza eficiente
CREATE INDEX [IX_BotExecutionLog_DataCriacao]
ON [dbo].[RPA_BotExecutionLog]([DataCriacao])
WHERE [DataExclusao] IS NULL;
```

**Exemplos**:
- ✓ Log criado em 2025-01-01, retido até 2025-07-01, então arquivado
- ✗ Log criado em 2025-01-01, acessado em 2026-01-01 (fora da retenção)

---

### RN-RPA-113-05: Validação de Checksum de Arquivos Baixados

**Descrição**: Arquivos baixados por bot (faturas PDF, anexos) devem ter checksum SHA256 validado. Download é rejeitado se checksum não corresponder.

**Justificativa**: Garante integridade e detecção de corrupção ou man-in-the-middle. Faturas alteradas afetam billing.

**Implementação**:
```csharp
public class FileIntegrityValidator
{
    public async Task<bool> ValidateFileIntegrityAsync(Stream fileStream, string expectedSha256)
    {
        using (var sha256 = SHA256.Create())
        {
            byte[] hash = await Task.Run(() => sha256.ComputeHash(fileStream));
            string computedSha256 = BitConverter.ToString(hash).Replace("-", "").ToLower();

            if (computedSha256 != expectedSha256.ToLower())
            {
                throw new FileIntegrityException(
                    $"Checksum mismatch for file. Expected: {expectedSha256}, Computed: {computedSha256}"
                );
            }

            return true;
        }
    }

    public async Task<string> ComputeFileChecksumAsync(Stream fileStream)
    {
        using (var sha256 = SHA256.Create())
        {
            byte[] hash = await Task.Run(() => sha256.ComputeHash(fileStream));
            return BitConverter.ToString(hash).Replace("-", "").ToLower();
        }
    }
}
```

**Exemplos**:
- ✓ Arquivo PDF com checksum válido é aceito e armazenado
- ✗ Arquivo alterado durante download é rejeitado com erro de integridade

---

### RN-RPA-113-06: Taxa de Confiança Mínima de Chatbot (NLP)

**Descrição**: Chatbot responde apenas com score de confiança ≥ 70%. Abaixo deste threshold, escala para atendimento humano com sugestão de topicos.

**Justificativa**: Respostas com baixa confiança causam frustração. Escalation garante qualidade de atendimento.

**Implementação**:
```csharp
public class ChatbotIntentResolver
{
    private const double MinimumConfidenceThreshold = 0.70;

    public async Task<ChatbotResponse> ResolveChatbotQueryAsync(string userQuery, LuisRecognizer luisClient)
    {
        var result = await luisClient.RecognizeAsync<BotIntents>(userQuery);

        if (result.TopScoringIntent.Score < MinimumConfidenceThreshold)
        {
            // Escala para atendimento humano
            return ChatbotResponse.CreateEscalation(
                "Não consegui entender sua pergunta com certeza suficiente. " +
                "Um agente de suporte foi escalado para ajudar.",
                suggestedTopics: ExtractIntentSuggestions(result)
            );
        }

        return ChatbotResponse.CreateSuccess(
            GetResponseForIntent(result.TopScoringIntent.Intent),
            confidence: result.TopScoringIntent.Score
        );
    }

    private List<string> ExtractIntentSuggestions(RecognizerResult recognizerResult)
    {
        return recognizerResult.Intents
            .Where(x => x.Value.Score >= 0.5)
            .OrderByDescending(x => x.Value.Score)
            .Take(3)
            .Select(x => x.Key)
            .ToList();
    }
}
```

**Exemplos**:
- ✓ User: "Como reativar meu notebook?" → Score 0.92 → Resposta: "Para reativar seu notebook, acesse..."
- ✗ User: "Blabla" → Score 0.35 → Escala: "Um agente foi acionado"

---

### RN-RPA-113-07: Rate Limiting de APIs Externas

**Descrição**: Execução de bots respeita rate limiting das APIs externas. Configuração por operadora define limite de requests (ex: Vivo = 100 req/hora, Claro = 50 req/hora).

**Justificativa**: Operadoras punem clientes com IP block se excederem rate limit. Deve-se respeitar limites publicados.

**Implementação**:
```csharp
public class ApiRateLimiter
{
    private readonly IDistributedCache _cache;

    public async Task<bool> AllowRequestAsync(string apiKey, int maxRequestsPerHour)
    {
        string cacheKey = $"rate_limit:{apiKey}:{DateTime.UtcNow:yyyyMMddHH}";

        var countStr = await _cache.GetStringAsync(cacheKey);
        int count = int.Parse(countStr ?? "0");

        if (count >= maxRequestsPerHour)
        {
            return false;
        }

        await _cache.SetStringAsync(
            cacheKey,
            (count + 1).ToString(),
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)
            }
        );

        return true;
    }
}
```

**Exemplos**:
- ✓ Vivo com limite 100/hora: 80 requisições executadas, 20 pendentes
- ✗ Claro com limite 50/hora: 50 requisições executadas, fila aguardando próxima hora

---

### RN-RPA-113-08: Multi-Tenancy em Execução de Bots

**Descrição**: Todos os bots, execuções e logs devem ter ClienteId preenchido. Query filter do EF Core garante isolamento automático por tenant.

**Justificativa**: IControlIT é multi-tenant. Impossibilitar acesso cruzado entre clientes é crítico.

**Implementação**:
```csharp
public class BotDbContext : DbContext
{
    private readonly ICurrentClientProvider _currentClientProvider;

    public DbSet<RpaBot> Bots { get; set; }
    public DbSet<RpaBotExecution> BotExecutions { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Query filter para Bots
        modelBuilder.Entity<RpaBot>()
            .HasQueryFilter(b => b.ClienteId == _currentClientProvider.GetCurrentClientId());

        // Query filter para Execuções
        modelBuilder.Entity<RpaBotExecution>()
            .HasQueryFilter(be => be.ClienteId == _currentClientProvider.GetCurrentClientId());
    }
}

// Validação na inserção
public class CreateBotCommandHandler : IRequestHandler<CreateBotCommand, BotId>
{
    public async Task<BotId> Handle(CreateBotCommand request, CancellationToken ct)
    {
        var bot = new RpaBot
        {
            Id = BotId.New(),
            ClienteId = _currentClientProvider.GetCurrentClientId(), // OBRIGATÓRIO
            Nome = request.Nome,
            // ... outros campos
        };

        // Validação de segurança
        if (bot.ClienteId == Guid.Empty)
            throw new InvalidOperationException("ClienteId must be set");

        _context.Bots.Add(bot);
        await _context.SaveChangesAsync(ct);

        return bot.Id;
    }
}
```

**Exemplos**:
- ✓ Cliente A cria bot, pode ver e executar apenas seus bots
- ✗ Cliente B tenta acessar bot de Cliente A → 404 (query filter oculta)

---

### RN-RPA-113-09: Aprovação Humana para Ações Críticas

**Descrição**: Ações críticas de bot (ex: pagamento de fatura, exclusão de registro) requerem aprovação explícita de usuário com permissão ADMIN antes de execução.

**Justificativa**: RPA opera automaticamente. Ações irreversíveis exigem validação humana para evitar desastres.

**Implementação**:
```csharp
public class CriticalActionApprovalWorkflow
{
    public async Task<bool> RequiresApprovalAsync(BotAction action)
    {
        var criticalActions = new[]
        {
            BotActionType.PaymentExecution,
            BotActionType.BulkDelete,
            BotActionType.ContractTermination,
            BotActionType.CredentialUpdate
        };

        return criticalActions.Contains(action.Type);
    }

    public async Task<WorkflowApproval> CreateApprovalRequestAsync(BotAction action, RpaBotExecution execution)
    {
        var approval = new WorkflowApproval
        {
            Id = WorkflowApprovalId.New(),
            ClienteId = action.ClienteId,
            ExecutionId = execution.Id,
            Type = WorkflowApprovalType.BotCriticalAction,
            Description = $"Aprovação de {action.Type}: {action.Description}",
            CreatedAt = DateTime.UtcNow,
            RequiredApprovers = 2, // ou politica configuravel
            Status = ApprovalStatus.Pending
        };

        _context.WorkflowApprovals.Add(approval);
        await _context.SaveChangesAsync();

        // Notificar aprovadores
        await _notificationService.NotifyAdminsAsync(
            action.ClienteId,
            $"Ação crítica de bot aguardando aprovação: {action.Description}"
        );

        return approval;
    }
}
```

**Exemplos**:
- ✓ Bot executa pagamento → Workflow aguarda aprovação → Admin aprova → Pagamento processado
- ✗ Bot tenta executar pagamento sem aprovação → BLOQUEADO

---

### RN-RPA-113-10: Auditoria Completa de Execuções e Ações de Bots

**Descrição**: Toda execução de bot (início, fim, ações internas) e toda interação com chatbot (query, resposta) é registrada em tabela de auditoria com timestamp, usuário, ClienteId e mudanças de estado.

**Justificativa**: LGPD exige rastreabilidade completa. Bots executam operações que afetam dados críticos.

**Implementação**:
```csharp
public class BotAuditService
{
    public async Task AuditBotExecutionStartAsync(RpaBotExecution execution, ICurrentUserProvider userProvider)
    {
        var auditEntry = new AuditLog
        {
            Id = AuditLogId.New(),
            ClienteId = execution.ClienteId,
            EntityType = "RPA_Bot_Execution",
            EntityId = execution.Id.ToString(),
            ActionType = "START",
            UserId = userProvider.GetCurrentUserId(),
            Timestamp = DateTime.UtcNow,
            OldValues = null,
            NewValues = JsonConvert.SerializeObject(new
            {
                execution.Id,
                execution.BotId,
                execution.Status,
                execution.DataInicio
            }),
            Changes = "BotExecution started"
        };

        await _auditRepository.LogAsync(auditEntry);
    }

    public async Task AuditBotActionAsync(BotAction action, BotActionResult result)
    {
        var auditEntry = new AuditLog
        {
            Id = AuditLogId.New(),
            ClienteId = action.ClienteId,
            EntityType = "RPA_Bot_Action",
            EntityId = action.Id.ToString(),
            ActionType = action.Type.ToString(),
            UserId = "SYSTEM_BOT", // Bot executa, não usuário
            Timestamp = DateTime.UtcNow,
            OldValues = null,
            NewValues = JsonConvert.SerializeObject(new
            {
                action.TargetEntityId,
                action.Type,
                result.IsSuccess,
                result.ErrorMessage
            }),
            Changes = $"Bot action {action.Type} executed with result: {result.IsSuccess}"
        };

        await _auditRepository.LogAsync(auditEntry);
    }

    public async Task AuditChatbotInteractionAsync(string userQuery, ChatbotResponse response, string userId)
    {
        var auditEntry = new AuditLog
        {
            Id = AuditLogId.New(),
            ClienteId = _currentClientProvider.GetCurrentClientId(),
            EntityType = "Chatbot_Interaction",
            EntityId = response.InteractionId.ToString(),
            ActionType = "CHATBOT_QUERY",
            UserId = userId,
            Timestamp = DateTime.UtcNow,
            OldValues = JsonConvert.SerializeObject(new { userQuery }),
            NewValues = JsonConvert.SerializeObject(new
            {
                response.Text,
                response.IntentDetected,
                response.ConfidenceScore
            }),
            Changes = $"Chatbot resolved intent: {response.IntentDetected}"
        };

        await _auditRepository.LogAsync(auditEntry);
    }
}

// Query para auditoria
public async Task<List<AuditLog>> GetBotAuditTrailAsync(Guid botExecutionId)
{
    return await _context.AuditLogs
        .Where(x => x.EntityType == "RPA_Bot_Execution" && x.EntityId == botExecutionId.ToString())
        .OrderByDescending(x => x.Timestamp)
        .ToListAsync();
}
```

**Exemplos**:
- ✓ Cada ação de bot registrada: "Bot iniciado às 14:32", "Download de fatura realizado", "OCR completado"
- ✗ Ação de bot sem registro em auditoria (VIOLAÇÃO)

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IC1_Legado`

**Tabelas Relacionadas a RPA**: Não existem tabelas nativas de RPA no legado. O sistema legado usa scripts VB.NET não governados para automação.

```sql
-- Estrutura esperada (não existe no legado, será criada)
CREATE TABLE [dbo].[RPA_Bot](
    [Id] [uniqueidentifier] NOT NULL PRIMARY KEY,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [Nome] [nvarchar](255) NOT NULL,
    [Descricao] [nvarchar](max) NULL,
    [Tipo] [nvarchar](50) NOT NULL, -- 'Download', 'Email', 'WebForm', 'Chatbot'
    [Status] [nvarchar](20) NOT NULL, -- 'Ativo', 'Inativo', 'Erro'
    [ConfiguracaoJson] [nvarchar](max) NOT NULL,
    [CredenciaisEncriptadas] [nvarchar](max) NULL,
    [ScheduleExpression] [nvarchar](255) NULL, -- CRON expression
    [TimeoutSeconds] [int] DEFAULT 900,
    [MaxRetries] [int] DEFAULT 2,
    [DataCriacao] [datetime2] NOT NULL,
    [DataAtualizacao] [datetime2] NULL,
    [CriadoPor] [uniqueidentifier] NOT NULL,
    CONSTRAINT [FK_RPA_Bot_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id]),
    CONSTRAINT [FK_RPA_Bot_User] FOREIGN KEY ([CriadoPor]) REFERENCES [dbo].[Usuario]([Id])
);

CREATE TABLE [dbo].[RPA_BotExecution](
    [Id] [uniqueidentifier] NOT NULL PRIMARY KEY,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [BotId] [uniqueidentifier] NOT NULL,
    [Status] [nvarchar](20) NOT NULL, -- 'Pendente', 'Executando', 'Sucesso', 'Erro'
    [DataInicio] [datetime2] NOT NULL,
    [DataFim] [datetime2] NULL,
    [DuracaoSegundos] [int] NULL,
    [MensagemErro] [nvarchar](max) NULL,
    [CodigoErro] [nvarchar](50) NULL,
    [TentativaAtual] [int] DEFAULT 1,
    [ResultadoJson] [nvarchar](max) NULL,
    CONSTRAINT [PK_RPA_BotExecution] PRIMARY KEY ([Id]),
    CONSTRAINT [FK_RPA_BotExecution_Bot] FOREIGN KEY ([BotId]) REFERENCES [dbo].[RPA_Bot]([Id]),
    CONSTRAINT [FK_RPA_BotExecution_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id])
);

CREATE TABLE [dbo].[RPA_BotExecutionLog](
    [Id] [uniqueidentifier] NOT NULL PRIMARY KEY,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [ExecutionId] [uniqueidentifier] NOT NULL,
    [Nivel] [nvarchar](20) NOT NULL, -- 'Info', 'Warning', 'Error'
    [Mensagem] [nvarchar](max) NOT NULL,
    [DataCriacao] [datetime2] NOT NULL,
    CONSTRAINT [FK_RPA_Log_Execution] FOREIGN KEY ([ExecutionId]) REFERENCES [dbo].[RPA_BotExecution]([Id])
);

CREATE TABLE [dbo].[Chatbot_Conversation](
    [Id] [uniqueidentifier] NOT NULL PRIMARY KEY,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [UserId] [uniqueidentifier] NOT NULL,
    [UserQuery] [nvarchar](max) NOT NULL,
    [ChatbotResponse] [nvarchar](max) NOT NULL,
    [IntentDetected] [nvarchar](100) NULL,
    [ConfidenceScore] [float] NULL,
    [EscaledToHuman] [bit] DEFAULT 0,
    [DataCriacao] [datetime2] NOT NULL,
    CONSTRAINT [FK_Chatbot_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id]),
    CONSTRAINT [FK_Chatbot_User] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Usuario]([Id])
);
```

### 3.2 Artefatos Legado VB.NET

Não existem classes de RPA no legado. O projeto modernizado criará toda a infraestrutura do zero.

**Scripts Manuais**: Alguns clientes usam scripts VB.NET manuais em pastas compartilhadas (não governados, não auditados). Estes serão migrados para o novo sistema de bots.

### 3.3 Telas ASPX

| Pagina | Descricao | Tela Moderna |
|--------|-----------|--------------|
| (não existe) | Sistema legado não tem suporte a bots | `/bots` (Angular) |

### 3.4 WebServices Legado (VB.NET)

Não existem WebServices específicos para RPA no legado.

---

## 4. INTEGRACOES OBRIGATORIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `RPA_AUTOMATION_ENGINE`

**Configuracao**:
```json
{
    "featureKey": "RPA_AUTOMATION_ENGINE",
    "nome": "RPA Automation Engine",
    "descricao": "Habilita execução de bots e automação de processos",
    "habilitado": true,
    "isSystemFeature": true
}
```

**FeatureKey**: `CHATBOT_INTEGRATION`

```json
{
    "featureKey": "CHATBOT_INTEGRATION",
    "nome": "Chatbot Integration",
    "descricao": "Habilita interface de chatbot para suporte ao usuário",
    "habilitado": true,
    "isSystemFeature": true
}
```

**FeatureKey**: `BOT_APPROVAL_WORKFLOW`

```json
{
    "featureKey": "BOT_APPROVAL_WORKFLOW",
    "nome": "Bot Critical Action Approval",
    "descricao": "Requer aprovação humana para ações críticas de bot",
    "habilitado": true,
    "isSystemFeature": true
}
```

---

### 4.2 Internacionalizacao (i18n)

**Chaves de Traducao**:

```json
{
    "rpa": {
        "bots": {
            "title": "Automação de Processos (RPA)",
            "list_title": "Meus Bots",
            "create_title": "Criar Novo Bot",
            "edit_title": "Editar Bot",
            "form": {
                "name": "Nome do Bot",
                "description": "Descrição",
                "type": "Tipo de Bot",
                "status": "Status",
                "schedule": "Agendamento (CRON)",
                "timeout": "Timeout (segundos)",
                "max_retries": "Máximo de Tentativas",
                "type_download": "Download de Faturas",
                "type_email": "Extração de Emails",
                "type_webform": "Preenchimento de Formulário",
                "status_active": "Ativo",
                "status_inactive": "Inativo"
            },
            "messages": {
                "create_success": "Bot criado com sucesso",
                "update_success": "Bot atualizado com sucesso",
                "delete_success": "Bot excluído com sucesso",
                "execution_started": "Execução de bot iniciada",
                "execution_failed": "Falha na execução do bot",
                "execution_timeout": "Bot excedeu timeout de execução",
                "approval_required": "Ação requer aprovação",
                "approval_granted": "Ação aprovada com sucesso"
            },
            "validation": {
                "name_required": "Nome é obrigatório",
                "type_required": "Tipo de bot é obrigatório",
                "invalid_cron": "Expressão CRON inválida",
                "timeout_invalid": "Timeout deve ser entre 60 e 3600 segundos"
            }
        },
        "executions": {
            "title": "Histórico de Execuções",
            "status_pending": "Pendente",
            "status_running": "Executando",
            "status_success": "Sucesso",
            "status_error": "Erro",
            "duration": "Duração",
            "started_at": "Iniciado em",
            "ended_at": "Finalizado em",
            "logs": "Logs de Execução",
            "retry_count": "Tentativa"
        },
        "chatbot": {
            "title": "Assistente Virtual",
            "placeholder": "Faça uma pergunta...",
            "typing": "Digitando...",
            "escalation": "Um agente de suporte foi escalado",
            "suggested_topics": "Tópicos sugeridos"
        }
    }
}
```

---

### 4.3 Auditoria

**Operacoes Auditadas**:

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Criar Bot | `RPA_BOT_CREATE` | Nome, tipo, agendamento, credenciais (criptografadas) |
| Editar Bot | `RPA_BOT_UPDATE` | Campos alterados, novo schedule, timeout |
| Excluir Bot | `RPA_BOT_DELETE` | ID do bot, motivo (se informado) |
| Iniciar Execução | `RPA_EXECUTION_START` | Bot ID, horário início, tentativa |
| Finalizar Execução | `RPA_EXECUTION_END` | Status, duração, mensagem de erro (se houver) |
| Retry Automático | `RPA_EXECUTION_RETRY` | Tentativa anterior, novo tentativa, delay |
| Ação Crítica | `RPA_CRITICAL_ACTION` | Tipo de ação, entidade afetada, aprovadores |
| Interação Chatbot | `CHATBOT_INTERACTION` | Query do usuário, intent detectado, confiança, resposta |
| Aprovação de Ação | `RPA_ACTION_APPROVAL` | Ação aprovada/rejeitada, aprovador, motivo |

**Retencao**: 180 dias (conforme LGPD)

---

### 4.4 Controle de Acesso (RBAC)

**Permissoes**:

| Permissao | Descricao | Perfis |
|-----------|-----------|--------|
| `rpa:bot:create` | Criar bot | Admin, RPA Specialist |
| `rpa:bot:read` | Visualizar bots | Admin, RPA Specialist, Operador |
| `rpa:bot:update` | Editar bot | Admin, RPA Specialist |
| `rpa:bot:delete` | Excluir bot | Admin |
| `rpa:bot:execute` | Executar bot manualmente | Admin, RPA Specialist, Operador |
| `rpa:bot:schedule` | Agendar execução | Admin, RPA Specialist |
| `rpa:bot:pause` | Pausar bot | Admin, RPA Specialist |
| `rpa:execution:read` | Visualizar execuções | Admin, RPA Specialist, Operador |
| `rpa:execution:retry` | Retentar execução | Admin, RPA Specialist |
| `rpa:approval:review` | Revisar aprovações de ação | Admin |
| `rpa:approval:approve` | Aprovar ações críticas | Admin (mínimo 2 assinaturas) |
| `rpa:credential:manage` | Gerenciar credenciais de bot | Admin, RPA Specialist |
| `chatbot:interact` | Conversar com chatbot | Todos os usuários |
| `chatbot:train` | Treinar modelo NLP | Admin, IA Specialist |

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal de Bots

| Metodo | Endpoint | Descricao | Permissao | Código |
|--------|----------|-----------|-----------|--------|
| GET | `/api/rpa/bots` | Listar todos os bots do cliente | `rpa:bot:read` | 200 |
| GET | `/api/rpa/bots/{id}` | Obter detalhes de um bot específico | `rpa:bot:read` | 200 |
| POST | `/api/rpa/bots` | Criar novo bot | `rpa:bot:create` | 201 |
| PUT | `/api/rpa/bots/{id}` | Atualizar configurações de um bot | `rpa:bot:update` | 200 |
| DELETE | `/api/rpa/bots/{id}` | Excluir um bot | `rpa:bot:delete` | 204 |

**Exemplo GET `/api/rpa/bots`**:
```json
{
    "data": [
        {
            "id": "550e8400-e29b-41d4-a716-446655440000",
            "clienteId": "660f9511-f31c-41d4-b817-556665440001",
            "nome": "Bot Download Vivo",
            "descricao": "Download automático de faturas da Vivo",
            "tipo": "Download",
            "status": "Ativo",
            "scheduleExpression": "0 2 * * 2", // Tuesday 2 AM UTC
            "timeoutSeconds": 900,
            "maxRetries": 2,
            "dataCriacao": "2025-01-15T10:30:00Z",
            "dataAtualizacao": "2025-01-20T14:45:00Z",
            "ultimaExecucao": {
                "dataInicio": "2025-01-22T02:00:00Z",
                "dataFim": "2025-01-22T02:08:30Z",
                "status": "Sucesso"
            }
        }
    ],
    "totalCount": 5,
    "pageNumber": 1,
    "pageSize": 10
}
```

**Exemplo POST `/api/rpa/bots`**:
```json
{
    "nome": "Bot Download Claro",
    "descricao": "Download automático de faturas da Claro",
    "tipo": "Download",
    "scheduleExpression": "0 3 * * 3", // Wednesday 3 AM UTC
    "timeoutSeconds": 900,
    "maxRetries": 2,
    "configuracao": {
        "operadora": "Claro",
        "portal_url": "https://portal.claro.com.br",
        "tipo_autenticacao": "CPF+Senha"
    },
    "credenciais": {
        "username": "cpf_cliente",
        "password": "senha_encriptada"
    }
}
```

### 5.2 Operacoes de Execução

| Metodo | Endpoint | Descricao | Permissao | Código |
|--------|----------|-----------|-----------|--------|
| POST | `/api/rpa/bots/{id}/executar` | Executar bot manualmente (imediato) | `rpa:bot:execute` | 202 |
| POST | `/api/rpa/bots/{id}/agendar` | Agendar execução futura | `rpa:bot:schedule` | 201 |
| GET | `/api/rpa/bots/{id}/execucoes` | Obter histórico de execuções | `rpa:execution:read` | 200 |
| GET | `/api/rpa/execucoes/{executionId}/logs` | Obter logs detalhados de uma execução | `rpa:execution:read` | 200 |
| GET | `/api/rpa/bots/{id}/status` | Obter status atual do bot | `rpa:bot:read` | 200 |
| POST | `/api/rpa/bots/{id}/pausar` | Pausar agendamento do bot | `rpa:bot:update` | 200 |
| POST | `/api/rpa/bots/{id}/retomar` | Retomar agendamento do bot | `rpa:bot:update` | 200 |

**Exemplo POST `/api/rpa/bots/{id}/executar`**:
```json
{
    "executionId": "770e8400-e29b-41d4-a716-446655440111",
    "status": "Pendente",
    "dataCriacao": "2025-01-22T14:35:00Z",
    "message": "Execução enfileirada, status será atualizado em tempo real"
}
```

Response Status 202 (Accepted)

**Exemplo GET `/api/rpa/execucoes/{executionId}/logs`**:
```json
{
    "logs": [
        {
            "timestamp": "2025-01-22T02:00:05.000Z",
            "nivel": "Info",
            "mensagem": "Iniciando execução do bot Download Vivo"
        },
        {
            "timestamp": "2025-01-22T02:00:10.000Z",
            "nivel": "Info",
            "mensagem": "Autenticando no portal da Vivo..."
        },
        {
            "timestamp": "2025-01-22T02:01:30.000Z",
            "nivel": "Info",
            "mensagem": "3 faturas encontradas, iniciando download"
        },
        {
            "timestamp": "2025-01-22T02:03:45.000Z",
            "nivel": "Info",
            "mensagem": "Validação de checksum: OK"
        },
        {
            "timestamp": "2025-01-22T02:08:30.000Z",
            "nivel": "Info",
            "mensagem": "Execução concluída com sucesso"
        }
    ],
    "totalLogs": 5
}
```

### 5.3 Endpoints de Chatbot

| Metodo | Endpoint | Descricao | Permissao | Código |
|--------|----------|-----------|-----------|--------|
| POST | `/api/chatbot/conversa` | Enviar mensagem ao chatbot | `chatbot:interact` | 200 |
| GET | `/api/chatbot/historico` | Obter histórico de conversas | `chatbot:interact` | 200 |
| POST | `/api/chatbot/treinar` | Treinar modelo NLP (admin) | `chatbot:train` | 202 |
| GET | `/api/chatbot/intents` | Listar intents disponíveis | `chatbot:interact` | 200 |

**Exemplo POST `/api/chatbot/conversa`**:
```json
{
    "userQuery": "Como faço para reativar meu notebook?",
    "conversationId": "abc123"
}

// Response
{
    "conversationId": "abc123",
    "userQuery": "Como faço para reativar meu notebook?",
    "chatbotResponse": "Para reativar seu notebook, você pode:\n1. Acessar o menu Ativos > Notebooks\n2. Localizar seu notebook\n3. Clicar em 'Reativar'\n\nPrecisa de mais ajuda?",
    "intentDetected": "asset_reactivation",
    "confidenceScore": 0.89,
    "escalatedToHuman": false,
    "suggestedTopics": ["Renovação de Contrato", "Suporte Técnico"]
}
```

### 5.4 Endpoints de Monitoramento e Métricas

| Metodo | Endpoint | Descricao | Permissao | Código |
|--------|----------|-----------|-----------|--------|
| GET | `/api/rpa/metricas` | Métricas gerais de RPA (taxa sucesso, tempo médio, etc) | `rpa:bot:read` | 200 |
| GET | `/api/rpa/bots/{id}/metricas` | Métricas específicas de um bot | `rpa:bot:read` | 200 |
| GET | `/api/rpa/alertas` | Obter alertas ativos de bots | `rpa:bot:read` | 200 |

**Exemplo GET `/api/rpa/metricas`**:
```json
{
    "totalBotsAtivos": 12,
    "totalExecucoesUltimos7dias": 84,
    "taxaSucessoTotal": 0.964, // 96.4%
    "tempoMedioExecucao": 450, // segundos
    "errosMaisComunsUltimo7dias": [
        {
            "tipo": "Timeout",
            "quantidade": 3,
            "botsMaisAfetados": ["Bot Download Vivo", "Bot Extract Email"]
        }
    ],
    "metricas_por_bot": [
        {
            "botId": "550e8400-e29b-41d4-a716-446655440000",
            "nome": "Bot Download Vivo",
            "execucoesUltimos7dias": 7,
            "sucessos": 7,
            "falhas": 0,
            "tempoMedioExecucao": 510
        }
    ]
}
```

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Execução Manual de Bot

```
Usuario acessa Dashboard de RPA
    |
    v
Clica em "Executar" do bot
    |
    v
Sistema enfileira execução (status = Pendente)
    |
    v
Worker de background processa fila
    |
    +--- Requer Aprovação? ---> Workflow de Aprovação
    |                                |
    |                                v
    |                         Admin aprova/rejeita
    |                                |
    |                                v [Aprovado]
    |
    v [Não requer ou aprovado]
Inicia execução (status = Executando)
    |
    +--- Timeout? ---> Cancelar + Status ERROR
    |
    v [Continua]
Executa steps do bot (login, download, OCR, etc)
    |
    +--- Passo falha (transiente)? ---> Retry (com delay exponencial)
    |
    v [Continua]
    |
    +--- Passo falha (crítico)? ---> Status ERROR + Notificar Admin
    |
    v [Sucesso]
Finaliza execução (status = Sucesso)
    |
    v
Log estruturado em BD + Auditoria
    |
    v
Usuario vê resultado no Dashboard
```

### 6.2 Fluxo de Execução Agendada de Bot

```
Hangfire Scheduler dispara (baseado em CRON)
    |
    v
Cria RpaBotExecution com status = Pendente
    |
    v
Worker de background pega da fila
    |
    v
[Mesmo fluxo de execução manual acima]
    |
    v
Ao concluir, próxima execução é schedulada
```

### 6.3 Fluxo de Chatbot

```
Usuario acessa Chat Widget
    |
    v
Digita pergunta (ex: "Como reativar notebook?")
    |
    v
Frontend envia POST /api/chatbot/conversa
    |
    v
Backend chama LUIS para NLP
    |
    v
    +--- Confiança >= 70%?
    |        |
    |        v [Sim]
    |    Retorna resposta apropriada
    |        |
    |        v
    |    Score = 0.89
    |
    +--- [Não]
         Escala para atendimento humano
             |
             v
         "Um agente foi acionado"
             |
             v
         Cria ticket de suporte
```

### 6.4 Fluxo de Ação Crítica (Pagamento)

```
Bot identifica fatura pronta para pagamento
    |
    v
Chama API /api/rpa/faturas/{id}/executar-pagamento
    |
    v
Sistema detecta ação crítica
    |
    v
Cria WorkflowApproval (requer 2 assinaturas)
    |
    v
Notifica 2 admins para revisão
    |
    v
Admins entram no sistema
    |
    +--- Admin 1 aprova
    |
    v [Após 2 aprovações]
    |
    +--- Admin 2 aprova
    |
    v
Sistema executa pagamento
    |
    v
Log de auditoria: "Pagamento autorizado por Admin1, Admin2"
```

---

## 7. SEGURANCA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **Criptografia de Credenciais** | AES-256-CBC com PBKDF2 derivation, 100k iterations |
| **RBAC Granular** | Permissões por ação (create, read, update, delete, execute, approve) |
| **Isolamento Multi-Tenant** | Query filters automáticos, ClienteId obrigatório |
| **Auditoria Completa** | Todas as operações registradas com timestamp, usuário, mudanças |
| **Workflow de Aprovação** | Ações críticas requerem aprovação explícita (ex: payment) |
| **Rate Limiting** | Respeita limites de APIs externas (por operadora) |
| **Timeout Obrigatório** | Máximo 15 minutos por execução, cancela se exceder |
| **Validação de Integridade** | SHA256 checksum para arquivos baixados |
| **Logging Estruturado** | Logs queryable, filtráveis por bot/execução/nível |
| **Retry com Backoff** | Exponential backoff evita hammer de APIs, máximo 2 tentativas |
| **LGPD Compliance** | Retenção 180 dias, direito ao esquecimento, consentimento explícito |
| **Notificação de Falhas** | Alertas automáticos para admin quando bot falha |

### 7.2 Testes de Seguranca Obrigatorios

- [ ] Injeção de credenciais falsas no formulário de criação de bot
- [ ] Tentativa de acessar bot de outro cliente (multi-tenancy bypass)
- [ ] SQL Injection em campos de busca de execuções
- [ ] XSS em campos de configuração de bot
- [ ] CSRF Protection em formulário de criação
- [ ] Validação de permissões (usuário sem rpa:bot:delete tenta excluir)
- [ ] Acesso a logs de execução de outro cliente
- [ ] Bypass de workflow de aprovação para ação crítica
- [ ] Rate limiting: verificar se respeitado limite de API
- [ ] Timeout: bot executado por 30 minutos é cancelado em 15
- [ ] Checksum: arquivo alterado durante download é rejeitado
- [ ] Credenciais: descriptografar credencial sem chave mestre (deve falhar)
- [ ] Audit trail: verificar completude de logs para cada operação

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao |
|-----|------|---------|
| **Taxa de Sucesso de Execução** | >= 96% | (Total Sucessos / Total Execuções) últimos 30 dias |
| **Tempo Médio de Execução** | <= 5 min | Média dos tempos de execução concluídos com sucesso |
| **Tempo de Resposta do Chatbot** | <= 2s | P95 latência de POST /api/chatbot/conversa |
| **Taxa de Escalonamento de Chatbot** | <= 5% | (Queries escaladas para humano / Total queries) |
| **MTTR (Mean Time To Recovery)** | <= 30 min | Tempo para bot recuperar após falha |
| **Disponibilidade de Bots** | >= 99.5% | Uptime de scheduler (Hangfire), ex: sem falhas > 30s |
| **Acurácia de OCR** | >= 95% | Validação de dados extraídos vs. dados esperados |
| **Taxa de Aprovação de Ações Críticas** | >= 98% | Ações aprovadas / Total submetidas |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **Bot Timeout** | Execução > 15 minutos | Cancelar bot, notificar admin, registrar em auditoria |
| **Falha Repetida** | Mesmo bot falhou 3x em 24h | Notificar admin, sugerir análise/correção |
| **Taxa de Erro Elevada** | > 10% de falhas em 24h | Enviar relatório, desativar bot automaticamente |
| **Checksum Inválido** | Arquivo falha em validação SHA256 | Rejeitar, notificar admin, não retentar |
| **Credencial Expirada** | Bot falha com erro de autenticação | Notificar admin para renovar credencial |
| **Rate Limit Atingido** | Operadora rejeitou requisição por rate limit | Aguardar, tentar próxima janela, alertar admin |
| **Escalacao de Chatbot** | Conversas escaladas para humano > 10% | Analisar intents com baixa confiança, treinar modelo |
| **Aprovação Pendente > 24h** | Ação crítica sem aprovação há 24h | Enviar reminder para aprovadores, escalacionar |

---

## 9. PROXIMOS PASSOS

1. **Modelo de Dados Relacional**: Criar [MD-RF113](./MD-RF113.md) com DDL, relacionamentos, índices, constraints
2. **Casos de Uso Detalhados**: Criar [UC-RF113](./UC-RF113.md) com 5-7 casos de uso principais
3. **Wireframes e Fluxos UI**: Criar [WF-RF113](./WF-RF113.md) com telas Angular, componentes, rotas
4. **Implementação Backend**:
   - Domain layer: Entities, Value Objects, Aggregates
   - Application layer: Commands, Queries, Handlers (MediatR)
   - Infrastructure layer: EF Core DbContext, Repositories, External services (Azure Bot, LUIS, Form Recognizer)
   - API layer: Minimal APIs, DTOs, validators, error handling
5. **Implementação Frontend**:
   - Components Angular: BotList, BotForm, ExecutionHistory, ChatWidget
   - Services: BotService, ChatbotService, WebSocketService (real-time updates)
   - Routes: /bots, /bots/create, /bots/:id, /executions, /chatbot
6. **Testes**: Criar [TC-RF113-BACKEND.md](./TC-RF113-BACKEND.md), [TC-RF113-FRONTEND.md](./TC-RF113-FRONTEND.md), [TC-RF113-E2E.md](./TC-RF113-E2E.md)
7. **User Stories**: Criar `user-stories.yaml` com quebra de implementação em sprints

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versao inicial com 10 regras de negócio, 14 endpoints, 4 integrações obrigatórias, fluxos ASCII e DDL completo | Claude Code |

---

**Ultima Atualizacao**: 2025-12-28
**Autor**: Claude Code
**Revisao**: Pendente de Aprovação

---

## APENDICE A: Estrutura de Pastas do Projeto

```
src/
├── IControlIT.RPA.Domain/
│   ├── Entities/
│   │   ├── RpaBot.cs
│   │   ├── RpaBotExecution.cs
│   │   ├── RpaBotExecutionLog.cs
│   │   └── ChatbotConversation.cs
│   ├── ValueObjects/
│   │   ├── BotId.cs
│   │   ├── BotStatus.cs
│   │   ├── BotType.cs
│   │   └── CronExpression.cs
│   └── Interfaces/
│       ├── IBot.cs
│       └── IBotRepository.cs
├── IControlIT.RPA.Application/
│   ├── Commands/
│   │   ├── CreateBotCommand.cs
│   │   ├── ExecuteBotCommand.cs
│   │   └── ApproveActionCommand.cs
│   ├── Queries/
│   │   ├── GetBotsQuery.cs
│   │   ├── GetBotExecutionsQuery.cs
│   │   └── GetChatbotHistoryQuery.cs
│   ├── Handlers/
│   │   ├── CreateBotCommandHandler.cs
│   │   ├── ExecuteBotCommandHandler.cs
│   │   └── ChatbotQueryHandler.cs
│   └── Services/
│       ├── BotExecutionService.cs
│       ├── ChatbotService.cs
│       └── RetryPolicyService.cs
├── IControlIT.RPA.Infrastructure/
│   ├── Persistence/
│   │   ├── RpaDbContext.cs
│   │   ├── Repositories/
│   │   │   ├── BotRepository.cs
│   │   │   └── BotExecutionRepository.cs
│   │   └── Migrations/
│   ├── External/
│   │   ├── AzureBotServiceClient.cs
│   │   ├── LuisClient.cs
│   │   ├── FormRecognizerClient.cs
│   │   └── OperadoraPortalClient.cs (Selenium/Playwright)
│   └── Security/
│       └── BotCredentialEncryptor.cs
└── IControlIT.RPA.API/
    ├── Controllers/
    │   ├── BotsController.cs
    │   ├── ExecutionsController.cs
    │   └── ChatbotController.cs
    ├── DTOs/
    │   ├── CreateBotRequest.cs
    │   ├── BotExecutionResponse.cs
    │   └── ChatbotMessageRequest.cs
    └── Middleware/
        └── BotAuthorizationMiddleware.cs
```

---

## APENDICE B: Tabelas SQL Completas (DDL)

```sql
-- ============================================================
-- MODULO RPA - AUTOMACAO DE PROCESSOS
-- ============================================================

-- Tabela: RPA_Bot (Definição de Bots)
CREATE TABLE [dbo].[RPA_Bot](
    [Id] [uniqueidentifier] NOT NULL,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [Nome] [nvarchar](255) NOT NULL,
    [Descricao] [nvarchar](max) NULL,
    [Tipo] [nvarchar](50) NOT NULL, -- 'Download', 'Email', 'WebForm', 'Chatbot'
    [Status] [nvarchar](20) NOT NULL DEFAULT 'Ativo', -- 'Ativo', 'Inativo', 'Erro'
    [ConfiguracaoJson] [nvarchar](max) NOT NULL,
    [CredenciaisEncriptadas] [nvarchar](max) NULL,
    [ScheduleExpression] [nvarchar](255) NULL, -- CRON: "0 2 * * 2"
    [TimeoutSeconds] [int] NOT NULL DEFAULT 900, -- 15 minutos
    [MaxRetries] [int] NOT NULL DEFAULT 2,
    [DataCriacao] [datetime2](7) NOT NULL DEFAULT GETUTCDATE(),
    [DataAtualizacao] [datetime2](7) NULL,
    [DataInativacao] [datetime2](7) NULL,
    [CriadoPor] [uniqueidentifier] NOT NULL,
    [AtualizadoPor] [uniqueidentifier] NULL,
    [IsDeleted] [bit] NOT NULL DEFAULT 0,
    CONSTRAINT [PK_RPA_Bot] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [FK_RPA_Bot_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id]),
    CONSTRAINT [FK_RPA_Bot_UserCriacao] FOREIGN KEY ([CriadoPor]) REFERENCES [dbo].[Usuario]([Id]),
    CONSTRAINT [CK_BotTipo] CHECK ([Tipo] IN ('Download', 'Email', 'WebForm', 'Chatbot')),
    CONSTRAINT [CK_BotStatus] CHECK ([Status] IN ('Ativo', 'Inativo', 'Erro'))
);

CREATE INDEX [IX_RPA_Bot_ClienteId] ON [dbo].[RPA_Bot]([ClienteId]);
CREATE INDEX [IX_RPA_Bot_Status] ON [dbo].[RPA_Bot]([Status]);
CREATE INDEX [IX_RPA_Bot_DataCriacao] ON [dbo].[RPA_Bot]([DataCriacao]);

-- Tabela: RPA_BotExecution (Registro de cada execução)
CREATE TABLE [dbo].[RPA_BotExecution](
    [Id] [uniqueidentifier] NOT NULL,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [BotId] [uniqueidentifier] NOT NULL,
    [Status] [nvarchar](20) NOT NULL DEFAULT 'Pendente', -- 'Pendente', 'Executando', 'Sucesso', 'Erro'
    [DataInicio] [datetime2](7) NOT NULL DEFAULT GETUTCDATE(),
    [DataFim] [datetime2](7) NULL,
    [DuracaoSegundos] [int] NULL,
    [MensagemErro] [nvarchar](max) NULL,
    [CodigoErro] [nvarchar](50) NULL, -- 'Timeout', 'AuthFailed', 'NetworkError'
    [TentativaAtual] [int] NOT NULL DEFAULT 1,
    [ResultadoJson] [nvarchar](max) NULL, -- Dados extraídos, por ex: faturas baixadas
    [TriggeredBy] [nvarchar](20) NOT NULL DEFAULT 'Manual', -- 'Manual', 'Scheduled', 'Api'
    [ApprovalId] [uniqueidentifier] NULL, -- Link para aprovação se ação crítica
    CONSTRAINT [PK_RPA_BotExecution] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [FK_RPA_BotExecution_Bot] FOREIGN KEY ([BotId]) REFERENCES [dbo].[RPA_Bot]([Id]),
    CONSTRAINT [FK_RPA_BotExecution_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id]),
    CONSTRAINT [CK_ExecutionStatus] CHECK ([Status] IN ('Pendente', 'Executando', 'Sucesso', 'Erro')),
    CONSTRAINT [CK_ExecutionDuration] CHECK ([DuracaoSegundos] IS NULL OR [DuracaoSegundos] <= 900)
);

CREATE INDEX [IX_RPA_BotExecution_BotId] ON [dbo].[RPA_BotExecution]([BotId]);
CREATE INDEX [IX_RPA_BotExecution_ClienteId] ON [dbo].[RPA_BotExecution]([ClienteId]);
CREATE INDEX [IX_RPA_BotExecution_Status] ON [dbo].[RPA_BotExecution]([Status]);
CREATE INDEX [IX_RPA_BotExecution_DataInicio] ON [dbo].[RPA_BotExecution]([DataInicio]);

-- Tabela: RPA_BotExecutionLog (Logs detalhados de execução)
CREATE TABLE [dbo].[RPA_BotExecutionLog](
    [Id] [uniqueidentifier] NOT NULL,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [ExecutionId] [uniqueidentifier] NOT NULL,
    [Nivel] [nvarchar](20) NOT NULL, -- 'Info', 'Warning', 'Error'
    [Mensagem] [nvarchar](max) NOT NULL,
    [DataCriacao] [datetime2](7) NOT NULL DEFAULT GETUTCDATE(),
    [DataExclusao] [datetime2](7) NULL, -- LGPD: 180 dias
    CONSTRAINT [PK_RPA_BotExecutionLog] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [FK_RPA_Log_Execution] FOREIGN KEY ([ExecutionId]) REFERENCES [dbo].[RPA_BotExecution]([Id]),
    CONSTRAINT [FK_RPA_Log_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id]),
    CONSTRAINT [CK_LogLevel] CHECK ([Nivel] IN ('Info', 'Warning', 'Error')),
    CONSTRAINT [CK_LogRetention] CHECK ([DataExclusao] IS NULL OR [DataExclusao] > DATEADD(DAY, -180, GETUTCDATE()))
);

CREATE INDEX [IX_RPA_BotExecutionLog_ExecutionId] ON [dbo].[RPA_BotExecutionLog]([ExecutionId]);
CREATE INDEX [IX_RPA_BotExecutionLog_DataCriacao] ON [dbo].[RPA_BotExecutionLog]([DataCriacao]) WHERE [DataExclusao] IS NULL;

-- Tabela: Chatbot_Conversation (Histórico de conversas)
CREATE TABLE [dbo].[Chatbot_Conversation](
    [Id] [uniqueidentifier] NOT NULL,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [UserId] [uniqueidentifier] NOT NULL,
    [UserQuery] [nvarchar](max) NOT NULL,
    [ChatbotResponse] [nvarchar](max) NOT NULL,
    [IntentDetected] [nvarchar](100) NULL,
    [ConfidenceScore] [float] NULL, -- 0.0 a 1.0
    [EscaledToHuman] [bit] NOT NULL DEFAULT 0,
    [TicketId] [uniqueidentifier] NULL, -- Link para ticket criado se escalado
    [DataCriacao] [datetime2](7) NOT NULL DEFAULT GETUTCDATE(),
    [DataExclusao] [datetime2](7) NULL,
    CONSTRAINT [PK_Chatbot_Conversation] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [FK_Chatbot_Cliente] FOREIGN KEY ([ClienteId]) REFERENCES [dbo].[Cliente]([Id]),
    CONSTRAINT [FK_Chatbot_User] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Usuario]([Id]),
    CONSTRAINT [CK_ConfidenceScore] CHECK ([ConfidenceScore] IS NULL OR ([ConfidenceScore] >= 0.0 AND [ConfidenceScore] <= 1.0))
);

CREATE INDEX [IX_Chatbot_Conversation_UserId] ON [dbo].[Chatbot_Conversation]([UserId]);
CREATE INDEX [IX_Chatbot_Conversation_ClienteId] ON [dbo].[Chatbot_Conversation]([ClienteId]);
CREATE INDEX [IX_Chatbot_Conversation_DataCriacao] ON [dbo].[Chatbot_Conversation]([DataCriacao]);
CREATE INDEX [IX_Chatbot_Conversation_Escalated] ON [dbo].[Chatbot_Conversation]([EscaledToHuman]) WHERE [EscaledToHuman] = 1;
```

