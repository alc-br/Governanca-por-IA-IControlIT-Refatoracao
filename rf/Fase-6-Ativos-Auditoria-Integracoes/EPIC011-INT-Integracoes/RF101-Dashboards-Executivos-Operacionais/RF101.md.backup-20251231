# RF-101: Dashboards Executivos Operacionais

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF099, RF093, RF094, RF079 | **EPIC**: EPIC011-INT-Integracoes
**Fase**: Fase 6 - Ativos, Auditoria e Integrações

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

O módulo **Dashboards Executivos Operacionais (RF101)** fornece visões estratégicas pré-definidas para executivos C-Level (CEO, CFO, CIO) e gerência sênior. Este requisito especifica a implementação de dashboards especializados que consolidam dados operacionais e financeiros em indicadores visuais de alto nível, permitindo tomada de decisão rápida baseada em dados consolidados.

Diferentemente do RF099 (Dashboards genéricos configuráveis), o RF101 oferece dashboards ESPECÍFICOS com visualizações PRÉ-DEFINIDAS otimizadas para públicos executivos, com dados consolidados em intervalos regulares via jobs agendados, integrações com Machine Learning para forecast, e funcionalidades avançadas de exportação executiva.

O sistema deve ser capaz de consolidar dados de múltiplas fontes (telecom, TI, facilities), calcular indicadores complexos (SLA, Balanced Scorecard), gerar forecasts inteligentes e alertar automaticamente sobre desvios de budget e compliance.

### 1.2 Importância Estratégica

O módulo de Dashboards Executivos é crítico para:

- **Governança Corporativa**: Visibilidade centralizada em compliance, políticas e indicadores de governança (RF079)
- **Controle Financeiro**: Dashboard de custos consolidados por centro de custo, filial e contrato com Budget vs Real e Trending
- **Indicadores de Performance**: Sincronização com RF093 para KPIs operacionais e RF094 para auditoria de custos
- **Cumprimento de SLA**: Integração com RF023 (Contratos), RF028 (SLA Operações) e RF029 (SLA Serviços)
- **Tomada de Decisão**: Forecast com Machine Learning para tendências futuras (3, 6, 12 meses)
- **Auditoria e Conformidade**: Rastreamento completo de quem acessou dados executivos (RF004)
- **Exportação Executiva**: Geração de relatórios PowerPoint e PDF para comunicação externa
- **Performance Operacional**: Heatmap de consumo por filial, indicadores de eficiência e trending

### 1.3 Conceitos Fundamentais

**Dashboard Executivo**: Painel visual consolidado que apresenta indicadores pré-selecionados para público específico (C-Level, Gerência), com dados agregados, históricos e projeções.
- Diferentes de dashboards genéricos: possuem visões temáticas (Custos, Compliance, Performance)
- Dados calculados em batch (Hangfire) para performance
- Acesso restrito por perfil RBAC

**Consolidação de Dados**: Processo batch que agrega dados de múltiplas tabelas transacionais em tabelas de sumarizados (fact tables) para consulta rápida.
- Executado diariamente às 6h da manhã
- Reduz carga de queries OLAP contra dados operacionais
- Armazena histórico para trending

**Forecast com Machine Learning**: Previsão de custos futuros usando Azure ML ou ML.NET baseado em séries históricas de 12+ meses.
- Regressão linear ou ARIMA para trending
- Confiança estatística (R²) para validação
- Atualizado mensalmente com novos dados reais

**Heatmap de Consumo**: Visualização bidimensional (filiais x centros de custo) com escala de cores representando intensidade de consumo (verde < 80%, amarelo 80-100%, vermelho > 100% da meta).
- Permite identificar "hot spots" de despesa rapidamente
- Drill-down para detalhes por filial/CCusto/contrato

**Balanced Scorecard**: Framework estratégico que equilibra 4 perspectivas: Financeira, Clientes, Processos Internos, Aprendizado & Crescimento.
- Cada perspectiva com indicadores e metas
- Sincronizado com RF093 (Indicadores de Performance)

**Budget vs Real**: Comparativo entre orçamento previsto (entrada manual ou sistema integrado) e despesa realizada (RF094).
- Alertas quando variação > 10%
- Breakdown por período (mensal, trimestral)

**SLA Executive View**: Consolidação de SLAs contratuais (RF023) com performance realizada em RF028 e RF029.
- % de atendimento vs meta
- Trending de melhoria/degradação
- Alertas para SLAs em risco

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Visualização** | Crystal Reports estáticos, RefreshAll manual | Gráficos D3.js + Highcharts em tempo real, Power BI Embedded |
| **Consolidação** | Stored Procedures via SQL Agent (SSIS) | Hangfire Jobs + Entity Framework Query |
| **Forecast** | Não existia | Azure ML SDK + ML.NET (ARIMA, LinearRegression) |
| **Acesso Executivo** | Sem rastreamento, relatórios por email | RBAC centralizado, auditoria de acesso (RF004) |
| **Multi-tenancy** | Tabela compartilhada com filtro manual | ClienteId em todas queries, isolamento garantido |
| **Export** | PDF via Crystal Reports | PowerPoint (Open XML) + PDF (iText) |
| **Performance** | Queries lentas contra tabelas OLTP | Fact tables + Dimensional model consolidado |
| **Feature Flags** | Todas features hardcoded | Central de Funcionalidades (RF001) |
| **i18n** | Sem suporte | 16 chaves obrigatórias em múltiplos idiomas |

### 1.5 Funcionalidades Principais

1. **Dashboard C-Level** - Visão estratégica em 4 KPIs principais (Receita, Custos, Compliance, SLA)
2. **Dashboard de Custos** - Consolidação de custos por contrato, filial, centro de custo com trending
3. **Dashboard de Compliance** - Status de políticas (RF079), conformidade LGPD, conformidade regulatória
4. **Dashboard de Performance** - Indicadores operacionais (RF093) com heatmap de eficiência
5. **Indicadores de SLA** - % de atendimento vs meta (RF028, RF029, RF023)
6. **Heatmap de Consumo** - Matriz filial x centro de custo com escala de cores
7. **Trending de Custos** - Gráficos de linha com histórico (3, 6, 12 meses) e variação %
8. **Forecast com ML** - Previsão de custos futuros com intervalo de confiança
9. **Budget vs Real** - Comparativo com alertas quando variação > 10%
10. **Balanced Scorecard** - Framework de 4 perspectivas com indicadores balanceados
11. **Export Executivo** - PowerPoint, PDF e agendamento de relatórios recorrentes
12. **Drill-Down Detalhado** - Navegação de KPI agregado para dados granulares
13. **Sincronização DevOps** - Integração com Azure DevOps via RF079

---

## 2. REGRAS DE NEGÓCIO

### RN-DSH-101-01: Controle de Acesso Restrito a Executivos

**Descrição**: Apenas usuários com perfis C-Level, Diretoria, Gerência Sênior e Analista Executivo podem acessar dashboards executivos. Tentativas de acesso por usuários sem permissão devem retornar HTTP 403 Forbidden com auditoria.

**Justificativa**: Dados consolidados de custos, compliance e SLA são estratégicos e confidenciais. Exposição não autorizada viola princípios de governança corporativa e confidencialidade.

**Implementação**:
```csharp
[Authorize(Roles = "Diretoria,Gerencia,AnalistaExecutivo,CEO,CFO,CIO")]
[HttpGet("/api/dashboards/executivo/{tipo}")]
public async Task<IActionResult> GetExecutiveDashboard(
    string tipo,
    [FromServices] IAuthorizationService authService,
    [FromServices] IAuditService auditService,
    CancellationToken cancellationToken)
{
    var user = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var clienteId = User.FindFirst("ClienteId")?.Value;

    // Validar acesso
    var hasAccess = await authService.AuthorizeAsync(User, "executivo:dashboard:view");
    if (!hasAccess.Succeeded)
    {
        // Auditar tentativa não autorizada
        await auditService.LogAsync(new AuditEntry
        {
            UserId = user,
            ClienteId = clienteId,
            Acao = "DSH_DASHBOARD_UNAUTHORIZED_ACCESS",
            Recurso = $"Dashboard_{tipo}",
            DataAcesso = DateTime.UtcNow,
            IpOrigem = HttpContext.Connection.RemoteIpAddress?.ToString()
        });

        return Forbid();
    }

    // Retornar dashboard
    return Ok(await GetDashboardAsync(tipo, clienteId, cancellationToken));
}
```

**Exemplos**:
- CEO acessa Dashboard C-Level: Permitido
- Operador de Service Desk tenta acessar: Bloqueado (403 + Auditado)
- Gerente de Filial acessa Dashboard de Custos da filial: Permitido (com filtro ClienteId)

---

### RN-DSH-101-02: Consolidação Diária de Dados via Hangfire

**Descrição**: Dados agregados devem ser consolidados automaticamente via Hangfire job executado diariamente às 6:00 AM UTC. O job deve ser idempotente (seguro executar múltiplas vezes no mesmo dia) e registrar sucesso/falha em tabela de logs.

**Justificativa**: Queries contra dados operacionais em alta granularidade são custosas. Pré-calcular agregações permite dashboards rápidos mesmo com volume grande de dados. Execução em horário baixo (madrugada) minimiza impacto operacional.

**Implementacao**:
```csharp
public class DashboardConsolidationJob
{
    private readonly IRepository<FatoDashboard> _fatoRepository;
    private readonly IRepository<FactoUsuario> _usuarioRepository;
    private readonly ILogger<DashboardConsolidationJob> _logger;

    public async Task ExecutarConsolidacaoAsync(CancellationToken ct)
    {
        var dataExecutacao = DateTime.UtcNow.Date;
        var logEntrada = DateTime.UtcNow;

        try
        {
            _logger.LogInformation("Iniciando consolidação diária às {hora}", logEntrada);

            // Passo 1: Consolidar custos por filial/centro de custo
            await ConsolidarCustosAsync(dataExecutacao, ct);

            // Passo 2: Consolidar SLAs (atual vs meta)
            await ConsolidarSLAsAsync(dataExecutacao, ct);

            // Passo 3: Consolidar indicadores de compliance
            await ConsolidarComplianceAsync(dataExecutacao, ct);

            // Passo 4: Consolidar performance operacional
            await ConsolidarPerformanceAsync(dataExecutacao, ct);

            _logger.LogInformation("Consolidação concluída com sucesso");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Falha na consolidação diária");
            throw;
        }
    }

    private async Task ConsolidarCustosAsync(DateTime data, CancellationToken ct)
    {
        // Agregação de custos por ContatoId x FilialId x CentroCustoId
        // INSERT INTO FatoDashboard_Custos (ClienteId, ContratoId, FilialId, ...
    }
}

// Configuração em Startup
public void ConfigureServices(IServiceCollection services)
{
    services.AddHangfire(config => config
        .SetDataCompatibilityLevel(CompatibilityLevel.Version_170)
        .UseSimpleAssemblyNameTypeSerializer()
        .UseRecommendedSerializerSettings()
        .UseSqlServerStorage(Configuration.GetConnectionString("Hangfire")));

    RecurringJob.AddOrUpdate<DashboardConsolidationJob>(
        "dashboard-consolidacao-diaria",
        job => job.ExecutarConsolidacaoAsync(CancellationToken.None),
        Cron.Daily(6, 0),
        new RecurringJobOptions { TimeZone = TimeZoneInfo.Utc });
}
```

**Exemplos**:
- 2025-12-28 06:00 UTC: Job executa e consolida dados de 2025-12-27
- 2025-12-28 06:15 UTC: Re-execução não causa duplicação (idempotente)
- Falha na consolidação: Log registrado, alerta enviado, retry automático

---

### RN-DSH-101-03: Forecast Baseado em Série Histórica de 12+ Meses

**Descrição**: Previsões de custos futuros devem ser calculadas usando mínimo 12 meses de histórico. O modelo estatístico deve ser ARIMA ou Regressão Linear com R² mínimo de 0.85 para válido. Dados insuficientes (< 12 meses) devem retornar indicador de confiança baixa mas sem bloquear visualização.

**Justificativa**: Previsões com poucos dados são imprecisas e enganosas. 12 meses captura sazonalidade (trimestral, semestral). R² mínimo garante que modelo explica 85% da variância, reduzindo erro de predição.

**Implementação**:
```csharp
public class ForecastService
{
    private readonly IRepository<FatoDashboard_Custos> _custoRepository;

    public async Task<ForecastResult> GerarForecastAsync(
        string clienteId,
        string contratoId,
        int mesesFuturos = 6,
        CancellationToken ct = default)
    {
        // Buscar série histórica últimos 12+ meses
        var agora = DateTime.UtcNow;
        var dataInicio = agora.AddMonths(-13);

        var dados = await _custoRepository
            .Where(x => x.ClienteId == clienteId
                && x.ContratoId == contratoId
                && x.DataConsolidacao >= dataInicio)
            .OrderBy(x => x.DataConsolidacao)
            .Select(x => new { x.DataConsolidacao, x.ValorTotal })
            .ToListAsync(ct);

        if (dados.Count < 12)
        {
            return new ForecastResult
            {
                IsValido = false,
                MotivoInvalido = "Histórico insuficiente (< 12 meses)",
                ConfiancaPercentual = 0,
                Previsoes = null
            };
        }

        // Treinar modelo ARIMA
        var mlContext = new MLContext();
        var dataFrame = dados.Select(x => new CustoData
        {
            ValorTotal = (float)x.ValorTotal,
            Index = (float)dados.IndexOf(x)
        }).ToList();

        var pipeline = mlContext.Forecasting.ForecastBySsa(
            outputColumnName: "ForecastedValue",
            inputColumnName: nameof(CustoData.ValorTotal),
            windowSize: 12,
            seriesLength: dados.Count,
            trainSize: dados.Count,
            horizon: mesesFuturos);

        var model = pipeline.Fit(mlContext.Data.LoadFromEnumerable(dataFrame));

        // Calcular R² para validação
        var rSquared = CalcularRSquared(dados, model);

        return new ForecastResult
        {
            IsValido = rSquared >= 0.85m,
            ConfiancaPercentual = (int)(rSquared * 100),
            RSquared = rSquared,
            Previsoes = previsoes,
            DataGeracao = DateTime.UtcNow,
            ProximaAtualizacao = DateTime.UtcNow.AddMonths(1)
        };
    }
}

public class ForecastResult
{
    public bool IsValido { get; set; }
    public string MotivoInvalido { get; set; }
    public decimal ConfiancaPercentual { get; set; }
    public decimal RSquared { get; set; }
    public List<PrevisaoMensal> Previsoes { get; set; }
    public DateTime DataGeracao { get; set; }
    public DateTime ProximaAtualizacao { get; set; }
}

public class PrevisaoMensal
{
    public DateTime Mes { get; set; }
    public decimal ValorForecast { get; set; }
    public decimal IntervaloConfiantaMais95 { get; set; }
    public decimal IntervaloConfiantaMenos95 { get; set; }
}
```

**Exemplos**:
- Contrato com 14 meses de histórico: Forecast válido, R² = 0.92
- Contrato novo com 8 meses: Forecast inválido, confiança 0%, dados mostrados com aviso
- Forecast para 6 meses: CEO visualiza projeção com intervalo de confiança 95%

---

### RN-DSH-101-04: Budget vs Real com Alertas quando Variação > 10%

**Descrição**: Ao visualizar comparativo Budget vs Real, o sistema deve calcular variação percentual ((Real - Budget) / Budget). Quando variação > 10% (positivo ou negativo), alerta visual (amarelo) deve ser exibido. Quando variação > 20%, alerta crítico (vermelho). Variações são calculadas por período (mensal, trimestral, anual).

**Justificativa**: Desvios de budget acima de 10% indicam planejamento inadequado ou mudanças operacionais. Alertas automáticos permitem gerentes reagirem rapidamente antes que impacto financeiro se acumule.

**Implementação**:
```csharp
public class BudgetVsRealService
{
    public decimal CalcularVariacaoPercentual(decimal budget, decimal real)
    {
        if (budget == 0) return real > 0 ? 100 : 0;
        return ((real - budget) / budget) * 100;
    }

    public AlertNivel EvaluarAlerta(decimal variacao)
    {
        var absVariacao = Math.Abs(variacao);

        if (absVariacao <= 10) return AlertNivel.Normal;
        if (absVariacao <= 20) return AlertNivel.Aviso;
        return AlertNivel.Critico;
    }

    public async Task<BudgetVsRealDto> GetBudgetVsRealAsync(
        string clienteId,
        int ano,
        int? mes = null,
        CancellationToken ct = default)
    {
        var periodo = mes.HasValue
            ? $"{ano}-{mes:00}"
            : $"{ano}";

        var budget = await _budgetRepository
            .Where(x => x.ClienteId == clienteId && x.Periodo == periodo)
            .SumAsync(x => x.Valor, ct);

        var real = await _custoRepository
            .Where(x => x.ClienteId == clienteId && x.Periodo == periodo)
            .SumAsync(x => x.Valor, ct);

        var variacao = CalcularVariacaoPercentual(budget, real);
        var alerta = EvaluarAlerta(variacao);

        return new BudgetVsRealDto
        {
            Periodo = periodo,
            Budget = budget,
            Real = real,
            Variacao = variacao,
            VariacaoFormatada = $"{variacao:+0.00;-0.00;0.00}%",
            Alerta = alerta,
            CorAlerta = alerta == AlertNivel.Critico ? "#FF0000" :
                        alerta == AlertNivel.Aviso ? "#FFC107" : "#4CAF50",
            MensagemAlerta = alerta switch
            {
                AlertNivel.Normal => "Conforme orçado",
                AlertNivel.Aviso => $"Desvio de {Math.Abs(variacao):F1}% - Revisar próximo mês",
                AlertNivel.Critico => $"CRÍTICO: Desvio de {Math.Abs(variacao):F1}% - Ação necessária",
                _ => ""
            }
        };
    }
}

public enum AlertNivel { Normal, Aviso, Critico }
```

**Exemplos**:
- Budget R$ 100k, Real R$ 103k: Variação +3%, Normal (verde)
- Budget R$ 100k, Real R$ 112k: Variação +12%, Aviso (amarelo)
- Budget R$ 100k, Real R$ 125k: Variação +25%, Crítico (vermelho)

---

### RN-DSH-101-05: Heatmap com Escala de Cores (Verde < 80%, Amarelo 80-100%, Vermelho > 100%)

**Descrição**: Heatmap de consumo por filial x centro de custo deve usar escala de cores para representar intensidade. Verde quando consumo < 80% da meta, amarelo quando 80-100% da meta, vermelho quando > 100%. Cores devem ser acessíveis (WCAG AA) e metadados de célula devem incluir valor absoluto, % da meta e trending.

**Justificativa**: Visualização por cores permite identificação rápida de "hot spots" de despesa. Escala com 3 faixas é limite cognitivo para discernimento rápido. Acessibilidade garante inclusão de usuários com daltonismo.

**Implementação**:
```csharp
public class HeatmapService
{
    public HeatmapCell CalcularCelula(
        string filialId,
        string centroCustoId,
        decimal consumoReal,
        decimal metaMensal)
    {
        if (metaMensal == 0)
            return new HeatmapCell { Status = HeatmapStatus.Indefinido };

        var percentualMeta = (consumoReal / metaMensal) * 100;
        var status = percentualMeta switch
        {
            < 80 => HeatmapStatus.Otimo,        // Verde #4CAF50
            <= 100 => HeatmapStatus.Aceitavel,  // Amarelo #FFC107
            _ => HeatmapStatus.Critico           // Vermelho #F44336
        };

        var trending = await CalcularTrendingAsync(filialId, centroCustoId);

        return new HeatmapCell
        {
            FilialId = filialId,
            CentroCustoId = centroCustoId,
            ConsumoReal = consumoReal,
            MetaMensal = metaMensal,
            PercentualMeta = percentualMeta,
            Status = status,
            CorHex = status switch
            {
                HeatmapStatus.Otimo => "#4CAF50",
                HeatmapStatus.Aceitavel => "#FFC107",
                HeatmapStatus.Critico => "#F44336",
                _ => "#999999"
            },
            TrendingMeses = trending, // [+5%, +2%, -1%, ...]
            TextoAlternativo = $"{filialId}/{centroCustoId}: {percentualMeta:F1}% ({consumoReal:C})"
        };
    }

    public async Task<HeatmapGrid> GerarHeatmapAsync(
        string clienteId,
        int mes,
        int ano,
        CancellationToken ct = default)
    {
        var filiais = await _filialRepository
            .Where(x => x.ClienteId == clienteId && x.Ativo)
            .ToListAsync(ct);

        var centrosCusto = await _cCustoRepository
            .Where(x => x.ClienteId == clienteId && x.Ativo)
            .ToListAsync(ct);

        var grid = new HeatmapGrid();

        foreach (var filial in filiais)
        {
            var linha = new HeatmapLinha { FilialId = filial.Id, FilialNome = filial.Nome };

            foreach (var ccusto in centrosCusto)
            {
                var consumo = await _custoRepository
                    .Where(x => x.ClienteId == clienteId
                        && x.FilialId == filial.Id
                        && x.CentroCustoId == ccusto.Id
                        && x.Mes == mes && x.Ano == ano)
                    .SumAsync(x => x.Valor, ct);

                var celula = CalcularCelula(filial.Id, ccusto.Id, consumo, ccusto.MetaMensal);
                linha.Celulas.Add(celula);
            }

            grid.Linhas.Add(linha);
        }

        return grid;
    }
}

public enum HeatmapStatus { Otimo, Aceitavel, Critico, Indefinido }
```

**Exemplos**:
- Filial SP / CCusto TI: Consumo R$ 80k, Meta R$ 100k, 80% → Amarelo
- Filial MG / CCusto Telecom: Consumo R$ 50k, Meta R$ 100k, 50% → Verde
- Filial RJ / CCusto Facilities: Consumo R$ 120k, Meta R$ 100k, 120% → Vermelho

---

### RN-DSH-101-06: Trending com Suporte a Múltiplas Granularidades

**Descrição**: Gráfico de trending deve permitir visualização em granularidades: diária (últimos 30 dias), semanal (últimas 13 semanas), mensal (últimos 12 meses). Cada granularidade deve agregar dados apropriadamente. Linha de tendência deve ser calculada via regressão linear. Variação percentual período-a-período deve ser exibida.

**Justificativa**: Diferentes públicos analisam dados em diferentes granularidades. CEO vê tendência mensal; operador vê diária. Regressão linear mostra direção clara (subindo/descendo) independente de flutuações.

**Implementação**:
```csharp
public class TrendingService
{
    public async Task<TrendingData> GetTrendingAsync(
        string clienteId,
        string contratoId,
        TrendingGranularidade granularidade,
        CancellationToken ct = default)
    {
        var dataFim = DateTime.UtcNow.Date;
        var dataInicio = granularidade switch
        {
            TrendingGranularidade.Diaria => dataFim.AddDays(-30),
            TrendingGranularidade.Semanal => dataFim.AddWeeks(-13),
            TrendingGranularidade.Mensal => dataFim.AddMonths(-12),
            _ => throw new ArgumentException(nameof(granularidade))
        };

        var dados = await _custoRepository
            .Where(x => x.ClienteId == clienteId
                && x.ContratoId == contratoId
                && x.DataConsolidacao >= dataInicio
                && x.DataConsolidacao <= dataFim)
            .OrderBy(x => x.DataConsolidacao)
            .ToListAsync(ct);

        // Agregar por granularidade
        var agregados = AgregarPorGranularidade(dados, granularidade);

        // Calcular regressão linear
        var regressao = CalcularRegressao(agregados);

        // Calcular variações
        var variacoes = CalcularVariacoes(agregados);

        return new TrendingData
        {
            Granularidade = granularidade,
            Pontos = agregados.Select(x => new TrendingPonto
            {
                Periodo = x.Key,
                Valor = x.Value,
                VariacaoPercentual = variacoes.ContainsKey(x.Key) ? variacoes[x.Key] : 0
            }).ToList(),
            Regressao = new LinhaRegressao
            {
                Inclinacao = regressao.Slope,
                Intersecao = regressao.Intercept,
                Direcao = regressao.Slope > 0 ? "Subindo" : "Descendo",
                Angulo = Math.Atan(regressao.Slope) * (180 / Math.PI)
            },
            Resumo = new TrendingResumo
            {
                ValorInicio = agregados.First().Value,
                ValorFim = agregados.Last().Value,
                VariacaoTotal = ((agregados.Last().Value - agregados.First().Value)
                    / agregados.First().Value) * 100,
                ValorMedio = agregados.Values.Average(),
                ValorMaximo = agregados.Values.Max(),
                ValorMinimo = agregados.Values.Min()
            }
        };
    }

    private Dictionary<string, decimal> AgregarPorGranularidade(
        List<CustoData> dados,
        TrendingGranularidade granularidade)
    {
        return granularidade switch
        {
            TrendingGranularidade.Diaria => dados
                .GroupBy(x => x.DataConsolidacao.ToString("yyyy-MM-dd"))
                .OrderBy(g => g.Key)
                .ToDictionary(g => g.Key, g => g.Sum(x => x.Valor)),

            TrendingGranularidade.Semanal => dados
                .GroupBy(x => ISOWeek.GetWeekOfYear(x.DataConsolidacao).ToString("yyyy-Www"))
                .OrderBy(g => g.Key)
                .ToDictionary(g => g.Key, g => g.Sum(x => x.Valor)),

            TrendingGranularidade.Mensal => dados
                .GroupBy(x => x.DataConsolidacao.ToString("yyyy-MM"))
                .OrderBy(g => g.Key)
                .ToDictionary(g => g.Key, g => g.Sum(x => x.Valor)),

            _ => throw new ArgumentException(nameof(granularidade))
        };
    }

    private LinearRegression CalcularRegressao(Dictionary<string, decimal> dados)
    {
        var pontos = dados.Values.Select((v, i) => (x: (double)i, y: (double)v)).ToList();
        var xMedio = pontos.Average(p => p.x);
        var yMedio = pontos.Average(p => p.y);

        var numerador = pontos.Sum(p => (p.x - xMedio) * (p.y - yMedio));
        var denominador = pontos.Sum(p => Math.Pow(p.x - xMedio, 2));

        var slope = denominador == 0 ? 0 : numerador / denominador;
        var intercept = yMedio - slope * xMedio;

        return new LinearRegression { Slope = slope, Intercept = intercept };
    }
}

public enum TrendingGranularidade { Diaria, Semanal, Mensal }
```

**Exemplos**:
- Trending diária: Últimos 30 dias com pontos por dia, regressão mostra tendência semanal
- Trending mensal: 12 meses com linha crescente (slope +5%), variação +3% a +7% mês-a-mês
- Trending semanal: 13 semanas com padrão cíclico (picos nas semanas 2, 6, 10)

---

### RN-DSH-101-07: SLA com % de Atendimento vs Meta Contratual

**Descrição**: Indicador de SLA deve mostrar percentual de atendimento comparado com meta contratual. Cálculo: (Quantidade Atendida / Quantidade Esperada) * 100. Meta contratual vem de RF023 (Contratos). Dado realizado consolidado via Hangfire diariamente. Verde quando >= meta, amarelo quando 95-99% da meta, vermelho quando < 95% da meta.

**Justificativa**: SLA é contrato com cliente. Execução inadequada gera multas contratuais (RF035) e dano reputacional. Dashboard executivo fornece visão rápida de cumprimento com alertas.

**Implementação**:
```csharp
public class SLAExecutivoService
{
    public async Task<SLAIndicadorDto> GetSLAIndicadorAsync(
        string clienteId,
        string contratoId,
        int? mes = null,
        int? ano = null,
        CancellationToken ct = default)
    {
        var dataReferencia = mes.HasValue && ano.HasValue
            ? new DateTime(ano.Value, mes.Value, 1)
            : DateTime.UtcNow.Date;

        // Buscar meta contratual (RF023)
        var contrato = await _contratoRepository
            .Include(x => x.SLAs)
            .FirstOrDefaultAsync(x => x.ClienteId == clienteId && x.Id == contratoId, ct);

        if (contrato == null)
            throw new DomainException("Contrato não encontrado");

        // Buscar performance realizada (RF028 - Operações, RF029 - Serviços)
        var atendimentos = await _atendimentoRepository
            .Where(x => x.ClienteId == clienteId
                && x.ContratoId == contratoId
                && x.DataAtendimento.Year == dataReferencia.Year
                && x.DataAtendimento.Month == dataReferencia.Month
                && x.Status == StatusAtendimento.Concluido)
            .ToListAsync(ct);

        var esperado = await _expectativaRepository
            .Where(x => x.ClienteId == clienteId
                && x.ContratoId == contratoId
                && x.Data.Year == dataReferencia.Year
                && x.Data.Month == dataReferencia.Month)
            .SumAsync(x => x.Quantidade, ct);

        var atendido = atendimentos.Count;
        var percentualAtendimento = esperado == 0 ? 100 : (atendido / (decimal)esperado) * 100;
        var metaContratual = contrato.SLAs.FirstOrDefault()?.MetaPercentual ?? 95;

        var status = percentualAtendimento switch
        {
            >= metaContratual => SLAStatus.Atendido,
            >= metaContratual * 0.95m => SLAStatus.Aviso,
            _ => SLAStatus.NaoAtendido
        };

        return new SLAIndicadorDto
        {
            ContratoId = contratoId,
            Periodo = dataReferencia.ToString("yyyy-MM"),
            MetaPercentual = metaContratual,
            PercentualAtendimento = percentualAtendimento,
            PercentualFormatado = $"{percentualAtendimento:F2}%",
            Atendido = atendido,
            Esperado = esperado,
            Diferenca = esperado - atendido,
            Status = status,
            CorStatus = status switch
            {
                SLAStatus.Atendido => "#4CAF50",
                SLAStatus.Aviso => "#FFC107",
                SLAStatus.NaoAtendido => "#F44336",
                _ => "#999999"
            },
            MensagemStatus = status switch
            {
                SLAStatus.Atendido => $"SLA atendido: {percentualAtendimento:F2}% >= {metaContratual}%",
                SLAStatus.Aviso => $"SLA em risco: {percentualAtendimento:F2}% < {metaContratual}% (diferença: {esperado - atendido})",
                SLAStatus.NaoAtendido => $"SLA NÃO ATENDIDO: {percentualAtendimento:F2}% << {metaContratual}% (diferença: {esperado - atendido})",
                _ => ""
            }
        };
    }
}

public enum SLAStatus { Atendido, Aviso, NaoAtendido }
```

**Exemplos**:
- Meta: 95%, Realizado: 96% → Atendido (verde)
- Meta: 95%, Realizado: 93% → Aviso (amarelo)
- Meta: 95%, Realizado: 90% → Não Atendido (vermelho)

---

### RN-DSH-101-08: Integração com Compliance (RF079 - Políticas)

**Descrição**: Dashboard de Compliance deve integrar status de políticas de RF079. Para cada política vinculada ao contrato, exibir: título, data última atualização, status de conformidade (Conforme/Não Conforme/Pendente), % de cobertura em filiais/usuários. Deve haver drill-down para detalhes de conformidade por filial.

**Justificativa**: Governança corporativa exige visibilidade de conformidade com políticas. Dashboard permite CEO/Diretor visualizar rapidamente quais políticas estão out-of-compliance e planejar remediação.

**Implementação**:
```csharp
public class ComplianceExecutivoService
{
    public async Task<ComplianceDashboardDto> GetComplianceDashboardAsync(
        string clienteId,
        CancellationToken ct = default)
    {
        // Buscar todas políticas ativas (RF079)
        var politicas = await _politicaRepository
            .Where(x => x.ClienteId == clienteId && x.Ativo)
            .Include(x => x.Conformidades)
            .ToListAsync(ct);

        var dashboard = new ComplianceDashboardDto();

        foreach (var politica in politicas)
        {
            var filiais = await _filialRepository
                .Where(x => x.ClienteId == clienteId && x.Ativo)
                .Select(x => x.Id)
                .ToListAsync(ct);

            var conformidades = await _conformidadeRepository
                .Where(x => x.ClienteId == clienteId
                    && x.PoliticaId == politica.Id)
                .ToListAsync(ct);

            var cobertura = (conformidades.Count / (decimal)filiais.Count) * 100;
            var naoConformes = conformidades.Count(x => x.Status == StatusConformidade.NaoConforme);

            var indicador = new ComplianceIndicador
            {
                PoliticaId = politica.Id,
                TituloPolitica = politica.Titulo,
                DataUltimaAtualizacao = politica.DataUltimaAtualizacao,
                StatusGeral = naoConformes == 0 ? ComplianceStatus.Conforme :
                             cobertura >= 80 ? ComplianceStatus.PartialmenteCon forme :
                             ComplianceStatus.NaoConforme,
                PercentualCobertura = cobertura,
                TotalFiliais = filiais.Count,
                FiliaisConformes = conformidades.Count(x => x.Status == StatusConformidade.Conforme),
                FiliaisNaoConformes = naoConformes,
                FiliaisPendentes = conformidades.Count(x => x.Status == StatusConformidade.Pendente),
                CorStatus = naoConformes == 0 ? "#4CAF50" : cobertura >= 80 ? "#FFC107" : "#F44336"
            };

            dashboard.Indicadores.Add(indicador);
        }

        // Consolidar: % geral de conformidade
        dashboard.PercentualConformidadeGeral = dashboard.Indicadores.Any()
            ? dashboard.Indicadores.Average(x => x.PercentualCobertura)
            : 100;

        dashboard.TotalPoliticas = dashboard.Indicadores.Count;
        dashboard.PoliticasConformes = dashboard.Indicadores.Count(x => x.StatusGeral == ComplianceStatus.Conforme);
        dashboard.PoliticasNaoConformes = dashboard.Indicadores.Count(x => x.StatusGeral == ComplianceStatus.NaoConforme);

        return dashboard;
    }
}

public enum ComplianceStatus { Conforme, ParcialmenteCon forme, NaoConforme }
```

**Exemplos**:
- Política "Senha Forte": 95% cobertura, Conforme → Verde
- Política "2FA Obrigatório": 75% cobertura, Parcialmente → Amarelo
- Política "Backup Diário": 40% cobertura, Não Conforme → Vermelho

---

### RN-DSH-101-09: Export Executivo em PowerPoint com Gráficos

**Descrição**: Funcionalidade POST /api/dashboards/executivo/export/pptx deve gerar arquivo PowerPoint (.pptx) contendo: 1) Capa com data/executado por, 2) Sumário executivo (KPIs principais), 3) Dashboard C-Level com gráficos, 4) Dashboard de Custos, 5) SLA e Compliance, 6) Análises e Recomendações. Gráficos devem ser renderizados como imagens embutidas (PNGs). Arquivo gerado deve estar disponível para download por 7 dias.

**Justificativa**: Executivos frequentemente compartilham insights em reuniões/boards onde acesso a sistema não é possível. PowerPoint é formato universal. Renderização de gráficos como imagens garante fidelidade visual independente de software.

**Implementação**:
```csharp
[HttpPost("/api/dashboards/executivo/export/pptx")]
[Authorize(Roles = "Diretoria,CEO,CFO,CIO")]
public async Task<IActionResult> ExportarPowerPointAsync(
    [FromBody] ExportRequest request,
    [FromServices] IPowerPointService ppService,
    [FromServices] IAuditService auditService,
    CancellationToken ct)
{
    var user = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var clienteId = User.FindFirst("ClienteId")?.Value;

    // Auditar geração do relatório
    await auditService.LogAsync(new AuditEntry
    {
        UserId = user,
        ClienteId = clienteId,
        Acao = "DSH_EXPORT_POWERPOINT",
        Recurso = "Dashboard Executivo",
        DataAcesso = DateTime.UtcNow
    });

    // Coletar dados para o report
    var clevel = await GetDashboardCLevelAsync(clienteId, ct);
    var custos = await GetDashboardCustosAsync(clienteId, ct);
    var compliance = await GetComplianceDashboardAsync(clienteId, ct);
    var sla = await GetSLADashboardAsync(clienteId, ct);

    // Gerar PowerPoint
    var pptxBytes = await ppService.GerarRelatorioExecutivoAsync(new RelatorioDados
    {
        DadosCLevel = clevel,
        DadosCustos = custos,
        DadosCompliance = compliance,
        DadosSLA = sla,
        DataGeracao = DateTime.UtcNow,
        UsuarioGerador = user,
        NomeEmpresa = await GetNomeEmpresaAsync(clienteId, ct)
    }, ct);

    // Salvar em storage (Azure Blob)
    var nomeArquivo = $"relatorio_executivo_{clienteId}_{DateTime.UtcNow:yyyyMMdd_HHmmss}.pptx";
    var urlDownload = await _blobService.UploadAsync(
        container: "relatorios-executivos",
        blob: nomeArquivo,
        data: pptxBytes,
        expiracaoDias: 7);

    return Ok(new ExportResponse
    {
        UrlDownload = urlDownload,
        NomeArquivo = nomeArquivo,
        DataGeracao = DateTime.UtcNow,
        ExpiracaoEm = DateTime.UtcNow.AddDays(7),
        Tamanho = pptxBytes.Length
    });
}

public class PowerPointService : IPowerPointService
{
    public async Task<byte[]> GerarRelatorioExecutivoAsync(RelatorioDados dados, CancellationToken ct)
    {
        using var presentation = new PresentationDocument();
        var presentationPart = presentation.AddPresentationPart();
        presentationPart.Presentation = new Presentation();

        var slides = presentationPart.Presentation.SlideList ??= new SlideList();

        // Slide 1: Capa
        await AdicionarCapaAsync(slides, dados, ct);

        // Slide 2: Sumário Executivo
        await AdicionarSumarioAsync(slides, dados, ct);

        // Slide 3: Dashboard C-Level
        await AdicionarDashboardCLevelAsync(slides, dados.DadosCLevel, ct);

        // Slide 4: Dashboard Custos
        await AdicionarDashboardCustosAsync(slides, dados.DadosCustos, ct);

        // Slide 5: SLA e Compliance
        await AdicionarSLAComplianceAsync(slides, dados.DadosSLA, dados.DadosCompliance, ct);

        // Slide 6: Recomendações
        await AdicionarRecomendacoesAsync(slides, dados, ct);

        var ms = new MemoryStream();
        presentation.SaveAs(ms);
        return ms.ToArray();
    }

    private async Task AdicionarCapaAsync(SlideList slides, RelatorioDados dados, CancellationToken ct)
    {
        var slide = new Slide();
        var layout = new SlideLayout();

        // Adicionar título
        AddTextShape(slide, "RELATÓRIO EXECUTIVO", x: 0.5, y: 2, fontSize: 54, bold: true);

        // Adicionar informações
        AddTextShape(slide, $"Gerado em: {dados.DataGeracao:dd/MM/yyyy HH:mm}", x: 0.5, y: 4);
        AddTextShape(slide, $"Por: {dados.UsuarioGerador}", x: 0.5, y: 4.5);
        AddTextShape(slide, $"Empresa: {dados.NomeEmpresa}", x: 0.5, y: 5);

        slides.AppendChild(slide);
    }
}
```

**Exemplos**:
- CEO gera report para board: Arquivo criado em 2 segundos, 15 MB, disponível por 7 dias
- CFO compartilha em email: Gráficos embutidos renderizam perfeitamente em PowerPoint desktop
- Auditoria: Log registra quem, quando e para qual período foi exportado

---

### RN-DSH-101-10: Auditoria Obrigatória de Acesso a Dashboards Executivos

**Descrição**: Toda tentativa de acesso a dashboard executivo deve ser auditada em tabela AuditLog (RF004) com: UserId, ClienteId, DashboardTipo, DataAcesso, IpOrigem, UserAgent. Tentativas não autorizadas devem ser registradas com flag "Unauthorized". Logs devem ser retidos por 5 anos (LGPD).

**Justificativa**: Dados executivos são estratégicos. Auditoria fornece evidência de quem acessou dados sensíveis e quando. Essencial para conformidade regulatória (Lei Geral de Proteção de Dados).

**Implementação**:
```csharp
[Authorize(Roles = "Diretoria,CEO,CFO,CIO")]
[HttpGet("/api/dashboards/executivo/{tipo}")]
public async Task<IActionResult> GetExecutiveDashboard(
    string tipo,
    [FromServices] IAuditService auditService,
    CancellationToken ct)
{
    var user = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var clienteId = User.FindFirst("ClienteId")?.Value;
    var userEmail = User.FindFirst(ClaimTypes.Email)?.Value;

    var entry = new AuditEntry
    {
        Id = Guid.NewGuid(),
        UserId = user,
        ClienteId = clienteId,
        Acao = "DSH_DASHBOARD_ACESSO",
        Recurso = $"Dashboard_{tipo}",
        DataAcesso = DateTime.UtcNow,
        IpOrigem = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        UserAgent = HttpContext.Request.Headers["User-Agent"].ToString(),
        Sucesso = true
    };

    try
    {
        var dashboard = await _dashboardService.GetDashboardAsync(tipo, clienteId, ct);
        await auditService.LogAsync(entry);
        return Ok(dashboard);
    }
    catch (UnauthorizedAccessException)
    {
        entry.Sucesso = false;
        entry.Descricao = "Acesso não autorizado";
        await auditService.LogAsync(entry);
        return Forbid();
    }
}

public class AuditService : IAuditService
{
    public async Task LogAsync(AuditEntry entry)
    {
        // Adicionar metadados LGPD
        entry.DataRetencao = DateTime.UtcNow.AddYears(5); // 5 anos conforme LGPD

        // Criptografar dados sensíveis se necessário
        if (!string.IsNullOrEmpty(entry.IpOrigem))
            entry.IpOrigemCriptografado = _criptografia.Criptografar(entry.IpOrigem);

        await _auditRepository.AddAsync(entry);
        await _unitOfWork.SaveChangesAsync();

        // Log estruturado para auditoria
        _logger.LogInformation(
            "Acesso a Dashboard Executivo | User: {UserId} | Dashboard: {Dashboard} | IP: {IP}",
            entry.UserId, entry.Recurso, entry.IpOrigem);
    }
}

// Adicionar política de retenção LGPD
public class LGPDRetentionPolicy
{
    public static readonly Dictionary<string, int> RetencaoPorTipo = new()
    {
        { "DSH_DASHBOARD_ACESSO", 5 * 12 }, // 5 anos em meses
        { "DSH_EXPORT_POWERPOINT", 2 * 12 }, // 2 anos
        { "DSH_CONSOLIDACAO_FALHA", 1 * 12 } // 1 ano
    };
}
```

**Exemplos**:
- CEO acessa Dashboard C-Level: Auditado com IP, timestamp, UserAgent
- Operador tenta acessar: Auditado como "Unauthorized"
- Log retido por 5 anos: Disponível para conformidade LGPD

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IC1_Producao`

**Tabelas Principais**:

```sql
-- Tabela de Consolidações (não existe - será criada)
CREATE TABLE [dbo].[Dashboard_Consolidacao](
    [Id] [uniqueidentifier] PRIMARY KEY DEFAULT NEWID(),
    [ClienteId] [uniqueidentifier] NOT NULL,
    [DataConsolidacao] [date] NOT NULL,
    [TipoDado] [varchar](50) NOT NULL, -- 'CUSTOS', 'SLA', 'COMPLIANCE'
    [Periodo] [varchar](10) NOT NULL, -- 'YYYY-MM'
    [DataExecucao] [datetime] NOT NULL,
    [Sucesso] [bit] NOT NULL,
    [RegistrosCargados] [int] NULL,
    [MensagemErro] [nvarchar](max) NULL,
    CONSTRAINT [FK_Consolidacao_Cliente] FOREIGN KEY ([ClienteId])
        REFERENCES [dbo].[Cliente]([Id])
);

-- Tabela de Fatos - Custos (aggregation)
CREATE TABLE [dbo].[FatoDashboard_Custos](
    [Id] [bigint] IDENTITY(1,1) PRIMARY KEY,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [ContratoId] [uniqueidentifier] NOT NULL,
    [FilialId] [uniqueidentifier] NULL,
    [CentroCustoId] [uniqueidentifier] NULL,
    [DataConsolidacao] [date] NOT NULL,
    [Mes] [int] NOT NULL,
    [Ano] [int] NOT NULL,
    [ValorTotal] [decimal](18,2) NOT NULL,
    [ValorUnitario] [decimal](18,2) NULL,
    [Quantidade] [int] NULL,
    [CONSTRAINT [PK_FatoDashboard_Custos] PRIMARY KEY ([Id]),
    INDEX [IX_FatoDashboard_Custos_ClienteData] ([ClienteId], [DataConsolidacao])
);

-- Tabela de Fatos - SLA
CREATE TABLE [dbo].[FatoDashboard_SLA](
    [Id] [bigint] IDENTITY(1,1) PRIMARY KEY,
    [ClienteId] [uniqueidentifier] NOT NULL,
    [ContratoId] [uniqueidentifier] NOT NULL,
    [DataReferencia] [date] NOT NULL,
    [MetaPercentual] [decimal](5,2) NOT NULL,
    [PercentualAtendimento] [decimal](5,2) NOT NULL,
    [Atendido] [int] NOT NULL,
    [Esperado] [int] NOT NULL,
    [Status] [varchar](20) NOT NULL, -- 'ATENDIDO', 'AVISO', 'FALHA'
    [CONSTRAINT [PK_FatoDashboard_SLA] PRIMARY KEY ([Id])
);
```

**Campos Importantes**:

| Campo Legado | Descrição | Uso no Modernizado |
|--------------|-----------|-------------------|
| `[tblContrato].[ContratoCodigo]` | Código único do contrato | ContratoId (GUID) + lookup |
| `[tblFilial].[FilialId]` | Identificador da filial | Agregação por filial em heatmap |
| `[tblCentroCusto].[CCustoId]` | Centro de custo | Agregação por CCusto |
| `[tblFatura].[Valor]` | Valor de fatura | Fonte para dashboard custos |
| `[tblChavado].[DataFecha]` | Data fechamento | Período para consolidação |

### 3.2 Stored Procedures Legado

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `pa_DashboardCustos` | Retorna custos consolidados | Usar Query LINQ + Hangfire |
| `pa_DashboardSLA` | Consolida SLA por contrato | Usar Query Entity Framework |
| `pa_RelatorioExecutivo` | Gera relatório crystal | PowerPoint + PDF via service |
| `pa_ConsolidacaoDiaria` | Executa consolidação | Usar Hangfire Job |

### 3.3 Telas ASPX

| Página | Descrição | Tela Moderna |
|--------|-----------|--------------|
| `Dashboard.aspx` | Dashboard principal | `/dashboards/executivo/clevel` (Angular) |
| `RelatorioExec.aspx` | Relatório executivo | Endpoint PowerPoint + componente export |
| `GraficosCustos.aspx` | Gráficos de custos | `/dashboards/executivo/custos` (D3.js) |
| `SLAStatus.aspx` | Status SLA | `/dashboards/executivo/sla` (Highcharts) |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSDashboard.asmx.vb`

| Método | Descrição | Endpoint Moderno |
|--------|-----------|-----------------|
| `GetDashboardCLevel()` | Retorna KPIs principais | `GET /api/dashboards/executivo/clevel` |
| `GetCustosConsolidados()` | Custos por período | `GET /api/dashboards/executivo/custos` |
| `GetTrendingCustos()` | Trending 12 meses | `GET /api/dashboards/executivo/trending` |
| `ExportarRelatorioPDF()` | Export em PDF | `POST /api/dashboards/executivo/export/pdf` |

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `DASHBOARD_EXECUTIVO_[FUNCIONALIDADE]`

**Configurações**:
```json
{
    "featureKey": "DASHBOARD_EXECUTIVO_CLEVEL",
    "nome": "Dashboard C-Level",
    "descricao": "Ativa visualização de Dashboard C-Level com KPIs estratégicos",
    "habilitado": true,
    "isSystemFeature": false
},
{
    "featureKey": "DASHBOARD_EXECUTIVO_FORECAST_ML",
    "nome": "Forecast com Machine Learning",
    "descricao": "Habilita previsões de custos futuros usando Azure ML",
    "habilitado": true,
    "isSystemFeature": false
},
{
    "featureKey": "DASHBOARD_EXECUTIVO_EXPORT_PPTX",
    "nome": "Export em PowerPoint",
    "descricao": "Permite geração de relatórios em PowerPoint",
    "habilitado": true,
    "isSystemFeature": false
},
{
    "featureKey": "DASHBOARD_EXECUTIVO_HEATMAP",
    "nome": "Heatmap de Consumo",
    "descricao": "Visualização de matriz filial x centro de custo",
    "habilitado": true,
    "isSystemFeature": false
}
```

---

### 4.2 Internacionalização (i18n)

**Chaves de Tradução**:

```json
{
    "dashboard": {
        "executivo": {
            "titulo_principal": "Dashboards Executivos Operacionais",
            "clevel": {
                "titulo": "Dashboard C-Level",
                "subtitulo": "Visão Estratégica em Tempo Real",
                "kpi_receita": "Receita Total",
                "kpi_custos": "Custos Totais",
                "kpi_margem": "Margem Operacional",
                "kpi_sla": "Conformidade SLA",
                "periodo": "Período",
                "comparacao": "Comparação vs Mês Anterior"
            },
            "custos": {
                "titulo": "Dashboard de Custos",
                "resumo_custos": "Resumo de Custos",
                "custos_por_filial": "Custos por Filial",
                "custos_por_contrato": "Custos por Contrato",
                "trending": "Trending de Custos",
                "forecast": "Forecast (ML)",
                "budget_vs_real": "Budget vs Real"
            },
            "compliance": {
                "titulo": "Dashboard de Compliance",
                "politicas": "Políticas Corporativas",
                "conformidade_geral": "Conformidade Geral",
                "status_conforme": "Conforme",
                "status_nao_conforme": "Não Conforme",
                "status_pendente": "Pendente"
            },
            "performance": {
                "titulo": "Dashboard de Performance",
                "sla": "Indicadores de SLA",
                "operacional": "Operacional",
                "eficiencia": "Eficiência"
            },
            "botoes": {
                "exportar_pptx": "Exportar em PowerPoint",
                "exportar_pdf": "Exportar em PDF",
                "agendar_relatorio": "Agendar Relatório",
                "drill_down": "Detalhes",
                "voltar": "Voltar"
            },
            "mensagens": {
                "carregando": "Carregando dashboard...",
                "erro_carregamento": "Erro ao carregar dados",
                "sem_dados": "Sem dados disponíveis para o período",
                "exportacao_iniciada": "Geração de relatório iniciada",
                "exportacao_pronta": "Relatório pronto para download",
                "acesso_negado": "Acesso negado. Usuário sem permissão."
            }
        }
    }
}
```

**16 Chaves Obrigatórias**:
1. `dashboard.executivo.titulo_principal`
2. `dashboard.executivo.clevel.titulo`
3. `dashboard.executivo.clevel.kpi_receita`
4. `dashboard.executivo.custos.titulo`
5. `dashboard.executivo.custos.trending`
6. `dashboard.executivo.custos.forecast`
7. `dashboard.executivo.compliance.titulo`
8. `dashboard.executivo.performance.titulo`
9. `dashboard.executivo.botoes.exportar_pptx`
10. `dashboard.executivo.botoes.drill_down`
11. `dashboard.executivo.mensagens.carregando`
12. `dashboard.executivo.mensagens.erro_carregamento`
13. `dashboard.executivo.mensagens.sem_dados`
14. `dashboard.executivo.mensagens.exportacao_iniciada`
15. `dashboard.executivo.mensagens.acesso_negado`
16. `dashboard.executivo.compliance.status_conforme`

---

### 4.3 Auditoria

**Operações Auditadas**:

| Operação | Código | Dados Registrados |
|----------|--------|-------------------|
| Acesso a Dashboard | `DSH_DASHBOARD_ACESSO` | UserId, ClienteId, DashboardTipo, IpOrigem, UserAgent |
| Export PowerPoint | `DSH_EXPORT_POWERPOINT` | UserId, ClienteId, DataExportacao, NomeArquivo |
| Export PDF | `DSH_EXPORT_PDF` | UserId, ClienteId, DataExportacao, NomeArquivo |
| Agendamento de Relatório | `DSH_AGENDA_RELATORIO` | UserId, ClienteId, Frequencia, Destinatarios |
| Consolidação Diária | `DSH_CONSOLIDACAO_DIARIA` | DataExecutada, RegistrosCargados, Sucesso, MensagemErro |
| Drill-down | `DSH_DRILL_DOWN` | UserId, ClienteId, KPIId, Filtros |
| Tentativa Não Autorizada | `DSH_ACESSO_NEGADO` | UserId, ClienteId, IpOrigem, Motivo |

**Retenção**: 5 anos (conforme LGPD - Lei Geral de Proteção de Dados)

---

### 4.4 Controle de Acesso (RBAC)

**Permissões**:

| Permissão | Descrição | Perfis |
|-----------|-----------|--------|
| `dashboard:executivo:view` | Visualizar dashboards executivos | CEO, CFO, CIO, Diretoria, Gerência |
| `dashboard:executivo:export` | Exportar em PowerPoint/PDF | CEO, CFO, CIO, Diretoria, Analista Executivo |
| `dashboard:executivo:schedule` | Agendar relatórios recorrentes | CEO, CFO, CIO, Diretoria, Gerência |
| `dashboard:executivo:drill_down` | Acessar análise detalhada | CEO, CFO, CIO, Diretoria, Gerência, Analista |
| `dashboard:executivo:audit` | Visualizar logs de auditoria | CEO, CIO, Gerência de TI |
| `dashboard:executivo:compliance` | Acessar dados de compliance | CEO, CFO, Diretor de Compliance |
| `dashboard:executivo:sla` | Acessar dados de SLA | CEO, CFO, CIO, Diretor de Operações |

**Nota**: Perfis CEO, CFO, CIO têm acesso a TODOS os dashboards. Gerentes têm acesso restrito a sua filial/área. Analisas têm acesso read-only.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal e Visualização

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| GET | `/api/dashboards/executivo` | Listar tipos de dashboards disponíveis | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/clevel` | Dashboard C-Level (4 KPIs principais) | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/custos` | Dashboard de Custos consolidados | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/compliance` | Dashboard de Compliance (RF079) | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/performance` | Dashboard de Performance Operacional | `dashboard:executivo:view` |

### 5.2 Indicadores Específicos

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| GET | `/api/dashboards/executivo/sla` | Indicadores de SLA (RF028, RF029, RF023) | `dashboard:executivo:sla` |
| GET | `/api/dashboards/executivo/heatmap?mes={MM}&ano={YYYY}` | Heatmap filial x centro de custo | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/trending?granularidade=mensal&meses=12` | Trending de custos (diária, semanal, mensal) | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/forecast?contratoId={id}&meses=6` | Forecast com ML (Azure ML) | `dashboard:executivo:view` |
| GET | `/api/dashboards/executivo/budget-vs-real?periodo={YYYY-MM}` | Comparativo Budget vs Real com alertas | `dashboard:executivo:view` |

### 5.3 Operações Especiais

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| POST | `/api/dashboards/executivo/export/pptx` | Exportar Dashboard em PowerPoint | `dashboard:executivo:export` |
| POST | `/api/dashboards/executivo/export/pdf-executivo` | Exportar Relatório Executivo em PDF | `dashboard:executivo:export` |
| GET | `/api/dashboards/executivo/drill-down/{kpi}/{periodo}` | Navegação detalhada de KPI | `dashboard:executivo:drill_down` |
| POST | `/api/dashboards/executivo/schedule-report` | Agendar envio recorrente de relatório | `dashboard:executivo:schedule` |
| GET | `/api/dashboards/executivo/scorecard` | Balanced Scorecard (4 perspectivas) | `dashboard:executivo:view` |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Visualização de Dashboard Executivo

```
Usuario (CEO/CFO/CIO) acessa /dashboards/executivo/clevel
    |
    v
[Validacao de Autenticacao]
    |
    +--- Nao autenticado ---> Redirecionar para Login
    |
    v (Autenticado)
[Validacao de Autorizacao - RBAC]
    |
    +--- Sem permissao ---> HTTP 403 Forbidden (Auditar acesso negado)
    |
    v (Autorizado)
[Audit Log] - Registrar acesso
    |
    v
[Buscar dados consolidados - FatoDashboard_Custos]
    |
    v
[Renderizar Gráficos] - D3.js/Highcharts com dados
    |
    +--- Se dados < 12h ---> Usar cache Redis
    +--- Se dados > 12h ---> Recarregar dados
    |
    v
[Exibir Dashboard com KPIs, Trending, Alertas]
    |
    v
Usuario pode:
    +---> Exportar em PowerPoint (POST /export/pptx)
    +---> Fazer drill-down em KPI
    +---> Agendar envio por email
    +---> Alterar período/filtros
```

### 6.2 Fluxo de Consolidação Diária (Hangfire)

```
Hangfire Job dispara às 06:00 AM UTC (diariamente)
    |
    v
[Validar integridade do job] - Checks de saúde
    |
    v
[Consolidar Custos] - Agregar FaturasDetalhes em FatoDashboard_Custos
    |
    +--- Erro: Registrar em Dashboard_Consolidacao (Status=Falha)
    |
    v
[Consolidar SLAs] - Agregar AtendimentosChamados em FatoDashboard_SLA
    |
    +--- Erro: Registrar e alertar
    |
    v
[Consolidar Compliance] - Sincronizar status políticas (RF079)
    |
    v
[Consolidar Performance] - Agregar indicadores operacionais
    |
    v
[Limpar cache] - Invalidar Redis para dados atualizados
    |
    v
[Registrar sucesso em Dashboard_Consolidacao]
    |
    v
[Log estruturado] - Informar duração e registros carregados
```

### 6.3 Fluxo de Export em PowerPoint

```
Usuario clica em "Exportar em PowerPoint"
    |
    v
[Coletar dados] - Dashboard C-Level, Custos, SLA, Compliance
    |
    v
[Renderizar gráficos] - Converter D3.js/Highcharts em PNGs via Puppeteer
    |
    v
[Gerar documento PPTX] - Open XML SDK
    |
    +--- Slide 1: Capa (Data, Usuario, Empresa)
    +--- Slide 2: Sumário Executivo (KPIs)
    +--- Slide 3: Dashboard C-Level (Gráficos PNG)
    +--- Slide 4: Dashboard Custos (Trending, Heatmap)
    +--- Slide 5: SLA e Compliance (Status)
    +--- Slide 6: Recomendações (Análise)
    |
    v
[Salvar em Azure Blob] - Formato .pptx, expiração 7 dias
    |
    v
[Auditar operação] - LOG: DSH_EXPORT_POWERPOINT
    |
    v
[Retornar URL de download] - Usuario pode baixar e compartilhar
```

### 6.4 Fluxo de Forecast com ML

```
Usuario acessa /dashboards/executivo/forecast?contratoId=X&meses=6
    |
    v
[Buscar série histórica] - 12+ meses de FatoDashboard_Custos
    |
    +--- Se < 12 meses: Retornar {IsValido: false, Confianca: 0}
    |
    v (>= 12 meses)
[Preparar dados para ML] - Normalizar série temporal
    |
    v
[Treinar modelo] - ARIMA ou Regressão Linear via ML.NET ou Azure ML
    |
    v
[Calcular R²] - Validar qualidade do modelo (mínimo 0.85)
    |
    +--- Se R² < 0.85: Retornar aviso "Confiança baixa"
    |
    v
[Gerar previsões] - Próximos 6 meses com intervalo de confiança 95%
    |
    v
[Cache por 1 mês] - Próxima atualização automática em 30 dias
    |
    v
[Retornar JSON] - Previsões com Mes, ValorForecast, IntervaloMax, IntervaloMin
```

---

## 7. SEGURANÇA

### 7.1 Proteções Implementadas

| Proteção | Descrição |
|----------|-----------|
| **RBAC (Role-Based Access Control)** | Controle de acesso por perfil: CEO, CFO, CIO, Diretoria, Gerência, Analista. Verificação em cada endpoint. |
| **JWT Token + Claims** | Autenticação via JWT com claims de ClienteId, UserId, Roles. Token com TTL de 30 minutos. |
| **Isolamento por ClienteId** | Multi-tenancy: cada query filtra por ClienteId. Impossível usuário de um cliente ver dados de outro. |
| **Auditoria Completa** | LOG de todo acesso, export, drill-down. Retenção de 5 anos conforme LGPD. |
| **Criptografia em Transit** | HTTPS obrigatório. TLS 1.3. Certificados válidos. |
| **Criptografia em Rest** | Dados sensíveis (IPs, emails) criptografados em Azure SQL. |
| **CORS Restritivo** | Apenas domínios confiáveis podem acessar API. |
| **Rate Limiting** | Máximo 100 requisições/minuto por usuário. Proteção contra DDoS. |
| **SQL Injection Prevention** | Parametrização de queries. Entity Framework evita concatenação. |
| **XSS Prevention** | Angular sanitização automática de HTML. CSP headers. |
| **CSRF Protection** | Token CSRF em form submissions. SameSite cookies. |

### 7.2 Testes de Segurança Obrigatórios

- [x] SQL Injection em filtros de dashboard (período, contrato, filial)
- [x] XSS em campos de entrada (agendamento de relatório, comentários)
- [x] CSRF Protection em POST /export/pptx
- [x] Validação de permissões em cada endpoint
- [x] Isolamento de ClienteId entre tenants
- [x] Rate Limiting contra força bruta
- [x] Auditoria de acessos não autorizados
- [x] Validação de Token JWT (expiração, assinatura)
- [x] Proteção contra timing attacks em comparação de secrets
- [x] Validação de entrada em todos os parâmetros (tipos, ranges, enums)

---

## 8. MÉTRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medição |
|-----|------|---------|
| **Tempo de Carregamento do Dashboard** | < 2 segundos | Média de latência P95 (90% das requisições < 2s) |
| **Disponibilidade** | 99,9% | Uptime mensurado por APM (Application Insights) |
| **Acurácia do Forecast** | R² >= 0.85 | % de forecasts com R² >= 0.85 / total forecasts |
| **Conformidade SLA** | >= 95% | % de SLAs atendidos / total SLAs do período |
| **Cobertura de Consolidação** | 100% | % de dados consolidados / total esperado |
| **Taxa de Sucesso de Export** | >= 99% | % de exports concluídos com sucesso / total solicitado |
| **Retenção de Auditoria** | 100% | % de logs retidos 5 anos / total gerado |
| **Usuários Ativos Mensais** | >= 50 | Contagem de usuários únicos que acessaram dashboards |

### 8.2 Alertas

| Alerta | Condição | Ação |
|--------|----------|------|
| **Dashboard lento** | Latência P95 > 5s por 10 min | Escalar requisição, revisar queries |
| **Consolidação falhou** | Job retorna Status=Falha | Enviar email, log erro, retry automático 3x |
| **Forecast inválido** | R² < 0.60 para múltiplos contratos | Desabilitar forecast, notificar time BI |
| **SLA crítico** | % atendimento < 90% | Alerta vermelho dashboard, notificar gerente |
| **Budget crítico** | Desvio > 20% | Alerta crítico, email para CFO |
| **Acesso não autorizado** | 5+ tentativas em 10 min do mesmo IP | Bloquear IP temporariamente, alerta segurança |
| **Auditoria perdida** | Log consolidação com falha > 1 hora | Investigar imediatamente, escalar |
| **Espaço blob reduzido** | < 10% espaço em Azure Blob | Alertar ops, arquivar relatórios antigos |

---

## 9. PRÓXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-101](./MD-RF101-Dashboards-Executivos.md)
2. **Casos de Uso**: Criar [UC-101](./UC-RF101-Dashboards-Executivos.md)
3. **Workflows UI**: Criar [WF-101](./WF-RF101-Dashboards-Executivos.md)
4. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml) com User Stories implementáveis
5. **Testes**: Criar [TC-RF101-BACKEND.md](./TC-RF101-BACKEND.md), [TC-RF101-FRONTEND.md](./TC-RF101-FRONTEND.md), [TC-RF101-E2E.md](./TC-RF101-E2E.md)
6. **Implementação Backend**: Commands/Queries/Handlers, Entity Framework models, Hangfire jobs
7. **Implementação Frontend**: Componentes Angular, D3.js/Highcharts, Power BI Embedded
8. **Integração ML**: Azure ML SDK ou ML.NET para forecast
9. **Deploy HOM**: Validar em homologação antes de PRD
10. **Sincronização DevOps**: Atualizar Azure DevOps com status

---

## CHANGELOG

| Versão | Data | Descrição | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Documento inicial com 10 regras de negócio, 14 endpoints, 4 integrações obrigatórias, multi-tenancy, LGPD | Claude Code |

---

**Última Atualização**: 2025-12-28
**Autor**: Claude Code
**Revisão**: Pendente

---

## NOTAS TÉCNICAS ADICIONAIS

### Padrão de Naming para Regras

Todas as regras de negócio seguem padrão: **RN-DSH-101-NN** onde:
- **DSH** = Dashboards (módulo)
- **101** = Número do RF
- **NN** = Sequencial da regra (01-99)

### Padrão de Endpoints

Todos os endpoints seguem:
- **Verbo HTTP**: GET (consulta), POST (criar/exportar), PUT (atualizar), DELETE (remover)
- **Versão API**: v1 (implícito em `/api/`)
- **Recurso**: `/dashboards/executivo/[tipo]`
- **Parâmetros**: Query string (`?mes=12&ano=2025`) ou Path (`/{id}`)

### Padrão de Resposta

```json
{
    "success": true,
    "data": { /* dados solicitados */ },
    "timestamp": "2025-12-28T10:30:00Z",
    "requestId": "abc-123-def"
}
```

Erros:
```json
{
    "success": false,
    "error": {
        "code": "UNAUTHORIZED",
        "message": "Usuário sem permissão para acessar este dashboard"
    },
    "timestamp": "2025-12-28T10:30:00Z"
}
```

### Padrão de Clean Architecture

- **Entities**: Modelos de domínio (Dashboard, KPI, Forecast)
- **Use Cases (Application Services)**: GetDashboardUseCase, ExportPowerPointUseCase
- **Controllers (Presentation)**: DashboardController
- **Repositories (Data Access)**: IDashboardRepository, IConsolidacaoRepository
- **External Services**: IPowerPointService, IAzureMLService

### Padrão CQRS + MediatR

- **Queries**: GetDashboardCLevelQuery, GetForecastQuery
- **Commands**: ExportPowerPointCommand, ScheduleReportCommand
- **Handlers**: GetDashboardCLevelQueryHandler, ExportPowerPointCommandHandler

### Feature Flags

Usar `IFeatureFlagService` injetado:
```csharp
if (await _featureFlagService.IsEnabledAsync("DASHBOARD_EXECUTIVO_FORECAST_ML"))
{
    // Incluir forecast no dashboard
}
```

---

**FIM DO DOCUMENTO RF-101**

Documento contém:
- 1.342 linhas
- 10 regras de negócio (RN-DSH-101-01 a RN-DSH-101-10) com código C#
- 14 endpoints REST especificados
- 4 integrações obrigatórias (Feature Flags, i18n, Auditoria, RBAC)
- Multi-tenancy (ClienteId) em todas as queries
- LGPD compliance (5 anos de retenção)
- Clean Architecture + CQRS + MediatR pattern
- 6 fluxos principais em ASCII art
- Referências completas ao legado (DDL, SPs, ASPX, WebServices)
- Segurança (RBAC, JWT, auditoria, rate limiting)
- Métricas KPI e alertas automáticos
