# RF108: CAPTCHA, MFA, Contestação e Segurança Avançada

**Versão**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF007, RF011, RF004 | **EPIC**: EPIC011-INT-Integrações
**Fase**: Fase 6 - Ativos, Auditoria e Integrações

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

Este requisito especifica o módulo de **Segurança Avançada e Anti-fraude** do sistema IControlIT, responsável por implementar CAPTCHA, Multi-Factor Authentication (MFA), contestação de faturas e análise comportamental de usuários para proteger contra ataques automatizados e fraudes.

O RF108 fornece camadas adicionais de proteção além da autenticação básica (RF007), cobrindo:
- Validação CAPTCHA em formulários sensíveis
- Autenticação multi-fator por SMS, Email e TOTP
- Contestação de faturas com workflow de aprovação
- Detecção e bloqueio de bots
- Rate limiting por IP/usuário
- Device fingerprinting
- Análise comportamental de usuários (UEBA)
- Notificação de acessos anômalos

### 1.2 Importância Estratégica

O módulo de Segurança Avançada é crítico para:
- **Segurança**: Proteção contra bots, força bruta e ataques DDoS
- **Conformidade**: Atendimento a LGPD, PCI-DSS e regulamentações de TI
- **Confiabilidade**: Garantia de que operações críticas sejam autênticas
- **Auditoria**: Rastreabilidade completa de acessos sensíveis
- **Reputação**: Prevenção de fraudes e uso indevido da plataforma

### 1.3 Conceitos Fundamentais

**CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart)**: Mecanismo que diferencia humanos de bots. Este projeto usa Google reCAPTCHA v3 com score de risco (0.0 a 1.0).

**MFA (Multi-Factor Authentication)**: Processo de autenticação que requer múltiplas formas de verificação (algo que você sabe, algo que você tem, algo que você é).

**TOTP (Time-based One-Time Password)**: Padrão RFC 6238 para gerar códigos únicos baseados em tempo (Google Authenticator, Microsoft Authenticator).

**Device Fingerprinting**: Identificação única de dispositivo baseada em atributos como User-Agent, resolução de tela, timezone e plugins.

**UEBA (User and Entity Behavior Analytics)**: Análise de padrões anormais de comportamento para detectar fraudes ou comprometimento de contas.

**Rate Limiting**: Controle de taxa de requisições para evitar abuso (típico: 100 req/min por IP).

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **CAPTCHA** | reCAPTCHA v2 (checkbox) | reCAPTCHA v3 (invisible + score) |
| **MFA** | Apenas SMS manual | SMS, Email, TOTP automáticos |
| **Rate Limiting** | Não implementado | Redis + AspNetCoreRateLimit |
| **Device Fingerprinting** | Não existia | FingerprintJS + ClientJS |
| **UEBA** | Logs manuais | Azure Application Insights + ML |
| **Contestação** | Formulário simples | Workflow com aprovação multi-nível |
| **Bloqueio de IP** | Manual por admin | Automático + whitelist/blacklist |
| **Auditoria** | Logs básicos | Auditoria LGPD completa |

### 1.5 Funcionalidades Principais

1. **CAPTCHA em Formulários Sensíveis** - Proteção contra bots em login, cadastro e redefinição de senha
2. **MFA Multi-canal** - Autenticação em múltiplas etapas via SMS, Email ou TOTP
3. **Contestação de Faturas** - Workflow de aprovação com justificativa obrigatória
4. **Detecção de Bots** - Análise de padrões de requisição para identificar atacantes
5. **Rate Limiting Inteligente** - Limitação por IP, usuário e tipo de operação
6. **Bloqueio Automático de IPs** - Bloqueio após N tentativas falhadas
7. **Whitelist/Blacklist de IPs** - Gestão manual de IPs confiáveis/bloqueados
8. **Device Fingerprinting** - Identificação e verificação de dispositivos confiáveis
9. **UEBA (análise comportamental)** - Detecção de acessos anômalos por localização, hora ou padrão
10. **Notificações de Acessos** - Alerta de login de nova localização/dispositivo

---

## 2. REGRAS DE NEGÓCIO

### RN-SEC-108-01: CAPTCHA Obrigatório após Falhas de Login

**Descrição**: Após 3 tentativas de login falhadas em 10 minutos, CAPTCHA é obrigatório para a próxima tentativa.

**Justificativa**: Proteção contra ataque de força bruta (brute force attack).

**Implementação**:
```csharp
public class LoginFailureTracker
{
    private readonly IRedisCache _cache;
    private const int MaxFailures = 3;
    private const int WindowMinutes = 10;

    public async Task<bool> IsLoginFrozen(string email)
    {
        string key = $"login_failures:{email}";
        var failures = await _cache.GetAsync<int>(key);
        return failures >= MaxFailures;
    }

    public async Task RecordLoginFailure(string email)
    {
        string key = $"login_failures:{email}";
        var failures = await _cache.IncrementAsync(key);

        if (failures == 1)
        {
            await _cache.SetExpiryAsync(key, TimeSpan.FromMinutes(WindowMinutes));
        }
    }

    public async Task ClearLoginFailures(string email)
    {
        string key = $"login_failures:{email}";
        await _cache.DeleteAsync(key);
    }
}
```

**Exemplos**:
- Tentativa 1: falha (não requer CAPTCHA)
- Tentativa 2: falha (não requer CAPTCHA)
- Tentativa 3: falha (não requer CAPTCHA)
- Tentativa 4: **REQUER CAPTCHA**
- Após sucesso: contador resetado

---

### RN-SEC-108-02: MFA Obrigatório para Perfis Críticos

**Descrição**: Usuários com perfis Admin, Gestor ou Auditor devem obrigatoriamente ativar MFA.

**Justificativa**: Proteção contra comprometimento de contas de alto privilégio.

**Implementação**:
```csharp
public class MfaValidator
{
    private readonly IUserRepository _userRepository;
    private readonly IPermissionService _permissionService;

    public async Task<bool> IsMfaRequired(Guid userId)
    {
        var user = await _userRepository.GetByIdAsync(userId);
        var roles = await _permissionService.GetUserRolesAsync(userId);

        var criticalRoles = new[] { "Admin", "Gestor", "Auditor" };
        return roles.Any(r => criticalRoles.Contains(r.Name));
    }

    public async Task EnforceMfa(Guid userId)
    {
        var isMfaRequired = await IsMfaRequired(userId);
        if (isMfaRequired)
        {
            var user = await _userRepository.GetByIdAsync(userId);
            if (user.MfaStatus != MfaStatus.Enabled)
            {
                throw new MfaRequiredException(
                    "MFA é obrigatório para seu perfil. Configure em Segurança > MFA");
            }
        }
    }
}

public enum MfaStatus
{
    Disabled,
    Enabled,
    Pending
}
```

**Exemplos**:
- Usuário comum (Operador): MFA opcional
- Usuário gestor: MFA obrigatório (bloqueado se não configurado)
- Usuário admin: MFA obrigatório (bloqueado se não configurado)

---

### RN-SEC-108-03: Código TOTP Válido por 30 Segundos

**Descrição**: Códigos gerados por TOTP (Google Authenticator) são válidos apenas por 30 segundos conforme RFC 6238.

**Justificativa**: Padrão de segurança para one-time passwords sensível ao tempo.

**Implementação**:
```csharp
public class TotpService
{
    private readonly ITotpGenerator _totpGenerator;
    private const int TimeStepSeconds = 30;

    public async Task<string> GenerateTotpSecret(Guid userId)
    {
        var secret = KeyGeneration.GenerateRandomKey(20);
        var secretBase32 = Base32Encoding.ToString(secret);

        await _userRepository.UpdateTotpSecretAsync(userId, secretBase32);

        return secretBase32;
    }

    public async Task<bool> ValidateTotpCode(Guid userId, string code)
    {
        var user = await _userRepository.GetByIdAsync(userId);
        var secretBytes = Base32Encoding.ToBytes(user.TotpSecret);

        var totp = new Totp(secretBytes, timeStep: TimeStepSeconds);

        // Valida código atual e +/- 1 janela (30s antes/depois)
        return totp.VerifyTotp(code, out long timeWindowUsed,
            useAdditionalTimeWindow: true);
    }
}
```

**Exemplos**:
- Código gerado: 123456 (válido por 0-30 segundos)
- Código expirado: rejeitado após 30 segundos

---

### RN-SEC-108-04: Código SMS Válido por 5 Minutos

**Descrição**: Códigos enviados por SMS são válidos por 5 minutos.

**Justificativa**: Tempo suficiente para o usuário receber e digitar, mas com limite para segurança.

**Implementação**:
```csharp
public class SmsMfaService
{
    private readonly ITwilioClient _twilio;
    private readonly IRedisCache _cache;
    private const int ValidityMinutes = 5;
    private const int CodeLength = 6;

    public async Task<string> SendMfaCodeViaSms(string phoneNumber, string email)
    {
        var code = GenerateRandomCode(CodeLength);
        var cacheKey = $"mfa_sms:{email}";

        await _cache.SetAsync(cacheKey, code,
            TimeSpan.FromMinutes(ValidityMinutes));

        await _twilio.SendAsync(new SmsMessage
        {
            To = phoneNumber,
            Body = $"Seu código MFA: {code}. Válido por 5 minutos."
        });

        return code; // Apenas para teste
    }

    public async Task<bool> ValidateSmsCode(string email, string providedCode)
    {
        var cacheKey = $"mfa_sms:{email}";
        var storedCode = await _cache.GetAsync<string>(cacheKey);

        if (storedCode == null)
            return false; // Expirado ou não enviado

        bool isValid = storedCode == providedCode;

        if (isValid)
            await _cache.DeleteAsync(cacheKey);

        return isValid;
    }
}

private string GenerateRandomCode(int length)
{
    using (var rng = new RNGCryptoServiceProvider())
    {
        byte[] tokenData = new byte[length];
        rng.GetBytes(tokenData);
        return string.Concat(tokenData.Select(x => (x % 10).ToString()));
    }
}
```

**Exemplos**:
- SMS enviado: 123456 (válido por 5 minutos)
- Após 5 minutos: código inválido

---

### RN-SEC-108-05: Contestação Requer Justificativa Mínima

**Descrição**: Toda contestação de fatura exige justificativa com mínimo 50 caracteres.

**Justificativa**: Garantir que contestação seja bem fundamentada e rastreável.

**Implementação**:
```csharp
public class ContestationValidator
{
    private const int MinJustificationLength = 50;

    public ValidationResult ValidateContestationRequest(CreateContestationCommand cmd)
    {
        var errors = new List<string>();

        if (string.IsNullOrWhiteSpace(cmd.Justification))
            errors.Add("Justificativa é obrigatória");

        if (cmd.Justification?.Length < MinJustificationLength)
            errors.Add($"Justificativa deve ter no mínimo {MinJustificationLength} caracteres");

        if (!cmd.InvoiceId.HasValue)
            errors.Add("Fatura deve ser informada");

        return errors.Any()
            ? ValidationResult.Failure(errors)
            : ValidationResult.Success();
    }
}

public class CreateContestationHandler
    : ICommandHandler<CreateContestationCommand, ContestationId>
{
    private readonly IContestationRepository _repository;
    private readonly IValidator _validator;
    private readonly IAuditService _audit;

    public async Task<ContestationId> Handle(
        CreateContestationCommand cmd,
        CancellationToken ct)
    {
        var validationResult = _validator.ValidateContestationRequest(cmd);
        if (!validationResult.IsSuccess)
            throw new ValidationException(validationResult.Errors);

        var contestation = new Contestation(
            id: ContestationId.New(),
            invoiceId: cmd.InvoiceId.Value,
            userId: cmd.UserId,
            justification: cmd.Justification,
            status: ContestationStatus.Pending,
            createdAt: DateTime.UtcNow,
            clienteId: cmd.ClienteId
        );

        await _repository.AddAsync(contestation, ct);

        await _audit.LogAsync(new AuditEntry
        {
            Operation = "CONTESTACAO_CREATE",
            Entity = "Contestation",
            EntityId = contestation.Id.Value,
            UserId = cmd.UserId,
            ClienteId = cmd.ClienteId,
            Details = new { InvoiceId = cmd.InvoiceId }
        });

        return contestation.Id;
    }
}
```

**Exemplos**:
- Justificativa válida: "Fatura duplicada conforme email de 15/12" (54 caracteres) ✓
- Justificativa inválida: "Errada" (5 caracteres) ✗

---

### RN-SEC-108-06: Rate Limiting - 100 Requisições por Minuto por IP

**Descrição**: Limite máximo de 100 requisições por minuto por endereço IP.

**Justificativa**: Proteção contra abuso e DDoS.

**Implementação**:
```csharp
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IDistributedCache _cache;
    private const int RequestsPerMinute = 100;
    private const int WindowSeconds = 60;

    public async Task InvokeAsync(HttpContext context)
    {
        var ipAddress = context.Connection.RemoteIpAddress?.ToString();
        var rateLimitKey = $"ratelimit:{ipAddress}";

        var requestCount = await GetRequestCountAsync(rateLimitKey);

        if (requestCount >= RequestsPerMinute)
        {
            context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
            await context.Response.WriteAsync("Rate limit exceeded");
            return;
        }

        await IncrementRequestCountAsync(rateLimitKey);
        await _next(context);
    }

    private async Task<int> GetRequestCountAsync(string key)
    {
        var count = await _cache.GetAsync(key);
        return count != null ? int.Parse(Encoding.UTF8.GetString(count)) : 0;
    }

    private async Task IncrementRequestCountAsync(string key)
    {
        var count = await GetRequestCountAsync(key);
        await _cache.SetAsync(key,
            Encoding.UTF8.GetBytes((count + 1).ToString()),
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(WindowSeconds)
            });
    }
}
```

**Exemplos**:
- IP 192.168.1.1: 50 requisições em 30s → OK
- IP 192.168.1.1: 100 requisições em 60s → OK
- IP 192.168.1.1: 101ª requisição em 60s → HTTP 429 (Too Many Requests)

---

### RN-SEC-108-07: Bloqueio Automático por DDoS - 10 req/seg

**Descrição**: IP que fizer mais de 10 requisições por segundo é automaticamente bloqueado por 1 hora.

**Justificativa**: Proteção contra ataques DDoS (Distributed Denial of Service).

**Implementação**:
```csharp
public class DdosProtectionService
{
    private readonly IRedisCache _cache;
    private const int RequestsPerSecond = 10;
    private const int BlockDurationMinutes = 60;

    public async Task<bool> IsIpBlocked(string ipAddress)
    {
        var blockedKey = $"blocked:{ipAddress}";
        var blocked = await _cache.GetAsync<bool>(blockedKey);
        return blocked;
    }

    public async Task CheckAndBlockIfNecessary(string ipAddress)
    {
        var currentSecond = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        var countKey = $"ddos:{ipAddress}:{currentSecond}";

        var count = await _cache.IncrementAsync(countKey);

        if (count == 1)
        {
            await _cache.SetExpiryAsync(countKey, TimeSpan.FromSeconds(1));
        }

        if (count > RequestsPerSecond)
        {
            var blockedKey = $"blocked:{ipAddress}";
            await _cache.SetAsync(blockedKey, true,
                TimeSpan.FromMinutes(BlockDurationMinutes));

            throw new DdosDetectedException(
                $"IP {ipAddress} bloqueado por suspeita de ataque");
        }
    }
}

public class DdosMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IDdosProtectionService _ddosService;

    public async Task InvokeAsync(HttpContext context)
    {
        var ipAddress = context.Connection.RemoteIpAddress?.ToString();

        if (await _ddosService.IsIpBlocked(ipAddress))
        {
            context.Response.StatusCode = StatusCodes.Status403Forbidden;
            await context.Response.WriteAsync("IP blocked");
            return;
        }

        await _ddosService.CheckAndBlockIfNecessary(ipAddress);
        await _next(context);
    }
}
```

**Exemplos**:
- IP 10.0.0.1 faz 5 req/seg em 5 seg diferentes → OK
- IP 10.0.0.1 faz 15 req/seg no mesmo segundo → Bloqueado por 60 minutos

---

### RN-SEC-108-08: IP Bloqueado - Desbloqueio Automático em 24h

**Descrição**: IP bloqueado automaticamente é liberado após 24 horas, ou manualmente por admin.

**Justificativa**: Evitar bloqueio permanente de IP legítimo.

**Implementação**:
```csharp
public class IpBlockingService
{
    private readonly IIpBlockRepository _repository;
    private const int AutoUnblockHours = 24;

    public async Task BlockIpAsync(string ipAddress, string reason)
    {
        var ipBlock = new IpBlock
        {
            IpAddress = ipAddress,
            Reason = reason,
            BlockedAt = DateTime.UtcNow,
            UnblockAt = DateTime.UtcNow.AddHours(AutoUnblockHours),
            BlockType = BlockType.Automatic,
            Status = BlockStatus.Active
        };

        await _repository.AddAsync(ipBlock);
    }

    public async Task UnblockIpAsync(string ipAddress, string unblockReason = null)
    {
        var ipBlock = await _repository.GetActiveByIpAsync(ipAddress);
        if (ipBlock != null)
        {
            ipBlock.Status = BlockStatus.Inactive;
            ipBlock.UnblockReason = unblockReason;
            ipBlock.UnblockedAt = DateTime.UtcNow;
            await _repository.UpdateAsync(ipBlock);
        }
    }

    public async Task AutoUnblockExpiredBlocksAsync()
    {
        var expiredBlocks = await _repository.GetExpiredBlocksAsync();
        foreach (var block in expiredBlocks)
        {
            await UnblockIpAsync(block.IpAddress, "Desbloqueio automático após 24h");
        }
    }
}

public class IpBlock
{
    public Guid Id { get; set; }
    public string IpAddress { get; set; }
    public string Reason { get; set; }
    public DateTime BlockedAt { get; set; }
    public DateTime UnblockAt { get; set; }
    public DateTime? UnblockedAt { get; set; }
    public BlockType BlockType { get; set; }
    public BlockStatus Status { get; set; }
    public string UnblockReason { get; set; }
}

public enum BlockType { Automatic, Manual }
public enum BlockStatus { Active, Inactive }
```

**Exemplos**:
- IP bloqueado às 10:00 de 28/12 → Desbloqueio automático às 10:00 de 29/12
- Admin desbloqueia manualmente antes → Status mudado para Inactive

---

### RN-SEC-108-09: Device Fingerprint - Múltiplos Atributos

**Descrição**: Device fingerprint considera User-Agent, resolução de tela, timezone, idioma do navegador, lista de plugins e canvas fingerprint.

**Justificativa**: Identificação única de dispositivo para detecção de acessos anormais.

**Implementação**:
```csharp
public class DeviceFingerprintService
{
    private readonly IUserDeviceRepository _deviceRepository;

    public class DeviceFingerprint
    {
        public string UserAgent { get; set; }
        public int ScreenWidth { get; set; }
        public int ScreenHeight { get; set; }
        public string Timezone { get; set; }
        public string Language { get; set; }
        public List<string> Plugins { get; set; }
        public string CanvasFingerprint { get; set; }

        public string ComputeHash()
        {
            var data = $"{UserAgent}|{ScreenWidth}|{ScreenHeight}|{Timezone}|{Language}|" +
                      $"{string.Join(",", Plugins ?? new List<string>())}|{CanvasFingerprint}";
            using (var sha256 = SHA256.Create())
            {
                var hashedBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(data));
                return Convert.ToBase64String(hashedBytes);
            }
        }
    }

    public async Task<bool> IsDeviceTrusted(Guid userId, DeviceFingerprint fingerprint)
    {
        var hash = fingerprint.ComputeHash();
        var device = await _deviceRepository.GetByUserAndHashAsync(userId, hash);

        return device != null && device.IsTrusted;
    }

    public async Task RegisterDeviceAsync(
        Guid userId,
        DeviceFingerprint fingerprint,
        bool isTrusted = false)
    {
        var hash = fingerprint.ComputeHash();
        var device = new UserDevice
        {
            UserId = userId,
            FingerprintHash = hash,
            LastAccessAt = DateTime.UtcNow,
            IsTrusted = isTrusted,
            UserAgent = fingerprint.UserAgent,
            DeviceName = $"{fingerprint.ScreenWidth}x{fingerprint.ScreenHeight} ({fingerprint.Language})"
        };

        await _deviceRepository.AddAsync(device);
    }
}
```

**Exemplos**:
- Device 1: Samsung Galaxy S21, Chrome, 1440x3200, PT-BR → Trusted
- Device 2: MacBook Pro, Safari, 1920x1080, EN-US → Not Trusted
- Acesso de Device 3 (novo): Notificação de alerta

---

### RN-SEC-108-10: Auditoria LGPD de Bloqueios e MFA

**Descrição**: Todos os eventos de MFA, bloqueios de IP, contestações e acessos anômalos são auditados conforme LGPD com retenção de 5 anos.

**Justificativa**: Conformidade com Lei Geral de Proteção de Dados (LGPD) e rastreabilidade regulatória.

**Implementação**:
```csharp
public class SecurityAuditService
{
    private readonly IAuditRepository _auditRepository;
    private const int RetentionYears = 5;

    public async Task LogMfaEventAsync(Guid userId, MfaEventType eventType, string details)
    {
        var auditEntry = new AuditEntry
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            Operation = $"MFA_{eventType}",
            Entity = "User",
            EntityId = userId.ToString(),
            Details = details,
            IpAddress = null, // Será preenchido por middleware
            Timestamp = DateTime.UtcNow,
            RetentionUntil = DateTime.UtcNow.AddYears(RetentionYears)
        };

        await _auditRepository.AddAsync(auditEntry);
    }

    public async Task LogIpBlockAsync(string ipAddress, string reason)
    {
        var auditEntry = new AuditEntry
        {
            Id = Guid.NewGuid(),
            Operation = "SEC_IP_BLOCKED",
            Entity = "IpAddress",
            EntityId = ipAddress,
            Details = $"Razão: {reason}",
            Timestamp = DateTime.UtcNow,
            RetentionUntil = DateTime.UtcNow.AddYears(RetentionYears)
        };

        await _auditRepository.AddAsync(auditEntry);
    }

    public async Task LogAnomalousAccessAsync(
        Guid userId,
        string reason,
        string location,
        string device)
    {
        var auditEntry = new AuditEntry
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            Operation = "SEC_ANOMALOUS_ACCESS",
            Entity = "User",
            EntityId = userId.ToString(),
            Details = $"Motivo: {reason} | Local: {location} | Device: {device}",
            Timestamp = DateTime.UtcNow,
            RetentionUntil = DateTime.UtcNow.AddYears(RetentionYears)
        };

        await _auditRepository.AddAsync(auditEntry);
    }
}

public enum MfaEventType
{
    Enabled,
    Disabled,
    CodeGenerated,
    CodeValidated,
    CodeFailed,
    BackupCodesGenerated,
    BackupCodeUsed,
    Recovery
}
```

**Exemplos**:
- 2025-12-28 10:30: Usuário ativar MFA → Auditado até 2030-12-28
- 2025-12-28 10:45: IP 192.168.1.1 bloqueado → Auditado até 2030-12-28
- 2025-12-28 14:20: Acesso anômalo de São Paulo (após histórico apenas SP) → Auditado até 2030-12-28

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `ic1` (SQL Server 2019)

**Tabelas Relacionadas**:

```sql
-- Tabela de Usuários (RF012)
CREATE TABLE [dbo].[USER](
    [ID_USER] [int] IDENTITY(1,1) NOT NULL,
    [EMAIL] [varchar](255) NOT NULL,
    [PASSWORD_HASH] [varchar](max) NOT NULL,
    [IS_ACTIVE] [bit] NOT NULL DEFAULT 1,
    [LAST_LOGIN_AT] [datetime] NULL,
    [CREATED_AT] [datetime] NOT NULL DEFAULT GETUTCDATE(),
    [UPDATED_AT] [datetime] NULL,
    CONSTRAINT [PK_USER] PRIMARY KEY CLUSTERED ([ID_USER] ASC)
)

-- Tabela de Faturas (RF026)
CREATE TABLE [dbo].[INVOICE](
    [ID_INVOICE] [int] IDENTITY(1,1) NOT NULL,
    [NUMBER] [varchar](50) NOT NULL,
    [AMOUNT] [decimal](18,2) NOT NULL,
    [STATUS] [varchar](20) NOT NULL,
    [CONSUMER_ID] [int] NOT NULL,
    [ISSUE_DATE] [datetime] NOT NULL,
    [DUE_DATE] [datetime] NOT NULL,
    CONSTRAINT [PK_INVOICE] PRIMARY KEY CLUSTERED ([ID_INVOICE] ASC),
    CONSTRAINT [FK_INVOICE_CONSUMER] FOREIGN KEY ([CONSUMER_ID])
        REFERENCES [dbo].[CONSUMER]([ID_CONSUMER])
)

-- Novos para RF108
CREATE TABLE [dbo].[MFA_CONFIG](
    [ID_MFA] [int] IDENTITY(1,1) NOT NULL,
    [USER_ID] [int] NOT NULL,
    [MFA_TYPE] [varchar](20) NOT NULL, -- 'SMS', 'EMAIL', 'TOTP'
    [PHONE_NUMBER] [varchar](20) NULL,
    [TOTP_SECRET] [varchar](max) NULL,
    [IS_ENABLED] [bit] NOT NULL DEFAULT 0,
    [CREATED_AT] [datetime] NOT NULL,
    [VERIFIED_AT] [datetime] NULL,
    CONSTRAINT [PK_MFA_CONFIG] PRIMARY KEY CLUSTERED ([ID_MFA] ASC),
    CONSTRAINT [FK_MFA_CONFIG_USER] FOREIGN KEY ([USER_ID])
        REFERENCES [dbo].[USER]([ID_USER])
)

CREATE TABLE [dbo].[CONTESTATION](
    [ID_CONTESTATION] [int] IDENTITY(1,1) NOT NULL,
    [INVOICE_ID] [int] NOT NULL,
    [USER_ID] [int] NOT NULL,
    [JUSTIFICATION] [varchar](max) NOT NULL,
    [STATUS] [varchar](20) NOT NULL DEFAULT 'PENDING',
    [APPROVED_BY_ID] [int] NULL,
    [APPROVED_AT] [datetime] NULL,
    [REJECTION_REASON] [varchar](max) NULL,
    [CREATED_AT] [datetime] NOT NULL,
    CONSTRAINT [PK_CONTESTATION] PRIMARY KEY CLUSTERED ([ID_CONTESTATION] ASC),
    CONSTRAINT [FK_CONTESTATION_INVOICE] FOREIGN KEY ([INVOICE_ID])
        REFERENCES [dbo].[INVOICE]([ID_INVOICE]),
    CONSTRAINT [FK_CONTESTATION_USER] FOREIGN KEY ([USER_ID])
        REFERENCES [dbo].[USER]([ID_USER]),
    CONSTRAINT [FK_CONTESTATION_APPROVER] FOREIGN KEY ([APPROVED_BY_ID])
        REFERENCES [dbo].[USER]([ID_USER])
)

CREATE TABLE [dbo].[IP_BLOCK](
    [ID_IP_BLOCK] [int] IDENTITY(1,1) NOT NULL,
    [IP_ADDRESS] [varchar](45) NOT NULL,
    [REASON] [varchar](max) NOT NULL,
    [BLOCKED_AT] [datetime] NOT NULL DEFAULT GETUTCDATE(),
    [UNBLOCK_AT] [datetime] NULL,
    [BLOCK_TYPE] [varchar](20) NOT NULL, -- 'AUTOMATIC', 'MANUAL'
    [STATUS] [varchar](20) NOT NULL DEFAULT 'ACTIVE',
    CONSTRAINT [PK_IP_BLOCK] PRIMARY KEY CLUSTERED ([ID_IP_BLOCK] ASC)
)

CREATE TABLE [dbo].[USER_DEVICE](
    [ID_DEVICE] [int] IDENTITY(1,1) NOT NULL,
    [USER_ID] [int] NOT NULL,
    [FINGERPRINT_HASH] [varchar](max) NOT NULL,
    [LAST_ACCESS_AT] [datetime] NULL,
    [IS_TRUSTED] [bit] NOT NULL DEFAULT 0,
    [DEVICE_NAME] [varchar](255) NULL,
    [USER_AGENT] [varchar](max) NULL,
    CONSTRAINT [PK_USER_DEVICE] PRIMARY KEY CLUSTERED ([ID_DEVICE] ASC),
    CONSTRAINT [FK_USER_DEVICE_USER] FOREIGN KEY ([USER_ID])
        REFERENCES [dbo].[USER]([ID_USER])
)

CREATE TABLE [dbo].[AUDIT_LOG](
    [ID_AUDIT] [int] IDENTITY(1,1) NOT NULL,
    [USER_ID] [int] NULL,
    [OPERATION] [varchar](100) NOT NULL,
    [ENTITY] [varchar](50) NOT NULL,
    [ENTITY_ID] [varchar](50) NULL,
    [IP_ADDRESS] [varchar](45) NULL,
    [DETAILS] [varchar](max) NULL,
    [TIMESTAMP] [datetime] NOT NULL DEFAULT GETUTCDATE(),
    [RETENTION_UNTIL] [datetime] NOT NULL,
    CONSTRAINT [PK_AUDIT_LOG] PRIMARY KEY CLUSTERED ([ID_AUDIT] ASC)
)
```

**Campos Importantes**:

| Campo Legado | Descrição | Uso no Modernizado |
|--------------|-----------|-------------------|
| `[USER].[ID_USER]` | ID único do usuário | Mapeado para `User.Id` (GUID) |
| `[INVOICE].[ID_INVOICE]` | ID único da fatura | Mapeado para `Invoice.Id` (GUID) |
| `[CONTESTATION].[STATUS]` | Status da contestação | Enum: Pending, Approved, Rejected |
| `[MFA_CONFIG].[MFA_TYPE]` | Tipo de MFA (SMS/EMAIL/TOTP) | Enum: Sms, Email, Totp |

---

### 3.2 Stored Procedures Legado

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `pa_USER_LOGIN` | Autentica usuário | Migrado para `AuthenticationService` |
| `pa_INVOICE_GET_PENDING` | Lista faturas pendentes | Migrado para `InvoiceQuery` (CQRS) |
| `pa_AUDIT_LOG_INSERT` | Registra auditoria | Migrado para `AuditRepository` |

---

### 3.3 Telas ASPX Legado

| Página | Descrição | Tela Moderna |
|--------|-----------|--------------|
| `login.aspx` | Login com CAPTCHA v2 | `/auth/login` (Angular) com reCAPTCHA v3 |
| `contestacao.aspx` | Contestação de fatura | `/contestacoes` (Angular) com workflow |
| `ip-bloqueados.aspx` | Gestão manual de IPs | `/seguranca/ips-bloqueados` (Angular) |

---

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSSeguranca.asmx.vb`

| Método | Descrição | Endpoint Moderno |
|--------|-----------|-----------------|
| `ValidarCaptcha()` | Valida reCAPTCHA | `POST /api/seguranca/captcha/validar` |
| `GerarCodigoMfa()` | Gera código MFA | `POST /api/seguranca/mfa/enviar-sms` |
| `ListarIpsBloqueados()` | Lista IPs bloqueados | `GET /api/seguranca/ips-bloqueados` |

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `SECURITY_ADVANCED`

**Configuração**:
```json
{
    "featureKey": "SECURITY_ADVANCED",
    "nome": "Segurança Avançada (CAPTCHA, MFA, Anti-fraude)",
    "descricao": "Ativa CAPTCHA, MFA, contestação de faturas e análise comportamental",
    "habilitado": true,
    "isSystemFeature": true,
    "subFeatures": [
        {
            "key": "CAPTCHA_RECAPTCHA_V3",
            "nome": "CAPTCHA - Google reCAPTCHA v3",
            "habilitado": true
        },
        {
            "key": "MFA_SMS",
            "nome": "MFA - SMS (Twilio)",
            "habilitado": true
        },
        {
            "key": "MFA_EMAIL",
            "nome": "MFA - Email (SendGrid)",
            "habilitado": true
        },
        {
            "key": "MFA_TOTP",
            "nome": "MFA - TOTP (Google Authenticator)",
            "habilitado": true
        },
        {
            "key": "CONTESTACAO_WORKFLOW",
            "nome": "Contestação de Faturas com Workflow",
            "habilitado": true
        },
        {
            "key": "RATE_LIMITING",
            "nome": "Rate Limiting por IP/Usuário",
            "habilitado": true
        },
        {
            "key": "IP_BLOCKING",
            "nome": "Bloqueio Automático de IPs",
            "habilitado": true
        },
        {
            "key": "DEVICE_FINGERPRINTING",
            "nome": "Device Fingerprinting",
            "habilitado": true
        },
        {
            "key": "UEBA_ANALYTICS",
            "nome": "UEBA - Análise Comportamental",
            "habilitado": true
        }
    ]
}
```

**Nota**: Todas as sub-features podem ser desabilitadas individualmente para permitir rollout gradual. Se a feature principal está desabilitada, nenhuma funcionalidade de segurança avançada ativa.

---

### 4.2 Internacionalização (i18n)

**Chaves de Tradução**:

```json
{
    "security": {
        "captcha": {
            "title": "Verificação de Segurança",
            "message": "Por favor, complete a verificação de reCAPTCHA",
            "error": "Falha na verificação de reCAPTCHA. Tente novamente.",
            "required": "Verificação reCAPTCHA é obrigatória"
        },
        "mfa": {
            "title": "Autenticação Multi-Fator",
            "subtitle": "Escolha um método de autenticação",
            "sms": "Código enviado via SMS",
            "email": "Código enviado via email",
            "totp": "Digite o código do seu autenticador",
            "codeLabel": "Código de 6 dígitos",
            "codePlaceholder": "000000",
            "send": "Enviar código",
            "verify": "Verificar",
            "resend": "Reenviar código em {seconds}s",
            "invalidCode": "Código inválido ou expirado",
            "successMessage": "Autenticação bem-sucedida",
            "totpSetup": "Configure seu autenticador",
            "totpInstructions": "Escaneie o código QR com seu autenticador ou insira a chave manualmente",
            "backupCodes": "Códigos de recuperação",
            "setupRequired": "MFA é obrigatório para seu perfil"
        },
        "contestacao": {
            "title": "Contestar Fatura",
            "subtitle": "Explique por que está contestando esta fatura",
            "invoiceNumber": "Número da fatura",
            "invoiceAmount": "Valor da fatura",
            "justification": "Justificativa",
            "justificationPlaceholder": "Descreva por que está contestando...",
            "minCharacters": "Mínimo de {min} caracteres",
            "submit": "Enviar contestação",
            "success": "Contestação enviada com sucesso",
            "error": "Erro ao enviar contestação",
            "status": {
                "pending": "Pendente",
                "approved": "Aprovada",
                "rejected": "Rejeitada"
            }
        },
        "ipBlocking": {
            "title": "Segurança - IPs Bloqueados",
            "ipAddress": "Endereço IP",
            "reason": "Motivo do bloqueio",
            "blockedAt": "Data do bloqueio",
            "unblockAt": "Data de desbloqueio",
            "blockType": "Tipo de bloqueio",
            "status": "Status",
            "unblock": "Desbloquear",
            "autoUnblocked": "Desbloqueado automaticamente"
        },
        "anomalousAccess": {
            "title": "Alerta de Acesso",
            "message": "Detectamos um acesso ao seu account de um novo local/dispositivo",
            "location": "Local",
            "device": "Dispositivo",
            "time": "Horário",
            "approve": "Aprovar acesso",
            "block": "Bloquear acesso"
        }
    }
}
```

---

### 4.3 Auditoria

**Operações Auditadas**:

| Operação | Codigo | Dados Registrados |
|----------|--------|-------------------|
| CAPTCHA validado | `SEC_CAPTCHA_VALIDATE` | Token, resultado, IP |
| MFA ativado | `SEC_MFA_ENABLE` | Tipo, phone/email, UserId |
| MFA código gerado | `SEC_MFA_CODE_GENERATE` | Tipo, UserId, método |
| MFA código validado | `SEC_MFA_CODE_VALIDATE` | Tipo, sucesso/falha |
| Contestação criada | `SEC_CONTESTACAO_CREATE` | InvoiceId, justificativa |
| Contestação aprovada | `SEC_CONTESTACAO_APPROVE` | ApprovedBy, resultado |
| IP bloqueado | `SEC_IP_BLOCKED` | IP, razão, duração |
| IP desbloqueado | `SEC_IP_UNBLOCKED` | IP, motivo |
| Acesso anômalo | `SEC_ANOMALOUS_ACCESS` | UserId, localização, dispositivo |
| Device fingerprint | `SEC_DEVICE_FINGERPRINT` | Hash, confiança, dispositivo |

**Retenção**: 5 anos (conforme LGPD Artigo 16)

---

### 4.4 Controle de Acesso (RBAC)

**Permissões**:

| Permissão | Descrição | Perfis |
|-----------|-----------|--------|
| `security:captcha:read` | Visualizar config CAPTCHA | Admin, Auditor |
| `security:captcha:update` | Alterar config CAPTCHA | Admin |
| `security:mfa:manage` | Gerenciar MFA de usuários | Admin, Gestor |
| `security:mfa:enable` | Ativar/desativar próprio MFA | Todos |
| `security:contestacao:create` | Criar contestação | Gestor, Operador |
| `security:contestacao:read` | Visualizar contestação | Admin, Gestor, Auditor |
| `security:contestacao:approve` | Aprovar contestação | Gestor, Admin |
| `security:ip:read` | Visualizar IPs bloqueados | Admin, Auditor |
| `security:ip:update` | Bloquear/desbloquear IP | Admin |
| `security:device:read` | Visualizar dispositivos confiáveis | Próprio usuário, Admin |
| `security:device:manage` | Gerenciar dispositivos confiáveis | Próprio usuário, Admin |
| `security:audit:read` | Visualizar auditoria de segurança | Admin, Auditor |

**Nota**: Usuários com MFA obrigatório não podem desativar MFA sem aprovação de Admin.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD - CAPTCHA

| Metodo | Endpoint | Descrição | Permissão | Autenticação |
|--------|----------|-----------|-----------|---------------|
| GET | `/api/seguranca/captcha` | Obter config reCAPTCHA | `security:captcha:read` | JWT |
| PUT | `/api/seguranca/captcha` | Atualizar config reCAPTCHA | `security:captcha:update` | JWT |
| POST | `/api/seguranca/captcha/validar` | Validar token reCAPTCHA | Pública | IP |

### 5.2 CRUD - MFA

| Metodo | Endpoint | Descrição | Permissão | Autenticação |
|--------|----------|-----------|-----------|---------------|
| GET | `/api/seguranca/mfa` | Obter status MFA do usuário | `security:mfa:enable` | JWT |
| POST | `/api/seguranca/mfa/ativar` | Ativar MFA (retorna QR code) | `security:mfa:enable` | JWT |
| POST | `/api/seguranca/mfa/desativar` | Desativar MFA | `security:mfa:enable` | JWT |
| POST | `/api/seguranca/mfa/enviar-sms` | Enviar código SMS | `security:mfa:enable` | JWT |
| POST | `/api/seguranca/mfa/enviar-email` | Enviar código email | `security:mfa:enable` | JWT |
| POST | `/api/seguranca/mfa/validar` | Validar código MFA | Pública | IP |
| POST | `/api/seguranca/mfa/backup-codes` | Gerar códigos de backup | `security:mfa:enable` | JWT |
| GET | `/api/seguranca/mfa/dispositivos` | Listar dispositivos confiáveis | `security:device:read` | JWT |

### 5.3 CRUD - Contestação

| Metodo | Endpoint | Descrição | Permissão | Autenticação |
|--------|----------|-----------|-----------|---------------|
| GET | `/api/seguranca/contestacao` | Listar contestações | `security:contestacao:read` | JWT |
| GET | `/api/seguranca/contestacao/{id}` | Obter contestação | `security:contestacao:read` | JWT |
| POST | `/api/seguranca/contestacao` | Criar contestação | `security:contestacao:create` | JWT |
| PUT | `/api/seguranca/contestacao/{id}/aprovar` | Aprovar contestação | `security:contestacao:approve` | JWT |
| PUT | `/api/seguranca/contestacao/{id}/rejeitar` | Rejeitar contestação | `security:contestacao:approve` | JWT |
| GET | `/api/seguranca/contestacao/{id}/historico` | Obter histórico aprovações | `security:contestacao:read` | JWT |

### 5.4 CRUD - IP Blocking

| Metodo | Endpoint | Descrição | Permissão | Autenticação |
|--------|----------|-----------|-----------|---------------|
| GET | `/api/seguranca/ips` | Listar IPs bloqueados | `security:ip:read` | JWT |
| GET | `/api/seguranca/ips/{ip}` | Obter detalhes IP | `security:ip:read` | JWT |
| POST | `/api/seguranca/ips/bloquear` | Bloquear IP manualmente | `security:ip:update` | JWT |
| PUT | `/api/seguranca/ips/{ip}/desbloquear` | Desbloquear IP | `security:ip:update` | JWT |
| POST | `/api/seguranca/ips/whitelist` | Adicionar IP à whitelist | `security:ip:update` | JWT |
| POST | `/api/seguranca/ips/blacklist` | Adicionar IP à blacklist | `security:ip:update` | JWT |
| GET | `/api/seguranca/ips-suspeitos` | Listar IPs com comportamento suspeito | `security:ip:read` | JWT |

### 5.5 CRUD - Auditoria

| Metodo | Endpoint | Descrição | Permissão | Autenticação |
|--------|----------|-----------|-----------|---------------|
| GET | `/api/seguranca/auditoria` | Listar eventos de auditoria | `security:audit:read` | JWT |
| GET | `/api/seguranca/auditoria/usuario/{userId}` | Auditoria por usuário | `security:audit:read` | JWT |
| GET | `/api/seguranca/auditoria/ip/{ip}` | Auditoria por IP | `security:audit:read` | JWT |
| GET | `/api/seguranca/auditoria/exportar` | Exportar auditoria (CSV/PDF) | `security:audit:read` | JWT |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Login com CAPTCHA e MFA

```
Usuário acessa /auth/login
    |
    v
[Frontend carrega reCAPTCHA v3 invisível]
    |
    v
Usuário digita Email e Senha
    |
    v
[Client envia: email, password, recaptchaToken]
    |
    v
[Backend verifica CAPTCHA]
    +--- Score < 0.5 (suspeito) ---> HTTP 400 "CAPTCHA Failed"
    |
    v (Score >= 0.5)
[Backend verifica login failures]
    +--- > 3 falhas em 10min ---> Requer CAPTCHA manual
    |
    v
[Backend valida email/password]
    +--- Credenciais inválidas ---> Registra falha, HTTP 401
    |
    v (Credenciais válidas)
[Backend verifica se MFA obrigatório]
    +--- Sim e não ativado ---> HTTP 403 "MFA Required"
    |
    v (MFA não obrigatório OU já ativado)
[Backend verifica se MFA ativado]
    +--- Não ---> Gera JWT, Login bem-sucedido
    |
    v (Sim)
[Backend envia código MFA (SMS/Email/TOTP)]
    |
    v
[Usuário digita código MFA]
    |
    v
[Backend valida código]
    +--- Inválido ---> HTTP 400 "Invalid MFA Code"
    |
    v (Válido)
[Backend valida Device Fingerprint]
    +--- Dispositivo novo ---> Envia notificação de alerta
    |
    v
[Backend faz check UEBA]
    +--- Localização anômala ---> HTTP 403 "Anomalous Access"
    |
    v (Aprovado)
[Gera JWT, registra login bem-sucedido, retorna token]
```

### 6.2 Fluxo de Contestação de Fatura

```
Usuário acessa /contestacoes
    |
    v
[Lista suas faturas pendentes]
    |
    v
Usuário clica em "Contestar"
    |
    v
[Abre modal de contestação]
    |
    v
Usuário escreve justificativa (50+ caracteres)
    |
    v
[Frontend valida tamanho e envia POST]
    |
    v
[Backend valida permissão: security:contestacao:create]
    +--- Sem permissão ---> HTTP 403
    |
    v (Autorizado)
[Backend valida comprimento justificativa]
    +--- < 50 caracteres ---> HTTP 400
    |
    v (Válido)
[Backend cria Contestation (Status: Pending)]
    |
    v
[Backend envia notificação aos Gestores]
    |
    v
[Registra auditoria: SEC_CONTESTACAO_CREATE]
    |
    v
[Retorna HTTP 201 + ID da contestação]
    |
    v
[Gestor vê notificação]
    |
    v
[Gestor acessa /contestacoes/pendentes]
    |
    v
[Clica em contestação para revisar]
    |
    v (Aprova)
[Clica "Aprovar" + adiciona comentário]
    |
    v
[Backend atualiza Status: Approved]
    |
    v
[Envia notificação ao solicitante]
    |
    v
[Registra auditoria: SEC_CONTESTACAO_APPROVE]
    |
    v (Rejeita)
[Clica "Rejeitar" + motivo obrigatório]
    |
    v
[Backend atualiza Status: Rejected]
    |
    v
[Envia notificação ao solicitante]
    |
    v
[Registra auditoria: SEC_CONTESTACAO_REJECT]
```

### 6.3 Fluxo de Detecção e Bloqueio de IP

```
Requisição chega ao middleware
    |
    v
[Extrai IP: 203.0.113.45]
    |
    v
[Verifica se IP está na blacklist]
    +--- Sim ---> HTTP 403 "IP Blocked"
    |
    v (Não)
[Verifica se IP está na whitelist]
    +--- Sim ---> Pula validações, processa requisição
    |
    v (Não)
[Conta requisições por segundo deste IP]
    +--- > 10 req/seg ---> Adiciona IP à blacklist por 60 minutos
                            HTTP 403 "Suspicious Activity Detected"
    |
    v (OK)
[Conta requisições por minuto deste IP]
    +--- > 100 req/min ---> HTTP 429 "Rate Limit Exceeded"
    |
    v (OK)
[Processa requisição normalmente]
    |
    v
[Monitora padrão de requisições em Redis]
    |
    v
[Se comportamento suspeito detectado]
    |
    +--- Registra em UEBA ---> Azure Application Insights
    |
    v
[Se muitas falhas de autenticação]
    |
    +--- Bloqueia IP automaticamente
    +--- Notifica Admin
    +--- Registra auditoria
```

---

## 7. SEGURANÇA

### 7.1 Proteções Implementadas

| Proteção | Descrição |
|----------|-----------|
| **reCAPTCHA v3** | Score-based CAPTCHA invisível para detectar bots |
| **MFA Multi-canal** | SMS, Email e TOTP para autenticação em dois fatores |
| **Rate Limiting** | Limite de 100 req/min por IP, 10 req/seg dispara bloqueio |
| **IP Blocking** | Bloqueio automático por DDoS, manual por admin, whitelist/blacklist |
| **Device Fingerprinting** | Identifica dispositivo, notifica se novo |
| **UEBA** | Análise comportamental via Azure Application Insights |
| **LGPD Audit Trail** | Auditoria completa com retenção de 5 anos |
| **JWT com RS256** | Tokens assinados com chave privada |
| **HTTPS obrigatório** | Todas as requisições via TLS 1.3 |
| **CORS restritivo** | Apenas domínios conhecidos |
| **CSP Headers** | Content Security Policy para prevenir XSS |
| **Senha não reversível** | Bcrypt com salt aleatório |

### 7.2 Testes de Segurança Obrigatórios

- [ ] SQL Injection em justificativa de contestação
- [ ] XSS em justificativa de contestação e comentários
- [ ] CSRF Protection em POST de contestação
- [ ] Validação de permissões em todos os endpoints
- [ ] Bloqueio de força bruta em /login (3+ falhas)
- [ ] Rate limiting realmente funciona (> 100 req/min = 429)
- [ ] DDoS detection funciona (> 10 req/seg = bloqueio IP)
- [ ] MFA obrigatório para Admin/Gestor/Auditor
- [ ] Device fingerprint detecta novo dispositivo
- [ ] UEBA detecta login de nova localização
- [ ] CAPTCHA é invisível (score-based) v3
- [ ] Auditoria registra TODOS os eventos de segurança
- [ ] JWT não pode ser falsificado (RS256)
- [ ] TOTP valida por exatamente 30 segundos (RFC 6238)
- [ ] SMS código válido por exatamente 5 minutos

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medição |
|-----|------|---------|
| **Ataques bloqueados/dia** | > 1.000 | Contador em Redis |
| **Tempo de resposta /login** | < 200ms | Application Insights |
| **Taxa de falso positivo MFA** | < 2% | Auditoria manual |
| **Taxa de aceitação CAPTCHA** | > 95% | reCAPTCHA Analytics |
| **Disponibilidade de MFA** | 99.9% | Uptime monitoring |
| **Latência de contestação (aprovação)** | < 24h | Relatório semanal |
| **Cobertura de UEBA** | 100% | % de usuários monitorados |
| **Detecção de anomalia (dias)** | < 1 dia | Tempo até notificação |

### 8.2 Alertas

| Alerta | Condição | Ação |
|--------|----------|------|
| **DDoS Detected** | > 1.000 requisições/segundo | Escalar para infraestrutura, bloquear IP automaticamente |
| **MFA Failure Rate Alta** | > 10% de falhas em 1h | Notificar suporte, verificar integração Twilio/SendGrid |
| **Anomalous Login Pattern** | > 5 logins diferentes locais/1h | Notificar usuário, bloquear automaticamente |
| **IP Bloqueado Legitimamente** | IP whitelist bloqueado > 3x | Remover de bloqueio automático |
| **Contestação não revisada** | Pendente > 48h | Notificar gestor responsável |

---

## 9. PRÓXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-RF108](./MD-RF108-CAPTCHA-MFA-Contestacao.md)
2. **Casos de Uso**: Criar [UC-RF108](./UC-RF108-CAPTCHA-MFA-Contestacao.md)
3. **Workflow**: Criar [WF-RF108](./WF-RF108-CAPTCHA-MFA-Contestacao.md)
4. **Testes**: Criar [TC-RF108-BACKEND.md](./TC-RF108-BACKEND.md)
5. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml)
6. **Implementação Backend**: Commands/Queries/Handlers + Controllers
7. **Implementação Frontend**: Telas de login, MFA, contestação, gestão de IPs
8. **Integração com reCAPTCHA v3**: Configurar chaves públicas/privadas
9. **Integração com Twilio**: Configurar SMS gateway
10. **Integração com SendGrid**: Configurar email gateway
11. **Integração com Azure Application Insights**: Configurar telemetria UEBA
12. **Testes E2E**: Executar cenários completos de login e contestação

---

## CHANGELOG

| Versão | Data | Descrição | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versão inicial com 10 RNs, 15 endpoints, integrações Google/Twilio/SendGrid | Claude Code |

---

**Última Atualização**: 2025-12-28
**Autor**: Claude Code (c) Anthropic
**Revisão**: Pendente

---

## Apêndices

### A. Integrações Técnicas

**Google reCAPTCHA v3**:
```
API Key (Site Key): [CONFIGURAR]
Secret Key: [CONFIGURAR]
Endpoint: https://www.google.com/recaptcha/api/siteverify
Score esperado: >= 0.5 (0 = bot, 1 = humano)
```

**Twilio SMS**:
```
Account SID: [CONFIGURAR]
Auth Token: [CONFIGURAR]
Phone Number: [CONFIGURAR]
API: https://api.twilio.com/2010-04-01
```

**SendGrid Email**:
```
API Key: [CONFIGURAR]
From Email: noreply@icontrolit.com
API: https://api.sendgrid.com/v3
```

**Azure Application Insights**:
```
Instrumentation Key: [CONFIGURAR]
UEBA Rules: Detectar login de nova localização, múltiplos IPs em curto período
```

### B. Padrões de Código

Todos os endpoints seguem Clean Architecture + CQRS:

```csharp
// Command para criar contestação
public class CreateContestationCommand : ICommand<ContestationId>
{
    public Guid UserId { get; set; }
    public Guid ClienteId { get; set; }
    public Guid InvoiceId { get; set; }
    public string Justification { get; set; }
}

// Handler implementa lógica
public class CreateContestationHandler
    : ICommandHandler<CreateContestationCommand, ContestationId>
{
    // Injeção de dependências + implementação
}

// Controller expõe endpoint
[ApiController]
[Route("api/seguranca/contestacao")]
public class ContestationController : ControllerBase
{
    [HttpPost]
    [Authorize(Policy = "security:contestacao:create")]
    public async Task<IActionResult> Create(CreateContestationCommand cmd)
    {
        var result = await _mediator.Send(cmd);
        return Created($"api/seguranca/contestacao/{result.Value}", result);
    }
}
```

---

**Total de linhas**: 1.450+ linhas

