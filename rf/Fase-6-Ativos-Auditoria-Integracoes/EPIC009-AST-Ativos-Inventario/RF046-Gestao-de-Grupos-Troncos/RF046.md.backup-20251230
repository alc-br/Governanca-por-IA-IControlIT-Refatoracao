# RF046 - Gest√£o de Grupos Troncos

**Fase:** Fase-2-Servicos-Essenciais
**EPIC:** EPIC003-GES-Gestao
**Requisito Funcional:** RF046
**Prioridade:** M√âDIA
**Complexidade:** ALTA
**Vers√£o:** 1.0
**Data:** 2025-01-14

---

## SE√á√ÉO 1 - VIS√ÉO GERAL

### 1.1 Descri√ß√£o Geral

O **RF046 - Gest√£o de Grupos Troncos** implementa um sistema completo de agrupamento l√≥gico e roteamento inteligente de linhas telef√¥nicas, chips SIM e ramais VoIP. Permite criar grupos hier√°rquicos de troncos com balanceamento de carga, failover autom√°tico, prioriza√ß√£o de rotas e monitoramento de sa√∫de em tempo real.

Este RF centraliza a gest√£o de conectividade de voz e dados, oferecendo:
- Agrupamento l√≥gico de troncos por regi√£o, operadora, tecnologia (SIP, E1, m√≥vel)
- Roteamento inteligente com LCR (Least Cost Routing)
- Balanceamento de carga com algoritmos configur√°veis (round-robin, least-used, weighted)
- Failover autom√°tico com health checks a cada 30s
- Prioriza√ß√£o de rotas por custo, qualidade, lat√™ncia
- Monitoramento de capacidade e uso (concurrent calls, bandwidth)
- Alertas de sobrecarga e indisponibilidade
- Estat√≠sticas de uso e performance por grupo
- Integra√ß√£o com PABX/SIP trunk via APIs

### 1.2 Import√¢ncia Estrat√©gica

**Benef√≠cios para o Neg√≥cio:**
- **Alta Disponibilidade:** Failover autom√°tico garante 99.9% de uptime em chamadas
- **Otimiza√ß√£o de Custos:** LCR reduz at√© 40% da conta telef√¥nica roteando por troncos mais baratos
- **Escalabilidade:** Adicionar novos troncos sem reconfigura√ß√£o de ramais
- **Visibilidade Total:** Monitoramento em tempo real de sa√∫de e uso de cada tronco
- **Resili√™ncia:** M√∫ltiplas rotas de sa√≠da previnem SPOF (single point of failure)

**Impacto Operacional:**
- Redu√ß√£o de 90% em chamadas perdidas por falha de tronco
- Economia de 35-40% em custos de telefonia com LCR autom√°tico
- Tempo de recupera√ß√£o de falha < 30s (antes: manual, 15-30min)
- Identifica√ß√£o de gargalos de capacidade com 7 dias de anteced√™ncia
- Provisionamento de novo tronco em < 5min (antes: 2-4h)

### 1.3 Sistema Legado vs Modernizado

#### Sistema Legado (ASP.NET Web Forms)

**Limita√ß√µes Cr√≠ticas:**
- ‚ùå Roteamento est√°tico hardcoded no PABX (sem failover autom√°tico)
- ‚ùå Sem balanceamento de carga (sempre usa mesmo tronco at√© falhar)
- ‚ùå Altera√ß√µes de roteamento exigem reinicializa√ß√£o do sistema
- ‚ùå Sem monitoramento de sa√∫de de troncos
- ‚ùå Falhas detectadas apenas quando cliente reclama de "telefone n√£o funciona"
- ‚ùå LCR manual via planilha Excel (desatualizada)
- ‚ùå Sem hist√≥rico de failovers ou m√©tricas de uso
- ‚ùå Imposs√≠vel priorizar troncos por qualidade/custo

**Problemas Recorrentes:**
- Tronco principal falha ‚Üí 100% das chamadas caem at√© interven√ß√£o manual
- Sobrecarga de tronco (concurrent calls > limite) ‚Üí chamadas derrubadas
- Roteamento sub√≥timo ‚Üí usando tronco caro quando h√° alternativa barata dispon√≠vel
- Sem visibilidade de uso ‚Üí imposs√≠vel planejar capacidade

**Arquivos Legados Principais:**
```
ic1_legado/IControlIT/
‚îú‚îÄ‚îÄ Telecom/
‚îÇ   ‚îú‚îÄ‚îÄ CadastroTroncos.aspx (CRUD b√°sico)
‚îÇ   ‚îî‚îÄ‚îÄ ConfiguracaoRoteamento.aspx (roteamento est√°tico)
‚îî‚îÄ‚îÄ App_Code/
    ‚îî‚îÄ‚îÄ Helpers/TroncoHelper.vb (sem l√≥gica de failover)
```

#### Sistema Modernizado (.NET 10 + Angular 19)

**Melhorias Implementadas:**
- ‚úÖ **Agrupamento Hier√°rquico:** Grupos de troncos com prioriza√ß√£o e peso
- ‚úÖ **Failover Autom√°tico:** Health check a cada 30s + roteamento autom√°tico
- ‚úÖ **LCR Din√¢mico:** Algoritmo que escolhe rota mais barata em tempo real
- ‚úÖ **Balanceamento de Carga:** Round-robin, least-used, weighted distribution
- ‚úÖ **Monitoramento Real-Time:** SignalR para status de sa√∫de, uso, lat√™ncia
- ‚úÖ **Prioriza√ß√£o Inteligente:** Por custo, qualidade (MOS), lat√™ncia, disponibilidade
- ‚úÖ **Alertas Proativos:** Notifica√ß√£o antes de atingir limite de capacidade
- ‚úÖ **API de Integra√ß√£o:** Webhooks para PABX/SIP trunk providers
- ‚úÖ **Hist√≥rico Completo:** 7 anos de logs de failover, uso, performance

**Arquitetura Clean + CQRS:**
```
backend/IControlIT.API/src/
‚îú‚îÄ‚îÄ Domain/Entities/
‚îÇ   ‚îú‚îÄ‚îÄ GrupoTronco.cs (grupo l√≥gico)
‚îÇ   ‚îú‚îÄ‚îÄ Tronco.cs (tronco individual - SIP, E1, m√≥vel)
‚îÇ   ‚îú‚îÄ‚îÄ TroncoRota.cs (rota de roteamento)
‚îÇ   ‚îú‚îÄ‚îÄ TroncoHealthCheck.cs (hist√≥rico de health checks)
‚îÇ   ‚îî‚îÄ‚îÄ TroncoUso.cs (estat√≠sticas de uso)
‚îú‚îÄ‚îÄ Application/
‚îÇ   ‚îú‚îÄ‚îÄ GruposTroncos/Commands/ (criar, atualizar, failover)
‚îÇ   ‚îú‚îÄ‚îÄ GruposTroncos/Queries/ (consultas otimizadas)
‚îÇ   ‚îî‚îÄ‚îÄ GruposTroncos/Services/
‚îÇ       ‚îú‚îÄ‚îÄ TroncoRoutingService.cs (LCR, balanceamento)
‚îÇ       ‚îú‚îÄ‚îÄ TroncoHealthCheckService.cs (monitoramento)
‚îÇ       ‚îî‚îÄ‚îÄ TroncoFailoverService.cs (failover autom√°tico)
‚îú‚îÄ‚îÄ Infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ BackgroundJobs/TroncoHealthCheckJob.cs (Hangfire, 30s)
‚îÇ   ‚îî‚îÄ‚îÄ ExternalServices/PABXService.cs (integra√ß√£o PABX)
‚îî‚îÄ‚îÄ Web/Endpoints/GruposTroncosEndpoints.cs

frontend/icontrolit-app/src/app/modules/gestao/grupos-troncos/
‚îú‚îÄ‚îÄ grupos-list/ (listagem de grupos)
‚îú‚îÄ‚îÄ grupo-detail/ (visualiza√ß√£o + dashboard de sa√∫de)
‚îú‚îÄ‚îÄ grupo-form/ (cria√ß√£o/edi√ß√£o)
‚îú‚îÄ‚îÄ rotas/ (configura√ß√£o de roteamento)
‚îî‚îÄ‚îÄ services/grupos-troncos.service.ts
```

### 1.4 Funcionalidades Principais

#### 1.4.1 Gerenciamento de Grupos de Troncos

**Estrutura Hier√°rquica:**
```
Grupo Principal: "Telefonia Corporativa"
‚îú‚îÄ‚îÄ Grupo Regional: "S√£o Paulo"
‚îÇ   ‚îú‚îÄ‚îÄ Tronco SIP: Operadora A (prioridade 1, peso 70%)
‚îÇ   ‚îú‚îÄ‚îÄ Tronco SIP: Operadora B (prioridade 2, peso 30%)
‚îÇ   ‚îî‚îÄ‚îÄ Tronco E1: Backup (prioridade 3, apenas failover)
‚îú‚îÄ‚îÄ Grupo Regional: "Rio de Janeiro"
‚îÇ   ‚îú‚îÄ‚îÄ Tronco SIP: Operadora C (prioridade 1)
‚îÇ   ‚îî‚îÄ‚îÄ Tronco M√≥vel: 4G LTE (failover)
‚îî‚îÄ‚îÄ Grupo Regional: "Demais Regi√µes"
    ‚îî‚îÄ‚îÄ Tronco SIP: Operadora Nacional (catch-all)
```

**Campos de um Grupo:**
```typescript
interface GrupoTronco {
  id: string;
  nome: string;
  descricao: string;
  tipo: 'GEOGRAFICO' | 'OPERADORA' | 'TECNOLOGIA' | 'CUSTO' | 'QUALIDADE';
  algoritmoBalanceamento: 'ROUND_ROBIN' | 'LEAST_USED' | 'WEIGHTED' | 'PRIORITY' | 'LCR';
  failoverAutomatico: boolean;
  tempoHealthCheck: number; // segundos (default: 30s)
  limitesConcurrentCalls: number;
  limiteBandwidth: number; // Mbps
  troncos: Tronco[]; // ordenados por prioridade
  ativo: boolean;
}

interface Tronco {
  id: string;
  grupoId: string;
  nome: string;
  tipo: 'SIP' | 'E1' | 'MOVEL_4G' | 'ISDN' | 'ANALOGICO';
  provider: string; // Operadora A, Vivo, Claro, etc.
  endpoint: string; // sip:trunk@operadora.com, n√∫mero E1
  prioridade: number; // 1 = maior prioridade
  peso: number; // % de tr√°fego (se weighted balancing)
  custoPorMinuto: number; // R$ para LCR
  qualidadeMOS: number; // Mean Opinion Score (1-5)
  latenciaMedia: number; // ms
  status: 'ATIVO' | 'INATIVO' | 'FALHA' | 'MANUTENCAO';
  capacidadeMaxima: number; // concurrent calls
  usoAtual: number; // calls em andamento
}
```

#### 1.4.2 Algoritmos de Roteamento

**1. Round-Robin (Distribui√ß√£o Igualit√°ria):**
```
Chamada 1 ‚Üí Tronco A
Chamada 2 ‚Üí Tronco B
Chamada 3 ‚Üí Tronco C
Chamada 4 ‚Üí Tronco A (volta ao in√≠cio)
```

**2. Least-Used (Menor Uso Atual):**
```
Tronco A: 5 calls ativas
Tronco B: 2 calls ativas ‚Üê escolhido
Tronco C: 8 calls ativas
```

**3. Weighted (Distribui√ß√£o Ponderada):**
```
Tronco A: peso 70% ‚Üí 7 de cada 10 chamadas
Tronco B: peso 20% ‚Üí 2 de cada 10 chamadas
Tronco C: peso 10% ‚Üí 1 de cada 10 chamadas
```

**4. Priority (Prioridade Estrita):**
```
Usa sempre prioridade 1 enquanto dispon√≠vel
Se prioridade 1 falhar ‚Üí prioridade 2
Se prioridade 2 falhar ‚Üí prioridade 3
```

**5. LCR - Least Cost Routing (Menor Custo):**
```csharp
public class LCRService
{
    public Tronco SelectTronco(string numeroDestino, List<Tronco> troncos)
    {
        // Filtra troncos dispon√≠veis e com capacidade
        var disponiveis = troncos
            .Where(t => t.Status == "ATIVO" && t.UsoAtual < t.CapacidadeMaxima)
            .ToList();

        if (!disponiveis.Any()) return null;

        // Identifica tipo de chamada (local, DDD, DDI, m√≥vel, fixo)
        var tipoChamada = ClassificarChamada(numeroDestino);

        // Calcula custo por tronco baseado em tabela de tarifa√ß√£o
        var custos = disponiveis.Select(t => new {
            Tronco = t,
            Custo = CalcularCusto(t, tipoChamada, numeroDestino)
        }).ToList();

        // Retorna tronco mais barato com qualidade m√≠nima (MOS ‚â• 3.5)
        return custos
            .Where(c => c.Tronco.QualidadeMOS >= 3.5)
            .OrderBy(c => c.Custo)
            .FirstOrDefault()?.Tronco;
    }

    private decimal CalcularCusto(Tronco tronco, TipoChamada tipo, string destino)
    {
        // L√≥gica de c√°lculo baseada em:
        // - Tarifa por minuto do tronco
        // - Tipo de chamada (local < DDD < DDI < m√≥vel)
        // - Hor√°rio (pico vs fora de pico)
        // - Destino espec√≠fico (tarifas diferenciadas)
        return tronco.CustoPorMinuto * GetMultiplicadorTipo(tipo);
    }
}
```

#### 1.4.3 Health Checks e Failover Autom√°tico

**Hangfire Job - Health Check a cada 30s:**
```csharp
[AutomaticRetry(Attempts = 0)] // N√£o retenta, pr√≥ximo cycle em 30s
public class TroncoHealthCheckJob : IJob
{
    public async Task Execute()
    {
        var troncos = await _context.Troncos
            .Where(t => t.Ativo)
            .ToListAsync();

        foreach (var tronco in troncos)
        {
            var healthResult = await PerformHealthCheck(tronco);

            // Salva resultado hist√≥rico
            await _context.TroncoHealthCheck.AddAsync(new TroncoHealthCheck {
                TroncoId = tronco.Id,
                Timestamp = DateTime.UtcNow,
                Status = healthResult.IsHealthy ? "OK" : "FAIL",
                Latencia = healthResult.Latency,
                PacketLoss = healthResult.PacketLoss,
                Jitter = healthResult.Jitter
            });

            // Atualiza status do tronco
            if (tronco.Status == "ATIVO" && !healthResult.IsHealthy)
            {
                // Detectou falha ‚Üí trigger failover
                await TriggerFailover(tronco);
            }
            else if (tronco.Status == "FALHA" && healthResult.IsHealthy)
            {
                // Tronco recuperou ‚Üí restaura
                await RestoreTronco(tronco);
            }
        }

        await _context.SaveChangesAsync();
    }

    private async Task<HealthResult> PerformHealthCheck(Tronco tronco)
    {
        switch (tronco.Tipo)
        {
            case "SIP":
                return await SIPOptionsRequest(tronco.Endpoint);
            case "E1":
                return await E1LoopbackTest(tronco.Endpoint);
            case "MOVEL_4G":
                return await PingTest(tronco.Endpoint);
            default:
                return HealthResult.Unknown();
        }
    }
}
```

**L√≥gica de Failover:**
```csharp
public class TroncoFailoverService
{
    public async Task TriggerFailover(Tronco troncoFalho)
    {
        var grupo = await _context.GruposTroncos
            .Include(g => g.Troncos)
            .FirstAsync(g => g.Id == troncoFalho.GrupoId);

        // Marca tronco como em falha
        troncoFalho.Status = "FALHA";

        // Busca pr√≥ximo tronco na hierarquia de prioridade
        var troncoBackup = grupo.Troncos
            .Where(t => t.Prioridade > troncoFalho.Prioridade && t.Status == "ATIVO")
            .OrderBy(t => t.Prioridade)
            .FirstOrDefault();

        if (troncoBackup == null)
        {
            // Sem backup dispon√≠vel ‚Üí alerta cr√≠tico
            await _alertService.NotifyAsync(new Alert {
                Severidade = "CRITICA",
                Titulo = $"Grupo {grupo.Nome} sem troncos dispon√≠veis",
                Mensagem = $"Tronco {troncoFalho.Nome} falhou e n√£o h√° backup dispon√≠vel"
            });
            return;
        }

        // Redireciona tr√°fego para backup
        await _pabxService.UpdateRouting(grupo.Id, troncoBackup.Id);

        // Log de failover
        await _context.TroncoFailoverLog.AddAsync(new TroncoFailoverLog {
            TroncoOrigemId = troncoFalho.Id,
            TroncoDestinoId = troncoBackup.Id,
            Timestamp = DateTime.UtcNow,
            Motivo = "HEALTH_CHECK_FAILED"
        });

        // Notifica administradores
        await _alertService.NotifyAsync(new Alert {
            Severidade = "ALTA",
            Titulo = $"Failover autom√°tico executado",
            Mensagem = $"Tronco {troncoFalho.Nome} ‚Üí {troncoBackup.Nome}"
        });

        await _context.SaveChangesAsync();
    }
}
```

#### 1.4.4 Monitoramento de Uso e Capacidade

**M√©tricas em Tempo Real (SignalR):**
- Concurrent calls atual vs limite
- Bandwidth consumido (Mbps)
- Lat√™ncia m√©dia (ms)
- Packet loss (%)
- Jitter (ms)
- MOS (Mean Opinion Score) - qualidade de voz
- Taxa de chamadas completadas vs abandonadas

**Dashboard de Sa√∫de do Grupo:**
```typescript
interface GrupoStatus {
  grupoId: string;
  nome: string;
  statusGeral: 'SAUDAVEL' | 'ALERTA' | 'CRITICO' | 'INATIVO';
  troncosAtivos: number;
  troncosTotal: number;
  concurrentCalls: number;
  capacidadeTotal: number;
  percentualUso: number; // concurrent calls / capacidade
  latenciaMedia: number;
  qualidadeMediaMOS: number;
  ultimoFailover: DateTime | null;
  alertasAtivos: Alert[];
}
```

**Visualiza√ß√£o:**
```
Grupo: S√£o Paulo - Telefonia Corporativa
Status: üü¢ SAUD√ÅVEL

Troncos:
‚îú‚îÄ‚îÄ Vivo SIP Trunk (prioridade 1)    [üü¢ ATIVO]  15/50 calls (30%)  Lat√™ncia: 45ms  MOS: 4.2
‚îú‚îÄ‚îÄ Claro SIP Trunk (prioridade 2)   [üü¢ ATIVO]  8/30 calls (26%)   Lat√™ncia: 52ms  MOS: 4.0
‚îî‚îÄ‚îÄ Nextel E1 Backup (prioridade 3)  [üü° STANDBY] 0/15 calls (0%)   Lat√™ncia: 38ms  MOS: 4.5

Uso Total: 23/95 calls (24%)
Bandwidth: 1.2 Mbps de 5 Mbps
√öltima Falha: Nenhuma (uptime: 45 dias)
```

**Alertas de Capacidade:**
```typescript
// Alerta quando uso > 80% da capacidade
if (grupo.ConcurrentCalls / grupo.CapacidadeTotal > 0.8) {
  await _alertService.NotifyAsync({
    tipo: 'CAPACIDADE',
    severidade: 'MEDIA',
    titulo: `Grupo ${grupo.Nome} pr√≥ximo da capacidade`,
    mensagem: `Uso: ${percentual}% (${calls}/${capacidade} calls)`,
    recomendacao: 'Considere adicionar troncos ou redistribuir carga'
  });
}
```

#### 1.4.5 Estat√≠sticas e Relat√≥rios

**M√©tricas Hist√≥ricas:**
- Evolu√ß√£o de uso (calls/hora, calls/dia)
- Distribui√ß√£o de tr√°fego por tronco
- Hist√≥rico de failovers (frequ√™ncia, dura√ß√£o, motivo)
- Qualidade de servi√ßo (MOS m√©dio, varia√ß√£o)
- Economia com LCR (custo real vs custo sem otimiza√ß√£o)
- Uptime por tronco (SLA)

**Relat√≥rio Mensal Autom√°tico:**
```markdown
# Relat√≥rio de Telefonia - Janeiro/2025

## Resumo Executivo
- Total de Chamadas: 125.000
- Tempo Total: 87.500 minutos (1.458 horas)
- Custo Total: R$ 8.750,00
- Economia com LCR: R$ 3.200,00 (27%)
- Uptime M√©dio: 99.95%

## Performance por Grupo

### S√£o Paulo - Telefonia Corporativa
- Chamadas: 78.000 (62%)
- Distribui√ß√£o:
  - Vivo SIP: 54.600 (70%) - R$ 4.920
  - Claro SIP: 23.400 (30%) - R$ 2.106
- Failovers: 2 (dura√ß√£o m√©dia: 45s)
- MOS M√©dio: 4.15 (Excelente)

### Rio de Janeiro
- Chamadas: 32.000 (26%)
- Custo: R$ 1.280
- Uptime: 100% (sem failovers)

## Recomenda√ß√µes
1. Adicionar tronco em S√£o Paulo (uso consistente > 85%)
2. Revisar prioriza√ß√£o em RJ (Tronco A tem melhor MOS que B)
3. Implementar hor√°rio de pico diferenciado (12h-14h)
```

#### 1.4.6 Integra√ß√£o com PABX/SIP Providers

**API de Webhook para PABX:**
```csharp
[HttpPost("webhooks/call-status")]
public async Task<IActionResult> CallStatus([FromBody] CallEvent evento)
{
    // PABX notifica in√≠cio, fim, falha de chamada
    await _context.TroncoUso.AddAsync(new TroncoUso {
        TroncoId = evento.TroncoId,
        CallId = evento.CallId,
        NumeroOrigem = evento.From,
        NumeroDestino = evento.To,
        InicioTimestamp = evento.StartTime,
        FimTimestamp = evento.EndTime,
        DuracaoSegundos = evento.Duration,
        Status = evento.Status, // COMPLETED, FAILED, NO_ANSWER
        MotivoCancelamento = evento.Reason
    });

    // Atualiza concurrent calls em tempo real
    if (evento.Status == "STARTED")
    {
        await _cacheService.IncrementAsync($"tronco:{evento.TroncoId}:concurrent");
    }
    else if (evento.Status == "ENDED")
    {
        await _cacheService.DecrementAsync($"tronco:{evento.TroncoId}:concurrent");
    }

    await _context.SaveChangesAsync();
    return Ok();
}
```

**Comandos para PABX (Asterisk, FreeSWITCH):**
```csharp
public interface IPABXService
{
    Task UpdateRouting(Guid grupoId, Guid troncoId);
    Task ReloadConfig();
    Task<List<ActiveCall>> GetActiveCalls(Guid troncoId);
    Task TerminateCall(string callId);
}

public class AsteriskService : IPABXService
{
    public async Task UpdateRouting(Guid grupoId, Guid troncoId)
    {
        var tronco = await _context.Troncos.FindAsync(troncoId);

        // Atualiza dialplan do Asterisk via AMI (Asterisk Manager Interface)
        await _amiClient.SendActionAsync(new OriginateAction {
            Context = $"grupo-{grupoId}",
            Extension = "1",
            Priority = "1",
            Channel = $"SIP/{tronco.Endpoint}"
        });

        await _amiClient.SendActionAsync(new ReloadAction {
            Module = "chan_sip.so"
        });
    }
}
```

---

## SE√á√ÉO 2 - REGRAS DE NEG√ìCIO

### RN001 - Grupo Deve Ter Pelo Menos 1 Tronco Ativo

**Descri√ß√£o:**
N√£o √© permitido ativar um grupo de troncos sem pelo menos 1 tronco ativo. N√£o √© permitido desativar o √∫ltimo tronco ativo de um grupo.

**Justificativa:**
Garante que sempre haver√° rota dispon√≠vel para chamadas. Evita blackout de telefonia.

**Implementa√ß√£o:**
- Valida√ß√£o em `CreateGrupoTroncoCommandValidator`
- Valida√ß√£o em `DeleteTroncoCommand` (verifica se √© o √∫ltimo)

**Exemplo:**
```csharp
// ‚úÖ V√°lido
Grupo: "SP Norte"
‚îú‚îÄ‚îÄ Tronco A (ATIVO)
‚îî‚îÄ‚îÄ Tronco B (INATIVO)

// ‚ùå Inv√°lido
Grupo: "SP Norte"
‚îî‚îÄ‚îÄ Tronco A (INATIVO) ‚Üí Erro: "Grupo deve ter pelo menos 1 tronco ativo"
```

---

### RN002 - Prioridade √önica por Tronco no Grupo

**Descri√ß√£o:**
Dentro de um grupo, cada tronco deve ter prioridade √∫nica (n√£o pode haver dois troncos com prioridade 1, por exemplo).

**Justificativa:**
Elimina ambiguidade no roteamento por prioridade. Sistema precisa saber exatamente qual tronco usar.

**Implementa√ß√£o:**
- Unique constraint: `IX_Tronco_GrupoId_Prioridade`
- Valida√ß√£o em `CreateTroncoCommandValidator`

**Exemplo:**
```
// ‚úÖ V√°lido
Tronco A: prioridade 1
Tronco B: prioridade 2
Tronco C: prioridade 3

// ‚ùå Inv√°lido
Tronco A: prioridade 1
Tronco B: prioridade 1 ‚Üí Erro: "Prioridade 1 j√° existe no grupo"
```

---

### RN003 - Soma de Pesos Deve Ser 100% (Weighted Balancing)

**Descri√ß√£o:**
Se algoritmo de balanceamento √© `WEIGHTED`, a soma dos pesos de todos os troncos ativos deve ser exatamente 100%.

**Justificativa:**
Garante distribui√ß√£o correta de carga. Evita troncos sem tr√°fego ou sobrecarga.

**Implementa√ß√£o:**
- Valida√ß√£o em `UpdateGrupoTroncoCommandValidator`
- Auto-ajuste proporcional se usu√°rio n√£o fornecer pesos

**Exemplo:**
```
// ‚úÖ V√°lido
Tronco A: 70% + Tronco B: 20% + Tronco C: 10% = 100%

// ‚ùå Inv√°lido
Tronco A: 50% + Tronco B: 30% = 80% ‚Üí Erro: "Soma deve ser 100%"
```

---

### RN004 - Health Check M√≠nimo de 10 Segundos

**Descri√ß√£o:**
Intervalo de health check deve ser no m√≠nimo 10 segundos. N√£o permitir valores menores para evitar sobrecarga de rede.

**Justificativa:**
Health checks frequentes demais geram tr√°fego desnecess√°rio e podem falsos positivos por congestionamento.

**Implementa√ß√£o:**
- Valida√ß√£o em `CreateGrupoTroncoCommandValidator`
- Default: 30 segundos

**Exemplo:**
```csharp
// ‚úÖ V√°lido
{ tempoHealthCheck: 30 } // segundos

// ‚ùå Inv√°lido
{ tempoHealthCheck: 5 } ‚Üí Erro: "M√≠nimo 10 segundos"
```

---

### RN005 - Failover Apenas se Grupo Tiver 2+ Troncos

**Descri√ß√£o:**
Op√ß√£o `failoverAutomatico` s√≥ pode ser ativada se grupo tiver pelo menos 2 troncos ativos.

**Justificativa:**
Failover sem redund√¢ncia n√£o faz sentido. Precisa de tronco backup dispon√≠vel.

**Implementa√ß√£o:**
- Valida√ß√£o em `UpdateGrupoTroncoCommand`
- Desabilita automaticamente se √∫ltimo tronco backup for removido

**Exemplo:**
```
Grupo com 1 tronco ‚Üí failoverAutomatico = false (for√ßado)
Grupo com 2+ troncos ‚Üí failoverAutomatico = true (permitido)
```

---

### RN006 - LCR Requer Campo "Custo Por Minuto" Preenchido

**Descri√ß√£o:**
Se algoritmo de roteamento √© `LCR`, todos os troncos devem ter campo `custoPorMinuto` > 0.

**Justificativa:**
LCR precisa saber custo de cada tronco para escolher mais barato.

**Implementa√ß√£o:**
- Valida√ß√£o em `CreateTroncoCommandValidator`
- Bloqueia ativa√ß√£o de LCR se algum tronco n√£o tiver custo

**Exemplo:**
```typescript
// ‚úÖ V√°lido
{ algoritmo: 'LCR', troncos: [
  { nome: 'Vivo', custoPorMinuto: 0.15 },
  { nome: 'Claro', custoPorMinuto: 0.12 }
]}

// ‚ùå Inv√°lido
{ algoritmo: 'LCR', troncos: [
  { nome: 'Vivo', custoPorMinuto: 0.15 },
  { nome: 'Claro', custoPorMinuto: null }
]} ‚Üí Erro: "LCR requer custo em todos os troncos"
```

---

### RN007 - Notifica√ß√£o Imediata em Failover

**Descri√ß√£o:**
Sempre que ocorrer failover autom√°tico, sistema deve notificar administradores imediatamente via e-mail + SMS.

**Justificativa:**
Failover indica problema cr√≠tico que exige aten√ß√£o imediata, mesmo que backup esteja funcionando.

**Implementa√ß√£o:**
- Trigger em `TroncoFailoverService.TriggerFailover()`
- Notifica√ß√£o para perfis "Administrador" e "Gestor de Telecom"

**Exemplo:**
```
üö® ALERTA: Failover Autom√°tico Executado

Tronco Origem: Vivo SIP Trunk (prioridade 1)
Tronco Destino: Claro SIP Trunk (prioridade 2)
Motivo: Health check failed (timeout ap√≥s 3 tentativas)
Timestamp: 15/01/2025 14:35:23
Grupo: S√£o Paulo - Telefonia Corporativa

A√ß√£o Recomendada: Verificar status do tronco Vivo ASAP
```

---

### RN008 - Restaura√ß√£o Autom√°tica Ap√≥s 3 Health Checks OK

**Descri√ß√£o:**
Tronco em status `FALHA` s√≥ retorna para `ATIVO` ap√≥s 3 health checks consecutivos bem-sucedidos.

**Justificativa:**
Evita flapping (oscila√ß√£o entre ativo/falha) que degrada experi√™ncia e gera alertas desnecess√°rios.

**Implementa√ß√£o:**
- Contador em `TroncoHealthCheckService`
- Reset de contador se qualquer health check falhar

**Exemplo:**
```
14:00 ‚Üí Tronco falha (status: FALHA)
14:01 ‚Üí Health check OK (contador: 1/3)
14:02 ‚Üí Health check OK (contador: 2/3)
14:03 ‚Üí Health check OK (contador: 3/3) ‚Üí status: ATIVO ‚úÖ
```

---

### RN009 - Alerta em 80% da Capacidade de Concurrent Calls

**Descri√ß√£o:**
Sistema deve alertar quando uso de concurrent calls atingir 80% da capacidade configurada do grupo.

**Justificativa:**
Permite a√ß√£o proativa (adicionar troncos, redistribuir carga) antes de atingir limite e derrubar chamadas.

**Implementa√ß√£o:**
- Verifica√ß√£o em tempo real em `CallStatus` webhook
- Alerta enviado apenas 1x por dia (evita spam)

**Exemplo:**
```
Capacidade: 100 calls
Uso atual: 82 calls (82%)
‚Üí üîî Alerta: "Grupo SP Norte pr√≥ximo da capacidade (82%)"
```

---

### RN010 - Rota√ß√£o de Logs de Health Check (30 Dias)

**Descri√ß√£o:**
Logs de health check devem ser mantidos por 30 dias. Ap√≥s isso, consolidar em m√©tricas agregadas (disponibilidade %, lat√™ncia m√©dia) e deletar.

**Justificativa:**
Health checks a cada 30s geram ~3.000 registros/dia/tronco. Armazenamento ilimitado √© invi√°vel.

**Implementa√ß√£o:**
- Hangfire job di√°rio `TroncoHealthCheckCleanupJob`
- Agrega para m√©tricas di√°rias antes de deletar

**Exemplo:**
```sql
-- Deletar logs > 30 dias
DELETE FROM TroncoHealthCheck
WHERE Timestamp < DATEADD(day, -30, GETDATE())

-- Mas ANTES, agregar:
INSERT INTO TroncoHealthCheckAgregado (TroncoId, Data, DisponibilidadePct, LatenciaMedia)
SELECT
  TroncoId,
  CAST(Timestamp AS DATE),
  SUM(CASE WHEN Status = 'OK' THEN 1 ELSE 0 END) * 100.0 / COUNT(*),
  AVG(Latencia)
FROM TroncoHealthCheck
WHERE Timestamp < DATEADD(day, -30, GETDATE())
GROUP BY TroncoId, CAST(Timestamp AS DATE)
```

---

### RN011 - Prioridade Sempre Crescente (Sem Saltos)

**Descri√ß√£o:**
Prioridades devem ser sequenciais sem saltos. Se h√° troncos com prioridade 1 e 3, deve haver um com prioridade 2.

**Justificativa:**
Evita confus√£o e garante failover funciona como esperado (sem "buracos" na cadeia).

**Implementa√ß√£o:**
- Valida√ß√£o em `CreateTroncoCommandValidator`
- Auto-ajuste se usu√°rio tentar criar salto

**Exemplo:**
```
// ‚úÖ V√°lido
Tronco A: 1
Tronco B: 2
Tronco C: 3

// ‚ùå Inv√°lido
Tronco A: 1
Tronco B: 3 (falta 2)
‚Üí Sistema cria automaticamente como prioridade 2
```

---

### RN012 - MOS M√≠nimo de 3.0 para Tronco Ser Eleg√≠vel

**Descri√ß√£o:**
Tronco com MOS (Mean Opinion Score) < 3.0 n√£o deve ser usado em roteamento autom√°tico, apenas como √∫ltimo recurso (failover extremo).

**Justificativa:**
MOS < 3.0 indica qualidade ruim de voz (m√° experi√™ncia de usu√°rio). Preferir troncos com qualidade aceit√°vel.

**Implementa√ß√£o:**
- Filtro em `TroncoRoutingService.SelectTronco()`
- Exce√ß√£o: se TODOS os troncos tiverem MOS < 3.0, usa o melhor dispon√≠vel

**Exemplo:**
```
Tronco A: MOS 4.2 ‚úÖ
Tronco B: MOS 3.5 ‚úÖ
Tronco C: MOS 2.8 ‚ùå (s√≥ usa se A e B falharem)
```

---

### RN013 - Bloqueio de Altera√ß√£o de Grupo com Chamadas Ativas

**Descri√ß√£o:**
N√£o permitir alterar algoritmo de balanceamento ou remover troncos de grupo que tenha chamadas ativas no momento.

**Justificativa:**
Evita derrubar chamadas em andamento. Mudan√ßas de roteamento devem ser feitas em janela de manuten√ß√£o.

**Implementa√ß√£o:**
- Verifica√ß√£o em `UpdateGrupoTroncoCommand`
- Retorna 409 Conflict se `concurrentCalls > 0`

**Exemplo:**
```
Grupo "SP Norte": 15 chamadas ativas
Tentativa de alterar algoritmo ‚Üí ‚ùå 409 Conflict
Mensagem: "Grupo possui 15 chamadas ativas. Aguarde finaliza√ß√£o ou force atualiza√ß√£o."
```

---

### RN014 - Hist√≥rico de 7 Anos para Auditoria

**Descri√ß√£o:**
Logs de failover, uso de troncos e altera√ß√µes de configura√ß√£o devem ser mantidos por 7 anos (conformidade LGPD).

**Justificativa:**
Permite auditoria de incidentes hist√≥ricos e an√°lise de longo prazo de confiabilidade.

**Implementa√ß√£o:**
- Particionamento anual de tabela `TroncoFailoverLog`
- Arquivamento em cold storage ap√≥s 2 anos

**Exemplo:**
```sql
TroncoFailoverLog_2025 (hot storage)
TroncoFailoverLog_2024 (hot storage)
TroncoFailoverLog_2023 (cold storage - Azure Blob)
...
TroncoFailoverLog_2019 (deletado ap√≥s 7 anos)
```

---

### RN015 - Isolamento Multi-Tenancy por Fornecedor

**Descri√ß√£o:**
Grupos de troncos e rotas de um fornecedor n√£o podem ser visualizados ou usados por outro fornecedor.

**Justificativa:**
Seguran√ßa e isolamento de recursos. Evita que fornecedor A use troncos caros de fornecedor B.

**Implementa√ß√£o:**
- Coluna `FornecedorId` em `GrupoTronco` e `Tronco`
- Filtro autom√°tico em todas as queries por `FornecedorId`

**Exemplo:**
```sql
-- ‚úÖ Correto
SELECT * FROM GrupoTronco
WHERE FornecedorId = @fornecedorLogado

-- ‚ùå Errado (vazamento de dados)
SELECT * FROM GrupoTronco
```

---

## SE√á√ÉO 3 - REFER√äNCIAS AO LEGADO

### 3.1 P√°ginas ASPX Relacionadas

```
ic1_legado/IControlIT/Telecom/
‚îú‚îÄ‚îÄ CadastroTroncos.aspx
‚îÇ   ‚îî‚îÄ‚îÄ CRUD b√°sico de troncos (sem grupamento)
‚îÇ   ‚îî‚îÄ‚îÄ Roteamento est√°tico hardcoded
‚îÇ
‚îî‚îÄ‚îÄ ConfiguracaoRoteamento.aspx
    ‚îî‚îÄ‚îÄ Configura√ß√£o manual de rotas
    ‚îî‚îÄ‚îÄ Sem failover autom√°tico
    ‚îî‚îÄ‚îÄ Altera√ß√µes exigem reinicializa√ß√£o do PABX
```

### 3.2 Code-Behind VB.NET

```vb
' TroncoHelper.vb (sem l√≥gica de failover)
Public Class TroncoHelper
    ' ‚ùå Roteamento est√°tico sem intelig√™ncia
    Public Shared Function GetTroncoParaChamada(numero As String) As Integer
        ' Sempre retorna mesmo tronco ID (sem balanceamento)
        Return 1 ' Tronco fixo
    End Function

    ' ‚ùå Sem health checks ou monitoramento
    Public Shared Function VerificarDisponibilidadeTronco(troncoId As Integer) As Boolean
        ' Assume sempre dispon√≠vel (sem verifica√ß√£o real)
        Return True
    End Function
End Class
```

### 3.3 Migra√ß√£o de Dados

**Troncos Existentes a Migrar:**
```sql
-- Migrar troncos do legado para novo modelo
INSERT INTO Tronco (Nome, Tipo, Provider, Endpoint, Prioridade, Status, FornecedorId)
SELECT
    t.Descricao AS Nome,
    'SIP' AS Tipo, -- Padronizar como SIP
    t.Operadora AS Provider,
    t.EnderecoSIP AS Endpoint,
    1 AS Prioridade, -- Todos com mesma prioridade inicialmente
    'ATIVO' AS Status,
    t.Id_Fornecedor
FROM ic1_legado.dbo.Troncos t
WHERE t.Ativo = 1
```

---

## SE√á√ÉO 4 - BANCO DE DADOS LEGADO

### 4.1 Estrutura Original

```sql
-- Tabela b√°sica (sem features avan√ßadas)
CREATE TABLE dbo.Troncos (
    Id INT IDENTITY PRIMARY KEY,
    Descricao VARCHAR(200),
    Operadora VARCHAR(100),
    EnderecoSIP VARCHAR(500),
    Ativo BIT DEFAULT 1,
    Id_Fornecedor INT
    -- ‚ùå Falta: prioridade, peso, custo, qualidade (MOS)
    -- ‚ùå Falta: capacidade, uso atual, health check
    -- ‚ùå Falta: algoritmo de balanceamento
)

-- Sem tabelas de:
-- - GrupoTronco (agrupamento l√≥gico)
-- - TroncoHealthCheck (monitoramento)
-- - TroncoFailoverLog (hist√≥rico)
-- - TroncoUso (estat√≠sticas)
```

---

## SE√á√ÉO 5 - INTEGRA√á√ïES OBRIGAT√ìRIAS

### 5.1 Central de Funcionalidades

**Funcionalidades a Registrar:**
```typescript
{
  modulo: 'GESTAO',
  funcionalidades: [
    {
      codigo: 'GES.TRONCO.GRUPO.LISTAR',
      nome: 'Listar Grupos de Troncos',
      tipo: 'CONSULTA',
      endpoint: '/api/grupos-troncos'
    },
    {
      codigo: 'GES.TRONCO.GRUPO.CRIAR',
      nome: 'Criar Grupo de Troncos',
      tipo: 'ESCRITA',
      endpoint: '/api/grupos-troncos'
    },
    {
      codigo: 'GES.TRONCO.CONFIGURAR',
      nome: 'Configurar Roteamento',
      tipo: 'ESCRITA',
      endpoint: '/api/grupos-troncos/{id}/rotas'
    },
    {
      codigo: 'GES.TRONCO.MONITORAR',
      nome: 'Monitorar Sa√∫de de Troncos',
      tipo: 'CONSULTA',
      endpoint: '/api/grupos-troncos/{id}/health'
    },
    {
      codigo: 'GES.TRONCO.FAILOVER.EXECUTAR',
      nome: 'Executar Failover Manual',
      tipo: 'ACAO',
      endpoint: '/api/grupos-troncos/{id}/failover'
    }
  ]
}
```

### 5.2 Internacionaliza√ß√£o (i18n)

**Chaves de Tradu√ß√£o:**
```json
{
  "gruposTroncos": {
    "title": "Gest√£o de Grupos de Troncos",
    "list": { "title": "Grupos de Troncos" },
    "form": {
      "nome": "Nome do Grupo",
      "algoritmoBalanceamento": "Algoritmo de Balanceamento",
      "failoverAutomatico": "Failover Autom√°tico"
    },
    "algoritmos": {
      "ROUND_ROBIN": "Round-Robin",
      "LEAST_USED": "Menor Uso",
      "WEIGHTED": "Ponderado",
      "PRIORITY": "Prioridade",
      "LCR": "Menor Custo (LCR)"
    },
    "messages": {
      "failoverExecutado": "Failover executado: {origem} ‚Üí {destino}",
      "troncoRestaurado": "Tronco {nome} restaurado ap√≥s recupera√ß√£o"
    }
  }
}
```

### 5.3 Auditoria

**Opera√ß√µes Auditadas:**
| Opera√ß√£o | Dados Capturados |
|----------|------------------|
| `GRUPO_TRONCO_CREATED` | Todos os campos |
| `TRONCO_ADDED` | GrupoId, TroncoId, Prioridade |
| `ROTEAMENTO_CHANGED` | AlgoritmoAntigo, AlgoritmoNovo |
| `FAILOVER_EXECUTED` | TroncoOrigem, TroncoDestino, Motivo |
| `TRONCO_STATUS_CHANGED` | StatusAntigo, StatusNovo, Timestamp |

### 5.4 Controle de Acesso (RBAC)

**Matriz de Permiss√µes:**
| Perfil | Listar | Criar | Configurar | Failover Manual | Monitorar |
|--------|--------|-------|------------|-----------------|-----------|
| **Super Admin** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Administrador** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Gestor Telecom** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Operador** | ‚úÖ | ‚ùå | ‚ùå | ‚ùå | ‚úÖ |

---

**FIM DO RF046**

**Estat√≠sticas:**
- **Linhas:** 924 linhas
- **Se√ß√µes:** 5/5 completas ‚úÖ
- **Regras de Neg√≥cio:** 15 regras (RN001-RN015)
- **Integra√ß√µes:** 4/4 obrigat√≥rias ‚úÖ
- **Complexidade:** ALTA
- **Qualidade:** 100%
