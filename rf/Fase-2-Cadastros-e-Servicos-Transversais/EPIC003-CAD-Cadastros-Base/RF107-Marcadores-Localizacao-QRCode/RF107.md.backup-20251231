# RF-107: Marcadores Localização QRCode

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF014 (Gestão de Ativos), RF015 (Locais e Endereços) | **EPIC**: EPIC003-CAD-Cadastros-Base
**Fase**: Fase 2 - Cadastros e Serviços Transversais

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

Este requisito especifica o **Módulo de Marcadores Localização QRCode** do sistema IControlIT, responsável por gerar, gerenciar e processar códigos QR únicos para rastreamento de ativos físicos em tempo real. O módulo integra tecnologias de geolocalização, identificação visual e auditoria para fornecer rastreabilidade completa do ciclo de vida de ativos no ambiente empresarial.

O sistema permite criar etiquetas de QR Code vinculadas a ativos, ler essas etiquetas via aplicativo mobile, registrar movimentações com precisão geográfica, realizar inventários bulk por leitura de QR Codes e manter histórico completo de localizações. A solução moderniza o processo manual de localização de ativos, eliminando perda de informações e garantindo conformidade com LGPD.

### 1.2 Importância Estratégica

O módulo de Marcadores QRCode é crítico para:

- **Rastreabilidade Completa**: Implementa trilha de auditoria completa de cada ativo, sabendo exatamente quem movimentou, quando e para onde
- **Conformidade Regulatória**: Atende LGPD (Art. 5º - Dados de Localização) e ISO 27001 (rastreamento de ativos críticos)
- **Eficiência Operacional**: Reduz tempo de localização de ativos em 90%, elimina perdas por desorientação e otimiza inventários
- **Segurança Física**: Alerta automático quando ativos críticos saem de localizações autorizadas
- **Integração Mobile**: Suporta leitura offline via PWA com sincronização automática quando conectado
- **Performance**: Processa até 1.000 leituras por sessão com latência < 500ms

### 1.3 Conceitos Fundamentais

**QR Code Corporativo**: Código visual 2D contendo ClienteId, AtivoId e CheckDigit (Algoritmo Luhn), gerado em Base64URL para segurança. Diferencia-se de QR Code público por incluir validação de dígito verificador e contexto multi-tenant.
- Formato: `[ClienteId(4)].[AtivoId(8)].[CheckDigit(2)].Base64Encoded`

**Check-in/Check-out**: Operações de rastreamento de movimento de ativo. Check-in registra entrada em localização com GPS. Check-out registra saída anterior. Sistema alerta se houver Check-in sem Check-out correspondente (duplicação).

**Geolocalização**: Captura de coordenadas GPS (latitude, longitude) com precisão mínima de 10 metros. Integrada com Azure Maps para reverter coordenadas para endereço legível (rua, cidade, país).

**Inventário Bulk**: Processo de leitura em lote de múltiplos QR Codes (até 1.000 por sessão) para sincronizar estado físico com estado no sistema. Ideal para auditorias periódicas.

**Histórico de Leituras**: Registro imutável de todas as interações com QR Code (quem leu, quando, onde). Mantido por 24 meses conforme política de retenção corporativa.

**Etiqueta QRCode**: Artefato físico impresso contendo QR Code + Nome Ativo + Código Patrimonial. Gerada em PDF via iTextSharp, pronta para impressão e colagem em ativo.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Geração de Código** | Manual via Excel, sem validação | Automática com ZXing.Net, validação Luhn obrigatória |
| **Leitura de QR Code** | Scanner externo de código de barras, sem GPS | PWA com câmera HTML5, captura GPS em tempo real |
| **Armazenamento de Imagem** | Servidor local, sem backup | Azure Blob Storage com redundância geográfica |
| **Rastreamento de Localização** | Planilha Excel, manual | Azure Maps API + SignalR para atualização em tempo real |
| **Inventário** | Contagem manual, semanal | Bulk automation, real-time sync, < 5 minutos |
| **Auditoria** | Logs de arquivo de texto | Tabela AuditLog estruturada com context completo |
| **Relatórios** | Crystal Reports, offline | Power BI integrado, dashboards interativos |
| **Multi-tenancy** | Não suportado (banco único) | ClienteId em todas as tabelas, tenant isolation automático |
| **LGPD Compliance** | Retenção indefinida | Política de retenção 24 meses, anonimização automática |

### 1.5 Funcionalidades Principais

1. **Geração Automática de QRCode** - Criar QR Code único por ativo com validação de dígito Luhn
2. **Impressão de Etiquetas** - Gerar PDF com QR Code + dados do ativo, pronto para impressão
3. **Leitura via Aplicativo Mobile** - PWA com câmera que captura QR Code e GPS simultaneamente
4. **Check-in/Check-out de Ativos** - Registrar movimento de ativo entre localizações
5. **Histórico de Leituras** - Visualizar trilha completa de movimentações com timestamps e GPS
6. **Geolocalização em Tempo Real** - Mapear localização atual de ativo via Google Maps/Azure Maps
7. **Inventário Bulk** - Ler até 1.000 QR Codes em sessão única para sincronizar estado
8. **Alertas de Desvio** - Notificar quando ativo sai de localização autorizada
9. **Integração com Ativos (RF014)** - Vincular QR Code a ativo existente
10. **Relatórios de Rastreamento** - Exportar trilha de movimentações, tempo de permanência, etc.

---

## 2. REGRAS DE NEGÓCIO

### RN-QRC-107-01: QRCode deve ser único (GUID codificado em Base64URL)

**Descrição**: Cada QR Code gerado deve ser único no escopo do Cliente, codificado em Base64URL para segurança e compactação, sem colisões possíveis mesmo após bilhões de gerações.

**Justificativa**: Evita duplicação de QR Codes, garante identificação única de cada ativo e facilita transmissão em URLs/QR Codes comprimidos (58 caracteres vs 36 de GUID simples).

**Implementação**:
```csharp
public class QRCodeGenerator
{
    public string GenerateUniqueQRCode()
    {
        // Gerar GUID aleatório para unicidade global
        var guid = Guid.NewGuid();

        // Converter para Base64URL (RFC 4648)
        var bytes = guid.ToByteArray();
        var base64 = Convert.ToBase64String(bytes)
            .Replace("+", "-")
            .Replace("/", "_")
            .TrimEnd('=');

        return base64; // Exemplo: "k3j_pQ2mRUGuH8-zV5L4Cw"
    }

    public bool ValidateQRCodeFormat(string qrCode)
    {
        // Validar comprimento mínimo
        if (qrCode.Length < 22) return false;

        // Validar caracteres Base64URL permitidos
        var validChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
        return qrCode.All(c => validChars.Contains(c));
    }
}
```

**Exemplos**:
- Válido: `"K9mL2qR8sT3uV1wX5yZ"` (22-44 caracteres Base64URL)
- Inválido: `"K9mL+2qR/8sT3uV1wX5yZ"` (contém caracteres fora do padrão URL)
- Inválido: `"K9mL"` (muito curto, < 22 caracteres)

---

### RN-QRC-107-02: QRCode deve conter ClienteId + AtivoId + CheckDigit

**Descrição**: A estrutura interna do QR Code, quando decodificado, deve ser: `[ClienteId(4)][AtivoId(8)][CheckDigit(2)]`, totalizando 14 dígitos numéricos antes da codificação Base64.

**Justificativa**: Permite validar QR Code sem acessar banco de dados (offline validation). ClienteId garante multi-tenancy. CheckDigit detecta erros de leitura ou QR Codes falsificados.

**Implementação**:
```csharp
public class QRCodeValidator
{
    public QRCodeStructure ParseQRCode(string qrCodeBase64)
    {
        // Decodificar Base64URL
        var base64 = qrCodeBase64
            .Replace("-", "+")
            .Replace("_", "/");
        var padding = 4 - (base64.Length % 4);
        if (padding != 4) base64 += new string('=', padding);

        var bytes = Convert.FromBase64String(base64);
        var numeric = BitConverter.ToInt64(bytes, 0).ToString().PadLeft(14, '0');

        return new QRCodeStructure
        {
            ClienteId = numeric.Substring(0, 4),
            AtivoId = numeric.Substring(4, 8),
            CheckDigit = numeric.Substring(12, 2)
        };
    }

    public bool ValidateCheckDigit(string numeric14)
    {
        var expectedCheckDigit = CalculateCheckDigit(numeric14.Substring(0, 12));
        var actualCheckDigit = numeric14.Substring(12, 2);

        return expectedCheckDigit == actualCheckDigit;
    }

    private string CalculateCheckDigit(string numeric12)
    {
        // Implementar Algoritmo de Luhn (veja RN-QRC-107-03)
        var luhn = new LuhnAlgorithm();
        return luhn.Calculate(numeric12);
    }
}

public class QRCodeStructure
{
    public string ClienteId { get; set; }  // 4 dígitos
    public string AtivoId { get; set; }    // 8 dígitos
    public string CheckDigit { get; set; } // 2 dígitos
}
```

**Exemplos**:
- Válido: `"K9mL2qR8sT3uV1wX5yZ"` (decodificado: `0001|00012345|78`)
- Inválido: `"INVALID_QR_CODE"` (falha na decodificação)
- Inválido: `"K9mL2qR8sT3uV1wX99"` (checksum incorreto)

---

### RN-QRC-107-03: Check-digit calculado via Algoritmo de Luhn (modificado para 14 dígitos)

**Descrição**: O dígito verificador dos 12 primeiros dígitos do QR Code (ClienteId + AtivoId) é calculado usando o Algoritmo de Luhn, armazenado nos últimos 2 dígitos.

**Justificativa**: Algoritmo de Luhn é padrão ISO para validação de números de identificação (cartão de crédito, CPF modificado). Detecta erros de transcrição e falsificação.

**Validação SQL**:
```sql
-- Função SQL para calcular Check Digit via Luhn
CREATE FUNCTION [dbo].[CalculateLuhnCheckDigit](@numeric12 VARCHAR(12))
RETURNS VARCHAR(2)
AS
BEGIN
    DECLARE @sum INT = 0, @i INT = 1, @digit INT, @isEven BIT = 0

    WHILE @i <= LEN(@numeric12)
    BEGIN
        SET @digit = CAST(SUBSTRING(@numeric12, LEN(@numeric12) - @i + 1, 1) AS INT)

        IF @isEven = 1
        BEGIN
            SET @digit = @digit * 2
            IF @digit > 9 SET @digit = @digit - 9
        END

        SET @sum = @sum + @digit
        SET @isEven = 1 - @isEven
        SET @i = @i + 1
    END

    DECLARE @checkDigit INT = (10 - (@sum % 10)) % 10

    -- Retornar 2 dígitos do check digit (pode ser 00-09)
    RETURN RIGHT('0' + CAST(@checkDigit AS VARCHAR(2)), 2)
END

-- Usar constraint para validar
ALTER TABLE [dbo].[QRCode] ADD CONSTRAINT [CK_QRCode_CheckDigit]
CHECK ([dbo].[CalculateLuhnCheckDigit](SUBSTRING([NumericContent], 1, 12)) = SUBSTRING([NumericContent], 13, 2))
```

---

### RN-QRC-107-04: Etiqueta deve conter QRCode + Nome Ativo + Código Patrimonial

**Descrição**: Quando impressa, a etiqueta física deve conter: (1) Código QR 40x40mm no mínimo, (2) Nome do Ativo legível, (3) Código Patrimonial (Ativo.Codigo). Artefato gerado em PDF via iTextSharp.

**Justificativa**: Permite leitura manual se QR Code estiver danificado. Identifica visualmente o ativo sem precisar decodificar QR Code. Segue padrões corporativos de etiquetagem.

**Implementação**:
```csharp
public class EtiquetaQRCodeGenerator
{
    private readonly IQRCodeRepository _qrRepository;
    private readonly IAtivoRepository _ativoRepository;

    public async Task<byte[]> GerarEtiquetaPDFAsync(string qrCodeId)
    {
        var qrCode = await _qrRepository.GetByIdAsync(qrCodeId);
        var ativo = await _ativoRepository.GetByIdAsync(qrCode.AtivoId);

        var document = new Document(new Rectangle(101.6f, 152.4f)); // 4x6 polegadas (padrão de etiqueta)
        var memoryStream = new MemoryStream();
        var writer = PdfWriter.GetInstance(document, memoryStream);

        document.Open();

        // Gerar imagem QR Code via ZXing
        var qrImage = GerarImagemQRCode(qrCodeId, 40, 40); // 40x40mm
        var img = Image.GetInstance(qrImage);
        img.ScaleToFit(113.4f, 113.4f); // Escalar para ~4x4 cm
        document.Add(img);

        // Adicionar Nome do Ativo
        var nomeFont = new Font(Font.HELVETICA, 10, Font.BOLD);
        document.Add(new Paragraph(ativo.Nome, nomeFont));

        // Adicionar Código Patrimonial
        var codigoFont = new Font(Font.HELVETICA, 9, Font.NORMAL);
        document.Add(new Paragraph($"Código: {ativo.Codigo}", codigoFont));

        // Adicionar Data de Geração
        var dataFont = new Font(Font.HELVETICA, 7, Font.ITALIC);
        document.Add(new Paragraph($"Gerado: {DateTime.UtcNow:dd/MM/yyyy HH:mm}", dataFont));

        document.Close();
        return memoryStream.ToArray();
    }

    private byte[] GerarImagemQRCode(string qrCodeId, int width, int height)
    {
        var writer = new BarcodeWriter { Format = BarcodeFormat.QR_CODE };
        writer.Options = new QRCodeEncodingOptions { Width = width, Height = height };

        using (var bitmap = writer.Write(qrCodeId))
        {
            using (var stream = new MemoryStream())
            {
                bitmap.Save(stream, System.Drawing.Imaging.ImageFormat.Png);
                return stream.ToArray();
            }
        }
    }
}
```

**Exemplo de Layout**:
```
┌─────────────────────────┐
│  ██████████████████    │
│  ██            ██       │
│  ██  QR CODE  ██  40mm  │
│  ██            ██       │
│  ██████████████████    │
│                         │
│  Servidor de Arquivo   │
│  Código: AT-2024-00123  │
│                         │
│  Gerado: 28/12/2025    │
└─────────────────────────┘
```

---

### RN-QRC-107-05: Leitura de QRCode deve registrar Usuário, Data/Hora, GPS (lat/lon)

**Descrição**: Toda leitura de QR Code via aplicativo mobile deve registrar automaticamente: (1) Usuário autenticado que realizou leitura, (2) Data/hora UTC da leitura, (3) Coordenadas GPS (latitude, longitude) com precisão mínima 10m.

**Justificativa**: Implementa auditoria completa de rastreamento, essencial para LGPD e investigações de perdas. Latitude/longitude permite mapear movimentações exatas.

**Implementação**:
```csharp
public class QRCodeLeitor
{
    private readonly IQRCodeRepository _qrRepository;
    private readonly IAzureMapsService _mapsService;
    private readonly ICurrentUserService _userService;

    public async Task<QRCodeLeituraResponse> LerQRCodeAsync(string qrCodeId, double latitude, double longitude)
    {
        // Validar precisão de GPS (mínimo 10 metros de acurácia)
        if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180)
            throw new InvalidOperationException("Coordenadas GPS inválidas");

        var usuarioId = _userService.GetCurrentUserId();
        var datahora = DateTime.UtcNow;

        // Reverter coordenadas para endereço legível
        var endereco = await _mapsService.ReverseGeocodeAsync(latitude, longitude);

        // Registrar leitura no banco
        var leitura = new QRCodeLeitura
        {
            QRCodeId = qrCodeId,
            UsuarioId = usuarioId,
            DataHoraLeitura = datahora,
            Latitude = latitude,
            Longitude = longitude,
            EnderecoReverso = endereco,
            AtivoId = ExtractAtivoIdFromQRCode(qrCodeId),
            ClienteId = ExtractClienteIdFromQRCode(qrCodeId)
        };

        await _qrRepository.AdicionarLeituraAsync(leitura);

        return new QRCodeLeituraResponse
        {
            Sucesso = true,
            QRCodeId = qrCodeId,
            DataHoraLeitura = datahora,
            Localizacao = endereco,
            Coordenadas = new { Latitude = latitude, Longitude = longitude }
        };
    }
}

public class QRCodeLeitura
{
    public string QRCodeId { get; set; }
    public string UsuarioId { get; set; }
    public DateTime DataHoraLeitura { get; set; }
    public double Latitude { get; set; }
    public double Longitude { get; set; }
    public string EnderecoReverso { get; set; }
    public string AtivoId { get; set; }
    public string ClienteId { get; set; }
}
```

---

### RN-QRC-107-06: Check-in sem check-out prévio deve alertar (possível duplicação)

**Descrição**: Se um ativo realiza Check-in em localização X sem ter realizado Check-out na localização anterior Y, o sistema deve alertar o usuário indicando possível duplicação ou erro de operação.

**Justificativa**: Previne situação inconsistente onde um ativo está registrado em 2 locais simultaneamente. Comum em operações manuais desorganizadas.

**Implementação**:
```csharp
public class CheckInCheckOutService
{
    private readonly IQRCodeRepository _qrRepository;
    private readonly INotificacaoService _notificacao;

    public async Task<CheckInResponse> ExecutarCheckInAsync(string qrCodeId, string localizacaoDestino)
    {
        var ultimaLeitura = await _qrRepository.ObterUltimaLeituraAsync(qrCodeId);

        if (ultimaLeitura != null &&
            ultimaLeitura.TipoOperacao == "CHECK_IN" &&
            ultimaLeitura.Localizacao != localizacaoDestino)
        {
            // Ativo tem check-in anterior sem checkout
            var alerta = new AlertaDuplicacao
            {
                QRCodeId = qrCodeId,
                LocalizacaoAnterior = ultimaLeitura.Localizacao,
                LocalizacaoNovaDestino = localizacaoDestino,
                DataHoraAlerta = DateTime.UtcNow,
                Mensagem = $"Ativo estava em check-in em {ultimaLeitura.Localizacao}. Realizar checkout antes de novo check-in?"
            };

            await _notificacao.EnviarAlertaAsync(alerta);

            return new CheckInResponse
            {
                Sucesso = false,
                Erro = "CHECK_IN_DUPLICADO",
                Mensagem = alerta.Mensagem,
                RequerConfirmacao = true
            };
        }

        // Processar check-in normal
        var checkIn = new QRCodeLeitura
        {
            QRCodeId = qrCodeId,
            TipoOperacao = "CHECK_IN",
            Localizacao = localizacaoDestino,
            DataHoraLeitura = DateTime.UtcNow,
            UsuarioId = _userService.GetCurrentUserId()
        };

        await _qrRepository.AdicionarCheckInAsync(checkIn);

        return new CheckInResponse { Sucesso = true, QRCodeId = qrCodeId };
    }
}
```

---

### RN-QRC-107-07: Geolocalização deve ter precisão mínima de 10 metros

**Descrição**: Toda leitura de QR Code capturando geolocalização GPS deve ter precisão (accuracy) de no máximo 10 metros. Leituras com precisão inferior (> 10m) devem ser rejeitadas ou marcadas como "baixa confiabilidade".

**Justificativa**: 10m é padrão industrial para localização GPS em ambientes corporativos internos/externos. Garante rastreamento significativo sem ruído de dados.

**Implementação**:
```csharp
public class GeolocalizacaoValidator
{
    private const double PRECISAO_MINIMA_METROS = 10.0;

    public bool ValidarPrecisaoGPS(GPSReading reading)
    {
        // Validar que accuracy está preenchido
        if (reading.AccuracyMeters == null)
            return false;

        // Verificar se está dentro do limite
        if (reading.AccuracyMeters > PRECISAO_MINIMA_METROS)
        {
            // Marcar como baixa confiabilidade ao invés de rejeitar
            reading.ConfiabilidadeGPS = "BAIXA";
            reading.NotasRejeitadas = $"Precisão GPS: {reading.AccuracyMeters}m (limite: {PRECISAO_MINIMA_METROS}m)";
            return false;
        }

        reading.ConfiabilidadeGPS = "ALTA";
        return true;
    }
}

public class GPSReading
{
    public double Latitude { get; set; }
    public double Longitude { get; set; }
    public double? AccuracyMeters { get; set; }  // Acurácia em metros
    public string ConfiabilidadeGPS { get; set; } // ALTA, BAIXA
    public string NotasRejeitadas { get; set; }
}
```

---

### RN-QRC-107-08: Histórico de leituras mantido por 24 meses

**Descrição**: Todos os registros de leitura de QR Code (QRCodeLeitura) devem ser mantidos em banco de dados por 24 meses (730 dias) a partir da data da leitura. Após esse período, devem ser anonimizados ou excluídos conforme política LGPD.

**Justificativa**: LGPD Art. 5º define necessidade de propósito legítimo e retenção justificada. 24 meses é padrão corporativo para auditoria de movimentação de ativos críticos.

**Validação SQL**:
```sql
-- Tabela QRCodeLeitura com policy de retenção
CREATE TABLE [dbo].[QRCodeLeitura] (
    [Id] [uniqueidentifier] PRIMARY KEY DEFAULT NEWID(),
    [QRCodeId] [nvarchar](128) NOT NULL,
    [UsuarioId] [nvarchar](128) NOT NULL,
    [DataHoraLeitura] [datetime2] NOT NULL,
    [Latitude] [float] NULL,
    [Longitude] [float] NULL,
    [ClienteId] [nvarchar](4) NOT NULL,
    [AtivoId] [nvarchar](8) NOT NULL,
    [DataCriacao] [datetime2] DEFAULT GETUTCDATE(),
    [DataRetencaoAte] [datetime2] GENERATED ALWAYS AS (DATEADD(MONTH, 24, [DataHoraLeitura])) STORED
)

-- Job diário para anonimizar dados expirados
CREATE PROCEDURE [dbo].[AnonimizarLeiturasExpiradas]
AS
BEGIN
    -- Anonimizar ao invés de excluir (LGPD compliance)
    UPDATE [dbo].[QRCodeLeitura]
    SET
        [UsuarioId] = 'ANONIMO_' + CAST(NEWID() AS VARCHAR(36)),
        [Latitude] = NULL,
        [Longitude] = NULL,
        [DataHoraLeitura] = DATEADD(DAY, -730, GETUTCDATE())
    WHERE
        [DataRetencaoAte] < GETUTCDATE()
        AND [DataCriacao] < DATEADD(MONTH, -24, GETUTCDATE())
END

-- Executar diariamente via Agent
EXEC [msdb]..[sp_add_job] @job_name = 'JOB_AnonimizarLeiturasQRCode'
EXEC [msdb]..[sp_add_jobstep] @job_name = 'JOB_AnonimizarLeiturasQRCode',
    @command = 'EXEC [dbo].[AnonimizarLeiturasExpiradas]'
EXEC [msdb]..[sp_add_schedule] @schedule_name = 'Diario_2AM', @freq_type = 4, @freq_interval = 1, @active_start_time = 020000
EXEC [msdb]..[sp_attach_schedule] @job_name = 'JOB_AnonimizarLeiturasQRCode', @schedule_name = 'Diario_2AM'
```

---

### RN-QRC-107-09: Inventário bulk deve processar até 1000 QRCodes por sessão

**Descrição**: Operação de inventário que lê múltiplos QR Codes (até 1.000) em uma única sessão deve completar em menos de 5 minutos, processando lotes de 100 QR Codes em paralelo.

**Justificativa**: Otimiza operações de auditoria física sem parar operações normais. Limite de 1.000 é baseado em teste de stress (1.000 registros = ~50MB de dados).

**Implementação**:
```csharp
public class InventarioBulkService
{
    private const int MAX_QR_CODES_POR_SESSAO = 1000;
    private const int TAMANHO_LOTE = 100;

    public async Task<InventarioBulkResponse> IniciarInventarioAsync(InventarioBulkRequest request)
    {
        if (request.QRCodeIds.Count > MAX_QR_CODES_POR_SESSAO)
            throw new InvalidOperationException($"Máximo de {MAX_QR_CODES_POR_SESSAO} QR Codes por sessão");

        var sessaoId = Guid.NewGuid().ToString();
        var dataInicio = DateTime.UtcNow;

        // Processar em lotes de 100
        var lotes = request.QRCodeIds
            .Chunk(TAMANHO_LOTE)
            .ToList();

        var tarefas = lotes.Select(lote => ProcessarLoteAsync(sessaoId, lote)).ToList();

        try
        {
            await Task.WhenAll(tarefas);

            var dataFim = DateTime.UtcNow;
            var duracao = (dataFim - dataInicio).TotalSeconds;

            if (duracao > 300) // 5 minutos
            {
                // Gerar alerta se ultrapassar limite
                // TODO: Implementar otimização ou alertar sobre performance
            }

            return new InventarioBulkResponse
            {
                SessaoId = sessaoId,
                Total = request.QRCodeIds.Count,
                Processados = request.QRCodeIds.Count,
                DuracaoSegundos = duracao,
                Status = "COMPLETO"
            };
        }
        catch (Exception ex)
        {
            return new InventarioBulkResponse
            {
                SessaoId = sessaoId,
                Status = "ERRO",
                Mensagem = ex.Message
            };
        }
    }

    private async Task ProcessarLoteAsync(string sessaoId, string[] qrCodeIds)
    {
        var lotes = qrCodeIds.Select(id => new { SessaoId = sessaoId, QRCodeId = id });
        await _repository.AdicionarLeiturasBulkAsync(lotes);
    }
}
```

---

### RN-QRC-107-10: Auditoria de todas as operações de QRCode

**Descrição**: Todas as operações sobre QR Codes (criação, leitura, check-in, check-out, impressão, exclusão) devem ser registradas em tabela de auditoria com: Usuário, Tipo de Operação, Data/Hora UTC, IP da Requisição, ClienteId.

**Justificativa**: LGPD Art. 12 exige comprovação de consentimento e histórico de acesso. ISO 27001 exige trilha de auditoria de operações críticas.

**Validação SQL**:
```sql
CREATE TABLE [dbo].[QRCodeAuditLog] (
    [Id] [uniqueidentifier] PRIMARY KEY DEFAULT NEWID(),
    [ClienteId] [nvarchar](4) NOT NULL,
    [QRCodeId] [nvarchar](128) NULL,
    [AtivoId] [nvarchar](8) NULL,
    [UsuarioId] [nvarchar](128) NOT NULL,
    [TipoOperacao] [nvarchar](50) NOT NULL, -- CREATE, READ, CHECKIN, CHECKOUT, IMPRIMIR, DELETE
    [DataHoraOperacao] [datetime2] DEFAULT GETUTCDATE(),
    [IPAddress] [nvarchar](45) NOT NULL,
    [UserAgent] [nvarchar](500) NULL,
    [DadosAntigos] [nvarchar](max) NULL, -- JSON do estado anterior (para UPDATE/DELETE)
    [DadosNovos] [nvarchar](max) NULL,  -- JSON do estado novo
    [Resultado] [nvarchar](20) NOT NULL, -- SUCESSO, ERRO
    [MensagemErro] [nvarchar](max) NULL,
    CONSTRAINT [FK_QRCodeAuditLog_Cliente] FOREIGN KEY ([ClienteId])
        REFERENCES [dbo].[Cliente]([Codigo]),
    INDEX [IX_QRCodeAuditLog_ClienteId] NONCLUSTERED ([ClienteId]),
    INDEX [IX_QRCodeAuditLog_DataHora] NONCLUSTERED ([DataHoraOperacao] DESC)
)

-- Trigger para garantir auditoria automática
CREATE TRIGGER [tr_QRCode_Auditoria_Alteracao] ON [dbo].[QRCode]
AFTER UPDATE
AS
BEGIN
    INSERT INTO [dbo].[QRCodeAuditLog]
    (ClienteId, QRCodeId, UsuarioId, TipoOperacao, IPAddress, DadosAntigos, DadosNovos, Resultado)
    SELECT
        i.ClienteId,
        i.QRCodeId,
        SYSTEM_USER,
        'UPDATE',
        '0.0.0.0', -- Será preenchido por middleware
        (SELECT * FROM deleted d WHERE d.Id = i.Id FOR JSON PATH),
        (SELECT * FROM inserted i2 WHERE i2.Id = i.Id FOR JSON PATH),
        'SUCESSO'
    FROM inserted i
END
```

---

## 3. REFERENCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IC1Legado`

**Tabela Principal**: `dbo.Patrimonio_QRCode`
```sql
CREATE TABLE [dbo].[Patrimonio_QRCode](
    [idPatrimonio] [int] IDENTITY(1,1) NOT NULL,
    [idEmpresa] [int] NOT NULL,
    [idCliente] [int] NULL,
    [CodigoPatrimonial] [varchar](50) NOT NULL,
    [CodigoQR] [varchar](255) NULL,
    [ImagemQRCode] [image] NULL,
    [LocalAtual] [varchar](255) NULL,
    [DataGeracao] [datetime] NULL,
    [DataUltimaLeitura] [datetime] NULL,
    [UsuarioGeracao] [varchar](50) NULL,
    [UsuarioUltimaLeitura] [varchar](50) NULL,
    [Ativo] [bit] DEFAULT 1,
    CONSTRAINT [PK_Patrimonio_QRCode] PRIMARY KEY CLUSTERED ([idPatrimonio] ASC)
)

CREATE TABLE [dbo].[Patrimonio_QRCode_Historico](
    [idHistorico] [int] IDENTITY(1,1) NOT NULL,
    [idPatrimonioQRCode] [int] NOT NULL,
    [DataLeitura] [datetime] NOT NULL,
    [LocalLeitura] [varchar](255) NULL,
    [UsuarioLeitura] [varchar](50) NOT NULL,
    [Observacoes] [varchar](500) NULL,
    CONSTRAINT [PK_Patrimonio_QRCode_Historico] PRIMARY KEY CLUSTERED ([idHistorico] ASC),
    CONSTRAINT [FK_Historico_QRCode] FOREIGN KEY ([idPatrimonioQRCode])
        REFERENCES [dbo].[Patrimonio_QRCode]([idPatrimonio])
)
```

**Campos Importantes**:

| Campo Legado | Tipo | Descrição | Uso no Modernizado |
|--------------|------|-----------|-------------------|
| `idPatrimonio` | int | ID único do patrimônio | Mapeado para `AtivoId` |
| `CodigoQR` | varchar(255) | Código QR em texto | Será re-codificado em Base64URL com validação Luhn |
| `ImagemQRCode` | image | Imagem PNG em BLOB | Migrado para Azure Blob Storage |
| `LocalAtual` | varchar(255) | Localização atual manual | Será substituído por GPS + Reversegeocoding |
| `DataUltimaLeitura` | datetime | Timestamp da última leitura | Mantido como `DataHoraLeitura` |
| `UsuarioUltimaLeitura` | varchar(50) | Login do usuário | Mapeado para `UsuarioId` (GUID) |

### 3.2 Stored Procedures Legado

| Procedure | Descricao | Migracao |
|-----------|-----------|----------|
| `pa_GerarQRCodePatrimonio` | Gera QR Code para patrimônio | Migrado para `QRCodeGenerator.GenerateUniqueQRCode()` |
| `pa_RegistrarLeituraQRCode` | Registra leitura manual | Substituído por `QRCodeLeitor.LerQRCodeAsync()` + GPS |
| `pa_ListarHistoricoQRCode` | Lista histórico de leituras | Implementado como Query CQRS: `GetQRCodeLeituraHistorico` |
| `pa_InventarioQRCode` | Inventário manual de QR Codes | Substituído por `InventarioBulkService.IniciarInventarioAsync()` |

### 3.3 Telas ASPX Legado

| Pagina | Descricao | Tela Moderna |
|--------|-----------|--------------|
| `Patrimonio_QRCode.aspx` | Gerenciar QR Codes | `/assets/qrcodes/list` (Angular) |
| `Patrimonio_QRCode_Gerar.aspx` | Gerar novo QR Code | `/assets/qrcodes/create` |
| `Patrimonio_QRCode_Impressao.aspx` | Imprimir etiquetas | `/assets/qrcodes/{id}/print` |
| `Patrimonio_QRCode_Leitura.aspx` | Interface de leitura | PWA Mobile `/mobile/qrcode-reader` |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSPatrimonioQRCode.asmx.vb`

| Metodo | Descricao | Endpoint Moderno |
|--------|-----------|-----------------|
| `GerarQRCodePatrimonio(idPatrimonio)` | Gera código para patrimônio | `POST /api/qrcodes` |
| `LerQRCode(codigoQR)` | Lê QR Code e registra | `POST /api/qrcodes/ler` |
| `ObterHistoricoQRCode(idPatrimonio)` | Retorna histórico | `GET /api/qrcodes/{id}/historico` |
| `ExportarInventario()` | Exporta relatório de inventário | `GET /api/qrcodes/inventario/exportar` |

---

## 4. INTEGRACOES OBRIGATORIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `QRCODE_MANAGEMENT`

**Configuracao**:
```json
{
    "featureKey": "QRCODE_MANAGEMENT",
    "nome": "Gestão de Marcadores QRCode",
    "descricao": "Módulo completo de geração, leitura e rastreamento de QR Codes para ativos",
    "habilitado": true,
    "isSystemFeature": false,
    "modulo": "GESTAO_ATIVOS",
    "dependencias": [
        "RBAC_ENABLED",
        "AUDITORIA_ENABLED",
        "GEOLOCATION_ENABLED"
    ],
    "configuracoes": {
        "precisaoGpsMinima": 10,
        "maxQRCodesPorSessao": 1000,
        "tempoRetencaoMeses": 24,
        "algoritmoCheckDigit": "LUHN",
        "enableOfflineScanning": true
    }
}
```

**Sub-features**:
- `QRCODE_GERACAO`: Ativar geração de novos QR Codes
- `QRCODE_LEITURA_MOBILE`: Ativar leitura via PWA mobile
- `QRCODE_IMPRESSAO`: Ativar impressão de etiquetas
- `QRCODE_INVENTARIO_BULK`: Ativar inventário em lote
- `QRCODE_GEOLOCATION`: Ativar captura de GPS

**Nota**: Se `QRCODE_MANAGEMENT` estiver desabilitado, todas as operações retornam erro 403 Feature Not Available.

---

### 4.2 Internacionalizacao (i18n)

**Chaves de Traducao**:

```json
{
    "qrcode": {
        "common": {
            "titulo": "Marcadores QRCode",
            "descricao": "Gestão de código QR para rastreamento de ativos"
        },
        "list": {
            "title": "Lista de Marcadores QRCode",
            "columns": {
                "qrcodeId": "ID do QRCode",
                "codigoPatrimonial": "Código Patrimonial",
                "nomeAtivo": "Nome do Ativo",
                "localizacao": "Localização",
                "dataGeracao": "Data de Geração",
                "dataUltimaLeitura": "Última Leitura",
                "status": "Status"
            }
        },
        "create": {
            "title": "Gerar Novo QRCode",
            "form": {
                "ativoId": "Selecione o Ativo",
                "localizacao": "Localização Inicial",
                "descricao": "Descrição"
            },
            "messages": {
                "success": "QRCode gerado com sucesso",
                "error": "Erro ao gerar QRCode"
            }
        },
        "read": {
            "title": "Ler QRCode",
            "form": {
                "qrcodeInput": "Escaneie ou cole o QRCode",
                "latitudeInput": "Latitude (GPS)",
                "longitudeInput": "Longitude (GPS)",
                "enableGps": "Usar GPS do dispositivo"
            },
            "messages": {
                "success": "QRCode lido com sucesso",
                "error": "Erro ao ler QRCode",
                "invalidQRCode": "QRCode inválido ou verificação falhou",
                "gpsPrecisionWarning": "Precisão GPS inferior a 10m"
            }
        },
        "checkin": {
            "title": "Check-in de Ativo",
            "confirmacao": "Deseja fazer check-in deste ativo em {{localizacao}}?",
            "aviso": "Ativo já em check-in sem checkout anterior"
        },
        "checkout": {
            "title": "Check-out de Ativo",
            "confirmacao": "Deseja fazer check-out deste ativo?"
        },
        "print": {
            "title": "Imprimir Etiqueta",
            "form": {
                "tamanhoEtiqueta": "Tamanho da Etiqueta",
                "opcoes": ["4x6 polegadas", "5x8 polegadas", "Customizado"],
                "quantidadeEtiquetas": "Quantidade de cópias"
            },
            "messages": {
                "gerando": "Gerando PDF da etiqueta...",
                "success": "Etiqueta gerada. Abra o arquivo PDF para imprimir."
            }
        },
        "inventario": {
            "title": "Inventário em Lote",
            "form": {
                "uploadQRCodes": "Fazer upload de arquivo com QR Codes (CSV)",
                "instrucoes": "Uma linha por QRCode"
            },
            "messages": {
                "processando": "Processando {{total}} QR Codes...",
                "success": "Inventário processado: {{processados}} lidos, {{erros}} erros",
                "maxExceeded": "Máximo de 1000 QR Codes por sessão"
            }
        },
        "validation": {
            "required": "Campo obrigatório",
            "invalidQRCode": "QRCode inválido",
            "invalidGPS": "Coordenadas GPS inválidas",
            "invalidEmail": "Email inválido"
        },
        "errors": {
            "403": "Você não tem permissão para esta operação",
            "404": "QRCode não encontrado",
            "500": "Erro interno do servidor"
        }
    }
}
```

---

### 4.3 Auditoria

**Operacoes Auditadas**:

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Criar QRCode | `QRCODE_CREATE` | QRCodeId, AtivoId, ClienteId, UsuarioId, DataCriacao |
| Ler QRCode | `QRCODE_READ` | QRCodeId, UsuarioId, Latitude, Longitude, IPAddress |
| Check-in | `QRCODE_CHECKIN` | QRCodeId, Localizacao, UsuarioId, DataHora |
| Check-out | `QRCODE_CHECKOUT` | QRCodeId, UsuarioId, DataHora |
| Imprimir Etiqueta | `QRCODE_PRINT` | QRCodeId, Quantidade, UsuarioId |
| Deletar QRCode | `QRCODE_DELETE` | QRCodeId, DadosAntigos, UsuarioId |
| Inventário Bulk | `QRCODE_INVENTARIO` | SessaoId, Total, Processados, Tempo, UsuarioId |

**Retencao**: 24 meses (conforme LGPD Art. 5º)

**Implementacao**:
```csharp
public class AuditoriaQRCodeMiddleware : IMiddleware
{
    private readonly IAuditoriaRepository _auditoria;

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var path = context.Request.Path.ToString();

        if (path.Contains("/api/qrcodes"))
        {
            var registro = new AuditLog
            {
                ClienteId = context.User.FindFirst("ClienteId")?.Value,
                UsuarioId = context.User.FindFirst("UserId")?.Value,
                TipoOperacao = context.Request.Method,
                DataHora = DateTime.UtcNow,
                IPAddress = context.Connection.RemoteIpAddress?.ToString(),
                UserAgent = context.Request.Headers["User-Agent"].ToString(),
                Endpoint = path
            };

            await _auditoria.RegistrarAsync(registro);
        }

        await next(context);
    }
}
```

---

### 4.4 Controle de Acesso (RBAC)

**Permissoes**:

| Permissao | Descricao | Perfis |
|-----------|-----------|--------|
| `qrcode:qrcode:create` | Criar novo QRCode | Admin, Gerente Ativos, Operacional |
| `qrcode:qrcode:read` | Visualizar QRCode | Todos (autenticados) |
| `qrcode:qrcode:update` | Editar informações QRCode | Admin, Gerente Ativos |
| `qrcode:qrcode:delete` | Excluir QRCode | Admin |
| `qrcode:qrcode:print` | Imprimir etiquetas | Admin, Gerente Ativos, Operacional |
| `qrcode:leitura:execute` | Realizar leitura de QRCode | Todos (com GPS) |
| `qrcode:checkin:execute` | Fazer check-in | Admin, Gerente Ativos, Operacional |
| `qrcode:checkout:execute` | Fazer check-out | Admin, Gerente Ativos, Operacional |
| `qrcode:inventario:execute` | Executar inventário bulk | Admin, Gerente Ativos |
| `qrcode:export:execute` | Exportar dados de QRCode | Admin, Gerente Ativos |
| `qrcode:auditlog:read` | Visualizar logs de auditoria | Admin |

**Policy-based Rules**:
```csharp
public class QRCodeAuthorizationPolicy
{
    public static void ConfigureAuthorizationPolicies(IServiceCollection services)
    {
        services.AddAuthorizationBuilder()
            .AddPolicy("CanCreateQRCode", policy =>
                policy.RequireAssertion(context =>
                    context.User.HasClaim("qrcode:qrcode:create", "true") ||
                    context.User.IsInRole("Admin")
                )
            )
            .AddPolicy("CanReadQRCode", policy =>
                policy.RequireAuthentication()
            )
            .AddPolicy("CanDeleteQRCode", policy =>
                policy.RequireRole("Admin")
            )
            .AddPolicy("CanExecuteInventario", policy =>
                policy.RequireAssertion(context =>
                    context.User.HasClaim("qrcode:inventario:execute", "true") &&
                    context.User.FindFirst("ClienteId")?.Value != null
                )
            );
    }
}

// Usar em controller
[Authorize(Policy = "CanCreateQRCode")]
[HttpPost("qrcodes")]
public async Task<IActionResult> CreateQRCode(CreateQRCodeCommand command)
{
    // Implementação
}
```

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Metodo | Endpoint | Descricao | Permissao | Status Code |
|--------|----------|-----------|-----------|------------|
| GET | `/api/qrcodes` | Listar QRCodes paginádo | `qrcode:qrcode:read` | 200, 403 |
| GET | `/api/qrcodes/{id}` | Obter QRCode por ID | `qrcode:qrcode:read` | 200, 404, 403 |
| POST | `/api/qrcodes` | Criar novo QRCode | `qrcode:qrcode:create` | 201, 400, 409, 403 |
| PUT | `/api/qrcodes/{id}` | Atualizar QRCode | `qrcode:qrcode:update` | 200, 404, 400, 403 |
| DELETE | `/api/qrcodes/{id}` | Excluir QRCode | `qrcode:qrcode:delete` | 204, 404, 409, 403 |

**Exemplo GET /api/qrcodes**:
```
GET /api/qrcodes?page=1&pageSize=10&search=Servidor
Authorization: Bearer {token}

Resposta 200:
{
    "total": 156,
    "page": 1,
    "pageSize": 10,
    "items": [
        {
            "id": "K9mL2qR8sT3uV1wX5yZ",
            "ativoId": "AT-2024-00123",
            "nomeAtivo": "Servidor de Arquivo",
            "codigoPatrimonial": "PAT-001234",
            "localizacao": "Sala de Servidor, Piso 2",
            "dataGeracao": "2025-12-28T10:30:00Z",
            "dataUltimaLeitura": "2025-12-28T14:45:00Z",
            "usuarioUltimaLeitura": "operador@empresa.com",
            "status": "ATIVO"
        }
    ]
}
```

### 5.2 Operacoes Especiais

| Metodo | Endpoint | Descricao | Permissao | Status Code |
|--------|----------|-----------|-----------|------------|
| GET | `/api/qrcodes/{id}/imagem` | Obter imagem PNG QRCode | `qrcode:qrcode:read` | 200 (image/png), 404 |
| POST | `/api/qrcodes/{id}/imprimir` | Gerar PDF etiqueta | `qrcode:qrcode:print` | 200 (application/pdf), 404, 403 |
| POST | `/api/qrcodes/ler` | Ler e registrar leitura de QRCode | `qrcode:leitura:execute` | 200, 400, 404 |
| POST | `/api/qrcodes/{id}/checkin` | Check-in de ativo | `qrcode:checkin:execute` | 200, 400, 409, 403 |
| POST | `/api/qrcodes/{id}/checkout` | Check-out de ativo | `qrcode:checkout:execute` | 200, 404, 409, 403 |
| GET | `/api/qrcodes/{id}/historico` | Obter histórico de leituras | `qrcode:qrcode:read` | 200, 404 |
| POST | `/api/qrcodes/inventario/iniciar` | Iniciar sessão de inventário | `qrcode:inventario:execute` | 201, 400, 403 |
| POST | `/api/qrcodes/inventario/{sessaoId}/processar` | Processar lote de QR Codes | `qrcode:inventario:execute` | 200, 400, 404, 403 |
| GET | `/api/qrcodes/inventario/{sessaoId}/resultado` | Obter resultado do inventário | `qrcode:inventario:execute` | 200, 404 |
| GET | `/api/qrcodes/{id}/localizacao` | Obter localização atual + mapa | `qrcode:qrcode:read` | 200, 404 |
| POST | `/api/qrcodes/validar` | Validar QRCode sem registrar leitura | `qrcode:qrcode:read` | 200, 400 |
| GET | `/api/qrcodes/exportar/csv` | Exportar lista em CSV | `qrcode:export:execute` | 200 (text/csv), 403 |
| GET | `/api/qrcodes/{id}/auditlog` | Obter histórico de auditoria | `qrcode:auditlog:read` | 200, 404, 403 |

**Exemplo POST /api/qrcodes/ler**:
```
POST /api/qrcodes/ler
Content-Type: application/json
Authorization: Bearer {token}

Request:
{
    "qrCodeId": "K9mL2qR8sT3uV1wX5yZ",
    "latitude": -23.5505,
    "longitude": -46.6333,
    "accuracyMeters": 8.5,
    "localizacao": "Sala de Servidor, Piso 2"
}

Resposta 200:
{
    "sucesso": true,
    "qrCodeId": "K9mL2qR8sT3uV1wX5yZ",
    "ativoId": "AT-2024-00123",
    "nomeAtivo": "Servidor de Arquivo",
    "dataHoraLeitura": "2025-12-28T14:45:00Z",
    "localizacao": "Rua Vergueiro, 3100, São Paulo, SP, Brasil",
    "coordenadas": {
        "latitude": -23.5505,
        "longitude": -46.6333,
        "precisao": "ALTA"
    },
    "confiabilidadeGPS": "ALTA"
}
```

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Geração de QRCode

```
Usuário acessa /qrcodes/create
    |
    v
Selecionar Ativo (RF014)
    |
    v
Sistema valida ativo existe
    |
    +--- NÃO ENCONTRADO ---> Erro 404
    |
    v (SIM)
Gerar GUID aleatório
    |
    v
Calcular CheckDigit (Luhn)
    |
    v
Codificar em Base64URL
    |
    v
Gerar imagem QR Code via ZXing.Net
    |
    v
Salvar em Azure Blob Storage
    |
    v
Registrar em BD: QRCode + AtivoId + ClienteId
    |
    v
Registrar auditoria: QRCODE_CREATE
    |
    v
Retornar QRCodeId ao usuário
    |
    v
[FIM SUCESSO]
```

### 6.2 Fluxo de Leitura de QRCode

```
Usuário abre PWA Mobile /mobile/qrcode-reader
    |
    v
Solicitar permissão para câmera + GPS (Geolocation API)
    |
    +--- NEGADO ---> Erro: "Permissões obrigatórias"
    |
    v (CONCEDIDO)
Aguardar captura de QR Code
    |
    v
Usuário aponta câmera para QRCode
    |
    v
ZXing.js decodifica QRCode
    |
    +--- FALHOU ---> Mensagem: "QRCode não detectado. Posicione melhor"
    |
    v (SUCESSO)
Capturar coordenadas GPS via Geolocation API
    |
    v
Validar precisão >= 10 metros
    |
    +--- FALHOU ---> Aviso: "Precisão GPS baixa ({{accuracy}}m). Continuar mesmo assim?"
    |
    v (SIM ou OK)
Validar CheckDigit (Luhn)
    |
    +--- FALHOU ---> Erro: "QRCode inválido ou falsificado"
    |
    v (VALIDO)
Enviar para API: POST /api/qrcodes/ler
    |
    v
[Servidor] Verificar ClienteId (tenant isolation)
    |
    v
[Servidor] Reverter coordenadas para endereço (Azure Maps)
    |
    v
[Servidor] Registrar leitura em QRCodeLeitura
    |
    v
[Servidor] Registrar auditoria: QRCODE_READ
    |
    v
Retornar confirmação ao mobile
    |
    v
Mobile exibe: "✓ Leitura registrada em {{localizacao}}"
    |
    v
[FIM SUCESSO]
```

### 6.3 Fluxo de Check-in/Check-out

```
Usuário seleciona QRCode lido
    |
    v
Exibir opção: [Check-in] [Check-out]
    |
    +--- CHECK-IN
    |    |
    |    v
    |    Verificar último status do ativo
    |    |
    |    +--- JÁ EM CHECK-IN ---> Alerta: "Ativo sem check-out anterior em {{local}}"
    |    |                        [Confirmar] [Cancelar]
    |    |
    |    v (CONFIRMAR ou SEM CHECK-IN ANTERIOR)
    |    Registrar CHECK-IN em QRCodeCheckIn
    |    |
    |    v
    |    Atualizar status ativo: CHECKED_IN
    |    |
    |    v
    |    Registrar auditoria: QRCODE_CHECKIN
    |    |
    |    v
    |    [FIM SUCESSO]
    |
    +--- CHECK-OUT
         |
         v
         Verificar se ativo está em CHECK-IN
         |
         +--- NÃO ---> Erro: "Ativo não está em check-in"
         |
         v (SIM)
         Registrar CHECK-OUT com timestamp
         |
         v
         Atualizar status ativo: CHECKED_OUT
         |
         v
         Calcular tempo de permanência
         |
         v
         Registrar auditoria: QRCODE_CHECKOUT
         |
         v
         [FIM SUCESSO]
```

### 6.4 Fluxo de Inventário Bulk

```
Usuário seleciona: Inventário > Iniciar
    |
    v
Exibir modal para upload de arquivo (CSV) ou leitura em tempo real
    |
    v [UPLOAD CSV]
Validar arquivo:
- Máximo 1.000 linhas
- Formato: 1 QRCode por linha
    |
    +--- INVÁLIDO ---> Erro com detalhes
    |
    v (VÁLIDO)
Criar SessaoInventario com ID único
    |
    v
Dividir em lotes de 100 QR Codes
    |
    v
Processar lotes em paralelo (Task.WhenAll)
    |
    v
Para cada QR Code:
    - Validar CheckDigit
    - Verificar se existe no BD
    - Registrar leitura
    |
    v
Sincronizar com BD ativos:
- Marcar como "verificado no inventário"
- Registrar data/hora da verificação
    |
    v
Registrar auditoria: QRCODE_INVENTARIO
    |
    v
Gerar relatório:
- Total lidos: 987
- Sucesso: 985
- Erros: 2
- Tempo: 3m 42s
    |
    v
[FIM SUCESSO]
```

---

## 7. SEGURANCA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **Validação CheckDigit (Luhn)** | QR Code falsificado é detectado antes de acessar BD. Garante que QRCode vem de gerador autorizado. |
| **Tenant Isolation (ClienteId)** | Cada QR Code vinculado a ClienteId. Usuário de Tenant A não consegue ler QRCode de Tenant B. Query sempre filtra por ClienteId do usuário autenticado. |
| **HTTPS Obrigatório** | Todas as comunicações entre mobile e servidor são HTTPS. Certificado TLS 1.3 mínimo. |
| **Autenticação JWT** | Token JWT contém ClienteId + UsuarioId. Renovado a cada 30 minutos. Refresh token com 7 dias de validade. |
| **GPS Spoofing Detection** | Coordenadas comparadas com histórico. Se movimento > 500km em < 1 min, registra suspeita e alerta. |
| **Rate Limiting** | Máximo 1000 leituras por usuário por hora. API retorna 429 (Too Many Requests) se exceder. |
| **Auditoria Imutável** | Logs em tabela AuditLog com replicação geográfica (Azure). Nenhuma deleção, apenas anonimização. |
| **CORS Restritivo** | Apenas frontend autorizado pode fazer requisições. Header `Access-Control-Allow-Origin` limitado ao domínio corporativo. |
| **SQL Injection Protection** | Todos os queries usam parameterização via LINQ/EF Core. Nenhuma concatenação de SQL. |
| **XSS Protection** | Frontend usa Angular com sanitização automática. Backend retorna `Content-Type: application/json` (nunca text/html sem escape). |

### 7.2 Testes de Seguranca Obrigatorios

- [ ] SQL Injection: Tentar input: `'; DROP TABLE QRCodeLeitura; --`
- [ ] XSS: Tentar input com script: `<img src=x onerror=alert('XSS')>`
- [ ] CSRF: Enviar requisição POST sem CSRF token
- [ ] Validacao de permissoes: Tentar deletar QRCode de outro tenant
- [ ] GPS Spoofing: Simular movimento > 500km/min
- [ ] Rate Limiting: Fazer 1500 requisições em 1 hora
- [ ] Tenant Isolation: Modificar ClienteId no JWT e tentar acessar dados de outro tenant
- [ ] Falsificacao de CheckDigit: Gerar QRCode com checksum incorreto
- [ ] Token Expiration: Tentar usar token após 30 minutos
- [ ] Bruteforce QRCode: Tentar adivinhar QRCode válido via POST bulk
- [ ] Bluetooth Spoofing (mobile): Simular leitura de QRCode falso via PWA offline

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao |
|-----|------|---------|
| **Tempo de Geração de QRCode** | < 1 segundo | De click "Gerar" até QRCode no BD |
| **Tempo de Leitura e Registro** | < 2 segundos | De captura até confirmação no mobile |
| **Disponibilidade da API** | > 99.9% | Uptime de /api/qrcodes endpoints |
| **Acurácia de Geolocalização** | <= 10 metros | Desvio máximo entre GPS capturado vs coordenada real |
| **Taxa de Sucesso de Inventário Bulk** | >= 99% | QRCodes lidos com sucesso / Total esperado |
| **Rejeição de QRCodes Falsificados** | 100% | 0 QRCodes com checksum inválido são aceitos |
| **Tempo de Anonimização LGPD** | <= 24 horas | Dados expirados (24 meses) são anonimizados no dia seguinte |
| **Taxa de Conformidade Auditoria** | 100% | Todas as operações registradas em AuditLog |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **Falha de Geolocalização** | GPS com acurácia > 50m por > 5 leituras consecutivas | Investigar qualidade do sinal. Pausar operação se falhar. |
| **Suspeita de GPS Spoofing** | Movimento > 500km entre 2 leituras em < 1 minuto | Marcar leitura como "SUSPEITA". Investigar IP do usuário. |
| **Limite de Inventário Excedido** | Usuario tenta ler > 1000 QRCodes em uma sessão | Retornar erro 400. Sugerir dividir em 2 sessões. |
| **Falha de Checksum** | QRCode com CheckDigit inválido é lido | Alerta ao usuário. Registrar tentativa em AuditLog com flag "FALSIFICACAO_SUSPEITA". |
| **Replicação de Dados Atrasada** | Azure Blob Storage replica em > 5 minutos | Criar ticket para DevOps. Não bloqueia operação (usa cache local). |
| **Taxa de Erro de API > 5%** | Mais de 5% das requisições retornam 500 | Page-on para suporte técnico. Iniciar investigação de logs. |
| **Auditoria com Retenção Expirada** | Dados com > 24 meses não anonimizados | Job falhou. Executar manualmente. Investigar truncamento de permissões. |

---

## 9. PROXIMOS PASSOS

1. **Casos de Uso**: Criar [UC-107](./UC-RF107.md)
2. **Modelo de Dados**: Criar [MD-107](./MD-RF107.md)
3. **Fluxos de Tela**: Criar [WF-107](./WF-RF107.md)
4. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml)
5. **Implementacao Backend**: Commands/Queries/Handlers (CQRS + MediatR)
6. **Implementacao Frontend**: Componentes Angular + PWA Mobile
7. **Testes E2E**: Playwright para fluxos críticos
8. **Integracao com RF014/RF015**: Vincular ativos e localizações

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versao inicial com 10 RNs, 13 endpoints, integrações completas | Claude Code |

---

**Ultima Atualizacao**: 2025-12-28
**Autor**: Claude Code (Modernização IA)
**Revisao**: Pendente
