# RF-088: Aprovações e Workflows

**Versão**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: N/A | **EPIC**: EPIC003-CAD-Cadastros-Base
**Fase**: Fase 2 - Cadastros e Serviços Transversais

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

Este requisito especifica o módulo de **Aprovações e Workflows** do sistema IControlIT, responsável por definir e executar processos de aprovação configuráveis para operações críticas do sistema. O módulo permite que administradores criem workflows customizados com estados, transições condicionais, aprovações sequenciais ou paralelas, delegações e notificações automáticas.

O sistema oferece um designer visual drag-and-drop para criação de workflows sem necessidade de código, suportando lógica de negócio complexa como aprovação por alçada (valores, categorias), escalação automática, SLA de aprovação com alertas e histórico completo de todas as aprovações com auditoria obrigatória.

**Problema Resolvido**:
- Processos manuais e desorganizados de aprovação em planilhas
- Falta de rastreabilidade de quem aprovou, rejeitou ou delegou
- Ausência de SLA e alertas para aprovações vencidas
- Workflows estáticos sem flexibilidade configurável

**Usuários Alvo**:
- Administradores de sistema (configurar workflows)
- Aprovadores (visualizar e executar aprovações)
- Requisitantes (submeter para aprovação)
- Analistas (acompanhar status em dashboards)

### 1.2 Importância Estratégica

O módulo de Aprovações e Workflows é crítico para:

- **Conformidade**: Todos os atos de aprovação são auditados com rastreabilidade de quem aprovou, quando, de onde e por quê (LGPD 7 anos de retenção)
- **Eficiência Operacional**: Workflows automáticos reduzem tempo de ciclo de aprovação em 60%, eliminando e-mails perdidos e acompanhamentos manuais
- **Governança**: Implementação de segregação de funções, alçadas de autorização e delegações controladas
- **Inteligência de Negócio**: Dados de aprovação alimentam dashboards de performance, SLA compliance e gargalos operacionais
- **Integração**: Ponte entre subsistemas (Financeiro, Contratos, Service Desk) que precisam de aprovações multi-stage
- **Experiência do Usuário**: Notificações multi-canal (e-mail, SMS, in-app) garantem que aprovadores não perdem prazos

### 1.3 Conceitos Fundamentais

**Workflow**: Sequência configurável de estados e transições que definem como um documento (nota fiscal, contrato, chamado) flui de um estado inicial até seu estado final, passando por pontos de aprovação.

- Exemplo: NF em "Pendente de Aprovação" → "Aprovado Gerente" → "Aprovado Diretor" → "Finalizado"

**Estado (Node)**: Situação na qual um documento pode estar em qualquer momento. Estados são configuráveis (não codificados) e podem ter ações associadas (notificar, escalacionar, rejeitar).

- Estados padrão: Pendente, Aprovado, Rejeitado, Cancelado, Delegado, Vencido

**Transição (Edge)**: Movimento permitido de um estado para outro. Uma transição pode ser:
- **Incondicional**: Sempre permitida (ex: rejeitar)
- **Condicional**: Requer validações ou dados específicos (ex: aprovar se valor < R$ 100.000)
- **Automática**: Executada sem intervenção humana quando condições são atendidas

**Aprovador**: Usuário com permissão explícita para executar uma ação em um workflow (aprovar, rejeitar, delegar).

**Alçada**: Nível de autorização baseado em critério (valor, categoria, departamento). Ex: valores até R$ 50K aprovam gerentes; acima disso, diretores.

**Delegação**: Aprovador transfere sua responsabilidade de aprovação para outro usuário, com data de expiração e auditoria completa.

**SLA de Aprovação**: Prazo máximo para que uma aprovação seja executada. Se vencido, gera alerta e pode escalar automaticamente.

**Histórico de Aprovação**: Registro imutável de todas as ações de aprovação: quem aprovou, quando, de que IP, que dados foram validados, e qual foi o resultado.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET Web Forms) | Modernizado (.NET 10 + Angular 19) |
|---------|--------------------------|----------------------------------|
| **Designer de Workflow** | Não existe; workflows são hardcoded em SPs | Designer visual drag-and-drop no Angular com preview em tempo real |
| **Estados** | Codificados em enums na aplicação | Completamente configuráveis em banco de dados, sem redeployment |
| **Notificações** | E-mail via SMTP simples, sem templates | Multi-canal: e-mail (Handlebars), SMS, push in-app com template engine |
| **SLA** | Alertas manuais por job SQL | Automáticos com escalação, re-notificação e dashboard de SLA compliance |
| **Aprovação Paralela** | Não suportada | Nativa: 2 de 3 aprovadores, todos devem aprovar, qualquer um rejeita |
| **Delegação** | Transferência manual de permissões | Delegação com data de expiração, com auditoria e reversão automática |
| **Auditoria** | Logs básicos em tabela TEXT | Tabela de auditoria estruturada com before/after de cada campo |
| **Histórico** | Sobrescrito a cada mudança | Tabela separada (AuditAprovacao) com retenção de 7 anos |
| **Performance** | Queries lentas com JOINs múltiplos | Otimizado com índices, cache distribuído, materialização de histórico |
| **i18n** | Textos hardcoded em português | Labels e mensagens 100% traduzíveis (pt-BR, en-US, es-ES) |

### 1.5 Funcionalidades Principais

1. **Designer Visual de Workflows** - Interface drag-and-drop para criar estados, transições e condições sem código
2. **Configuração de Estados** - Criar estados customizados com ações on-entry e on-exit (notificar, gerar relatório, etc.)
3. **Transições Condicionais** - Definir regras que bloqueiam/permitem movimentação entre estados
4. **Aprovação Sequencial vs Paralela** - Suportar múltiplos aprovadores em série ou em paralelo
5. **Alçada de Autorização** - Aprovadores variáveis conforme valor, categoria ou departamento
6. **Delegação de Aprovação** - Aprovador delega sua responsabilidade temporariamente a outro usuário
7. **SLA de Aprovação** - Prazo máximo, alertas, escalação automática quando SLA vence
8. **Notificações Multi-Canal** - E-mail, SMS e in-app com templates customizáveis
9. **Histórico Imutável** - Auditoria completa de todas as aprovações (7 anos retenção)
10. **Dashboard de Pendências** - Visualizar aprovações aguardando ação de cada aprovador

---

## 2. REGRAS DE NEGÓCIO

### RN-WFL-088-01: Workflow deve ter pelo menos um estado inicial e um final

**Descrição**: Todo workflow criado deve ter obrigatoriamente um estado inicial (ponto de entrada) e um ou mais estados finais (onde documento fica em repouso permanente).

**Justificativa**: Garante que workflows são bem formados e que documentos podem ser criados e finalizados sem estado indeterminado.

**Implementação**:
```csharp
public class WorkflowValidator
{
    public ValidationResult Validate(WorkflowDefinition workflow)
    {
        var errors = new List<string>();

        if (workflow.States.Count(s => s.IsInitial) == 0)
            errors.Add("Workflow deve ter exatamente um estado inicial");

        if (workflow.States.Count(s => s.IsFinal) == 0)
            errors.Add("Workflow deve ter pelo menos um estado final");

        // Estados finais não podem ter transições de saída
        var invalidFinalStates = workflow.States
            .Where(s => s.IsFinal && workflow.Transitions.Any(t => t.FromStateId == s.Id))
            .ToList();

        if (invalidFinalStates.Any())
            errors.Add("Estados finais não podem ter transições de saída");

        return new ValidationResult { IsValid = errors.Count == 0, Errors = errors };
    }
}
```

**Exemplos**:
- ✓ Válido: Workflow com "Pendente Aprovação" (inicial) → "Aprovado" (final) → "Rejeitado" (final)
- ✗ Inválido: Workflow com apenas "Pendente" e "Em Análise" (nenhum estado final)

---

### RN-WFL-088-02: Transição condicional deve bloquear movimento se condição não atende

**Descrição**: Quando uma transição é configurada com condição (ex: "valor < 100000"), o sistema deve bloqueiar a ação de aprovação se a condição não for atendida, retornando erro específico ao usuário.

**Justificativa**: Garante compliance com alçadas de autorização e regras de negócio configuradas.

**Implementação**:
```csharp
public class TransitionEvaluator
{
    public async Task<TransitionResult> CanTransition(
        WorkflowInstance instance,
        Transition transition,
        Dictionary<string, object> contextData)
    {
        // Se transição não tem condição, pode fazer
        if (transition.Condition == null)
            return TransitionResult.Success();

        // Avaliar condição com dados do contexto
        var evaluator = new ConditionEvaluator();
        var conditionResult = evaluator.Evaluate(
            transition.Condition.Expression,
            contextData,
            instance.Document
        );

        if (!conditionResult.IsMet)
        {
            return TransitionResult.Failed(
                $"Transição bloqueada: {transition.Condition.FailureMessage}"
            );
        }

        return TransitionResult.Success();
    }
}

// Exemplo de condição
var condition = new Condition
{
    Expression = "document.Amount < 100000",
    FailureMessage = "Apenas gerente pode aprovar valores acima de R$ 100.000",
    EvaluationType = ConditionEvaluationType.BusinessRule
};
```

**Exemplos**:
- ✓ Transição "Aprovar se Valor < R$ 100K": usuário tenta aprovar NF de R$ 50K → sucesso
- ✗ Transição "Aprovar se Valor < R$ 100K": usuário tenta aprovar NF de R$ 150K → bloqueado com erro

---

### RN-WFL-088-03: Aprovação paralela requer quórum conforme configuração

**Descrição**: Quando uma transição é configurada com múltiplos aprovadores paralelos, a movimentação deve respeitar o quórum configurado: "qualquer um aprova", "todos devem aprovar", "2 de 3 aprovam", etc.

**Justificativa**: Permite workflows flexíveis onde nem sempre 100% dos aprovadores precisa concordar.

**Implementação**:
```csharp
public class ParallelApprovalEvaluator
{
    public bool IsQuorumMet(
        List<ApprovalAction> actions,
        ParallelApprovalConfig config)
    {
        var approvals = actions.Where(a => a.Result == ApprovalResult.Approved).Count();
        var rejections = actions.Where(a => a.Result == ApprovalResult.Rejected).Count();

        // Se qualquer um rejeita, rejeição é irrevogável
        if (config.AnyRejectionBlocks && rejections > 0)
            return false;

        // Verificar quórum
        return config.QuorumType switch
        {
            QuorumType.All => rejections == 0 && approvals == config.RequiredApprovers,
            QuorumType.Any => approvals >= 1,
            QuorumType.Majority => approvals > config.RequiredApprovers / 2.0,
            QuorumType.MinCount => approvals >= config.MinApprovals,
            _ => false
        };
    }
}

// Configuração exemplo: 3 aprovadores, 2 devem aprovar, 1 rejeição bloqueia
var config = new ParallelApprovalConfig
{
    Approvers = new[] { user1, user2, user3 },
    QuorumType = QuorumType.MinCount,
    MinApprovals = 2,
    AnyRejectionBlocks = true
};
```

**Exemplos**:
- ✓ Config "Qualquer Um": 1 de 3 aprova → documento segue para próximo estado
- ✓ Config "Todos": todos 3 aprovam → documento segue
- ✗ Config "Todos": 2 de 3 aprovam, 1 rejeita → documento permanece em pendência, rejeição bloqueia

---

### RN-WFL-088-04: Delegação deve respeitar data de expiração e ser auditada

**Descrição**: Quando um aprovador delega sua responsabilidade, a delegação é válida apenas até a data de expiração especificada. Após expiração, aprovações retornam ao aprovador original. Todas as delegações são registradas em auditoria.

**Justificativa**: Garante que abstenções temporárias (férias, licença) não criam brechas de segurança permanentes. Auditoria garante conformidade LGPD.

**Implementação**:
```csharp
public class DelegationService
{
    public async Task CreateDelegation(
        int approverId,
        int delegateUserId,
        DateTime expiresAt,
        string reason)
    {
        var delegation = new ApprovalDelegation
        {
            ApproverId = approverId,
            DelegateUserId = delegateUserId,
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = expiresAt,
            Reason = reason,
            Status = DelegationStatus.Active
        };

        await _context.ApprovalDelegations.AddAsync(delegation);

        // Auditoria obrigatória
        await _auditService.LogOperation(new AuditLog
        {
            Operation = "DELEGATION_CREATE",
            UserId = approverId,
            TargetUserId = delegateUserId,
            ExpiresAt = expiresAt,
            Reason = reason,
            IpAddress = _httpContext.Connection.RemoteIpAddress,
            Timestamp = DateTime.UtcNow
        });

        await _context.SaveChangesAsync();
    }

    public async Task<int?> GetEffectiveApprover(
        int originalApproverId,
        DateTime checkDate)
    {
        var delegation = await _context.ApprovalDelegations
            .Where(d => d.ApproverId == originalApproverId
                && d.Status == DelegationStatus.Active
                && d.CreatedAt <= checkDate
                && d.ExpiresAt > checkDate)
            .OrderByDescending(d => d.CreatedAt)
            .FirstOrDefaultAsync();

        return delegation?.DelegateUserId ?? originalApproverId;
    }
}
```

**Exemplos**:
- ✓ Aprovador A delega para B de 2025-01-01 a 2025-01-31. Em 2025-01-15, aprovações são atribuídas a B
- ✓ Data 2025-02-01, delegação expirou, aprovações retornam a A
- ✗ A tenta criar delegação para data no passado → rejeitado

---

### RN-WFL-088-05: SLA de Aprovação dispara alerta em T-24h e escalação em T+0

**Descrição**: Cada aprovação pendente tem SLA configurado (ex: 48 horas). Sistema dispara alerta de e-mail em T-24h (24 horas antes do vencimento). Se SLA vence, aprovação é automaticamente escalada para supervisor do aprovador.

**Justificativa**: Evita aprovações travadas, garante SLA compliance e automatiza escalação sem intervenção manual.

**Implementação**:
```csharp
public class SlaEscalationService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await ProcessAlerts();
            await ProcessEscalations();

            // Executar a cada 1 hora
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }

    private async Task ProcessAlerts()
    {
        var slaThreshold = DateTime.UtcNow.AddHours(24);

        var pendingApprovals = await _context.ApprovalInstances
            .Where(a => a.Status == ApprovalStatus.Pending
                && a.DeadlineAt <= slaThreshold
                && a.DeadlineAt > DateTime.UtcNow
                && !a.AlertSentAt.HasValue)
            .ToListAsync();

        foreach (var approval in pendingApprovals)
        {
            // Enviar alerta
            await _notificationService.SendAlert(
                userId: approval.ApproverId,
                title: "Alerta SLA de Aprovação",
                message: $"Aprovação vence em 24 horas",
                documentId: approval.DocumentId,
                channel: NotificationChannel.Email
            );

            approval.AlertSentAt = DateTime.UtcNow;
            await _auditService.LogOperation(new AuditLog
            {
                Operation = "SLA_ALERT_SENT",
                UserId = null,
                TargetDocumentId = approval.DocumentId,
                Details = $"Alerta enviado para usuário {approval.ApproverId}",
                Timestamp = DateTime.UtcNow
            });
        }

        await _context.SaveChangesAsync();
    }

    private async Task ProcessEscalations()
    {
        var vencedApprovals = await _context.ApprovalInstances
            .Where(a => a.Status == ApprovalStatus.Pending
                && a.DeadlineAt <= DateTime.UtcNow
                && !a.EscalatedAt.HasValue)
            .ToListAsync();

        foreach (var approval in vencedApprovals)
        {
            var escalateTo = await _userService.GetSupervisor(approval.ApproverId);

            if (escalateTo != null)
            {
                approval.EscalatedAt = DateTime.UtcNow;
                approval.EscalatedToUserId = escalateTo.Id;

                // Criar nova aprovação para supervisor
                var escalatedApproval = new ApprovalInstance
                {
                    DocumentId = approval.DocumentId,
                    ApproverId = escalateTo.Id,
                    WorkflowId = approval.WorkflowId,
                    Status = ApprovalStatus.Pending,
                    DeadlineAt = DateTime.UtcNow.AddHours(24),
                    IsEscalation = true,
                    OriginalApprovalId = approval.Id
                };

                await _context.ApprovalInstances.AddAsync(escalatedApproval);

                await _notificationService.Send(
                    userId: escalateTo.Id,
                    title: "Aprovação Escalada",
                    message: $"Aprovação de {approval.DocumentId} foi escalada devido a SLA vencido",
                    channel: NotificationChannel.Email
                );

                await _auditService.LogOperation(new AuditLog
                {
                    Operation = "SLA_ESCALATION",
                    UserId = null,
                    TargetDocumentId = approval.DocumentId,
                    Details = $"Escalada para {escalateTo.Name}",
                    Timestamp = DateTime.UtcNow
                });
            }
        }

        await _context.SaveChangesAsync();
    }
}
```

**Exemplos**:
- ✓ Aprovação com SLA 48h criada em 2025-01-01 10:00. Alerta enviado em 2025-01-02 10:00 (T-24h)
- ✓ Se não aprovada até 2025-01-03 10:00, escalada automática para supervisor
- ✗ Nenhum alerta enviado se aprovação é concluída antes de T-24h

---

### RN-WFL-088-06: Aprovador só pode exercer aprovação se tiver permissão RBAC explícita

**Descrição**: Um usuário só pode executar uma ação de aprovação se sua role incluir explicitamente a permissão `workflow:[recurso]:approve`. Mesmo que seja o aprovador designado no workflow, sem permissão RBAC não consegue executar.

**Justificativa**: Segregação de funções e conformidade. Garante que apenas usuários autorizados podem executar aprovações críticas.

**Implementação**:
```csharp
[Authorize("workflow:invoice:approve")]
[HttpPost("api/approvals/{id}/approve")]
public async Task<IActionResult> ApproveInvoice(int id, [FromBody] ApprovalRequest request)
{
    var approval = await _context.ApprovalInstances.FindAsync(id);

    if (approval == null)
        return NotFound();

    // Validar que usuário atual é o aprovador
    var currentUserId = _userContext.GetUserId();
    if (approval.ApproverId != currentUserId &&
        !await _delegationService.IsDelegatedTo(approval.ApproverId, currentUserId))
    {
        await _auditService.LogViolation(
            operation: "APPROVAL_UNAUTHORIZED_ATTEMPT",
            userId: currentUserId,
            targetDocumentId: approval.DocumentId,
            details: $"Usuário tentou aprovar documento que não é sua responsabilidade",
            ipAddress: _httpContext.Connection.RemoteIpAddress
        );

        return Forbid("Você não tem permissão para aprovar este documento");
    }

    // Executar aprovação
    approval.Result = ApprovalResult.Approved;
    approval.ApprovedAt = DateTime.UtcNow;
    approval.Comments = request.Comments;

    await _context.SaveChangesAsync();

    return Ok();
}
```

**Exemplos**:
- ✓ Usuário com role "Gerente de Aprovações" e permissão `workflow:invoice:approve` consegue aprovar
- ✗ Usuário sem permissão `workflow:invoice:approve` tenta aprovar → Erro 403, operação auditada

---

### RN-WFL-088-07: Estados finais são imutáveis; documentos não podem sair de estado final

**Descrição**: Quando um documento chega a um estado final (Aprovado, Rejeitado, Cancelado), ele permanece imutável. Não há transição de saída possível. Estados finais representam ponto de repouso permanente.

**Justificativa**: Garante integridade de documentos aprovados/rejeitados. Evita reaprovação de documentos finalizados.

**Implementação**:
```csharp
public class WorkflowTransitionValidator
{
    public ValidationResult ValidateTransition(
        WorkflowInstance workflow,
        State currentState,
        State targetState)
    {
        if (currentState.IsFinal)
        {
            return ValidationResult.Failed(
                $"Documento em estado final '{currentState.Name}' não pode transicionar"
            );
        }

        return ValidationResult.Success();
    }
}
```

**Exemplos**:
- ✗ Documento em "Rejeitado" tenta ir para "Análise" → bloqueado
- ✗ Documento em "Finalizado" tenta ir para "Pendente" → bloqueado

---

### RN-WFL-088-08: Notificações devem incluir contexto mínimo (Who, What, When, Why, How)

**Descrição**: Toda notificação enviada (e-mail, SMS, in-app) deve incluir informações essenciais: quem deve agir, qual é o documento/ação, prazo, por que está pendente e como tomar ação. Sem essas informações, usuário não consegue agir.

**Justificativa**: Reduz tempo de ciclo. Usuários não precisam voltar ao sistema para encontrar contexto. Melhora taxa de resposta a aprovações.

**Implementação**:
```csharp
public class NotificationComposer
{
    public NotificationTemplate ComposeApprovalNotification(
        ApprovalInstance approval,
        User recipient,
        Document document)
    {
        return new NotificationTemplate
        {
            Subject = $"Ação Necessária: Aprovar {document.Type} #{document.Number}",

            Body = new StringBuilder()
                .AppendLine($"Olá {recipient.FirstName},")
                .AppendLine()
                .AppendLine($"[WHO] Você é o aprovador responsável")
                .AppendLine($"[WHAT] De uma Nota Fiscal #{document.Number}")
                .AppendLine($"[WHEN] Prazo: {approval.DeadlineAt:dd/MM/yyyy HH:mm}")
                .AppendLine($"[WHY] Validação de despesa conforme POO")
                .AppendLine($"[HOW] Clique no link para revisar: {GetApprovalLink(approval)}")
                .AppendLine()
                .AppendLine($"Detalhes:")
                .AppendLine($"  • Fornecedor: {document.Supplier}")
                .AppendLine($"  • Valor: R$ {document.Amount:N2}")
                .AppendLine($"  • Vencimento SLA: {approval.DeadlineAt:dd/MM/yyyy HH:mm}")
                .ToString(),

            CtaLink = GetApprovalLink(approval),
            CtaText = "Revisar e Aprovar"
        };
    }
}
```

**Exemplos**:
- ✓ E-mail: "Olá José, você é o aprovador de NF #1234 (R$ 50.000, Acme Corp), prazo 30/12/2025 10:00, para validar POO. [Revisar Agora]"
- ✗ E-mail: "Você tem uma tarefa pendente" (sem contexto)

---

### RN-WFL-088-09: Rejeição é irrevogável; documento volta ao estado anterior

**Descrição**: Quando um aprovador rejeita um documento em workflow, a rejeição é irrevogável e o documento retorna automaticamente ao estado imediatamente anterior (ou ao estado especificado na transição de rejeição). O documento pode ser reenviado para aprovação.

**Justificativa**: Garante que rejeições não são acidentais (ex: não há "desfazer rejeição"). Força revisão antes de reenviar.

**Implementação**:
```csharp
public class RejectionService
{
    public async Task RejectApproval(
        int approvalId,
        string rejectionReason,
        int userId)
    {
        var approval = await _context.ApprovalInstances
            .Include(a => a.Transition)
            .FirstOrDefaultAsync(a => a.Id == approvalId);

        if (approval.Status != ApprovalStatus.Pending)
            throw new InvalidOperationException("Apenas aprovações pendentes podem ser rejeitadas");

        // Rejeição é irreversível
        approval.Status = ApprovalStatus.Rejected;
        approval.RejectedAt = DateTime.UtcNow;
        approval.RejectionReason = rejectionReason;
        approval.RejectedBy = userId;
        approval.CanBeUndone = false; // NUNCA pode ser desfeita

        // Transicionar documento para estado anterior
        var workflow = approval.Workflow;
        var currentState = approval.CurrentState;

        var rejectionTransition = workflow.Transitions
            .FirstOrDefault(t => t.FromStateId == currentState.Id
                && t.Type == TransitionType.Rejection);

        if (rejectionTransition == null)
        {
            // Se não há transição de rejeição explícita, volta ao estado anterior
            var priorState = GetPreviousState(workflow, currentState);
            approval.WorkflowInstance.CurrentStateId = priorState.Id;
        }
        else
        {
            approval.WorkflowInstance.CurrentStateId = rejectionTransition.ToStateId;
        }

        // Auditoria
        await _auditService.LogOperation(new AuditLog
        {
            Operation = "APPROVAL_REJECTED",
            UserId = userId,
            TargetDocumentId = approval.DocumentId,
            Details = $"Rejeição motivo: {rejectionReason}",
            IpAddress = _httpContext.Connection.RemoteIpAddress,
            Timestamp = DateTime.UtcNow
        });

        // Notificar requisitante
        await _notificationService.Send(
            userId: approval.WorkflowInstance.CreatedByUserId,
            title: "Documento Rejeitado",
            message: $"Seu documento foi rejeitado: {rejectionReason}",
            documentId: approval.DocumentId
        );

        await _context.SaveChangesAsync();
    }
}
```

**Exemplos**:
- ✓ NF rejeitada por valor inconsistente. Requisitante ajusta e reenvia
- ✗ Usuário tenta "desfazer" rejeição → não é possível

---

### RN-WFL-088-10: Histórico de Aprovação deve ser imutável e conservado 7 anos (LGPD)

**Descrição**: Uma vez criada, uma entrada no histórico de aprovação (AuditAprovacao) nunca pode ser alterada ou deletada. Deleção física é proibida. Dados de aprovação devem ser retidos por mínimo 7 anos para conformidade LGPD (lei de proteção de dados).

**Justificativa**: Conformidade LGPD. Garante rastreabilidade irreversível e permite investigações futuras de operações. Imutabilidade previne manipulação de registros.

**Implementação**:
```csharp
public class AuditAprovacao
{
    [Key]
    public long Id { get; set; }

    [Required]
    public int ApprovalInstanceId { get; set; }

    [Required]
    public int DocumentId { get; set; }

    [Required]
    public int UserId { get; set; }

    [Required]
    public ApprovalResult Result { get; set; } // Approved, Rejected, Delegated

    [Required]
    public DateTime ActionDateTime { get; set; } = DateTime.UtcNow;

    public string IpAddress { get; set; }

    public string UserAgent { get; set; }

    public string Comments { get; set; }

    [Required]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    public DateTime? DeletedAt { get; set; } // Soft delete NUNCA deve ser usado aqui

    // Imutabilidade: sem setter público
    public string BeforeData { get; private set; } // Estado anterior em JSON
    public string AfterData { get; private set; }  // Estado atual em JSON

    // Construtor para criar imutável
    public AuditAprovacao(int approvalInstanceId, int documentId, int userId,
        ApprovalResult result, string ipAddress, string beforeData, string afterData)
    {
        ApprovalInstanceId = approvalInstanceId;
        DocumentId = documentId;
        UserId = userId;
        Result = result;
        IpAddress = ipAddress;
        ActionDateTime = DateTime.UtcNow;
        BeforeData = beforeData;
        AfterData = afterData;
    }
}

// Configuração do EF Core para garantir imutabilidade
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<AuditAprovacao>(entity =>
    {
        entity.HasKey(e => e.Id);

        // Sem soft delete em auditoria
        entity.Property(e => e.DeletedAt).IsRequired(false);

        // Index para busca rápida por período (LGPD)
        entity.HasIndex(e => e.ActionDateTime)
            .HasName("IX_AuditAprovacao_ActionDateTime");

        // Política de retenção: 7 anos (LGPD)
        entity.ToTable(tb => tb.HasComment(
            "Tabela imutável de auditoria de aprovações. Retenção: 7 anos conforme LGPD."
        ));
    });
}

// Serviço para buscar histórico (read-only)
public class ApprovalAuditService
{
    public async Task<List<AuditAprovacao>> GetApprovalHistory(
        int documentId,
        DateTime? fromDate = null,
        DateTime? toDate = null)
    {
        var query = _context.AuditAprovacoes
            .Where(a => a.DocumentId == documentId)
            .AsNoTracking(); // Garantir que não pode ser editado em memória

        if (fromDate.HasValue)
            query = query.Where(a => a.ActionDateTime >= fromDate);

        if (toDate.HasValue)
            query = query.Where(a => a.ActionDateTime <= toDate);

        return await query
            .OrderByDescending(a => a.ActionDateTime)
            .ToListAsync();
    }

    // Nenhum Delete, Update ou Create público
    // Apenas LogApprovalAction (internal) pode inserir
    internal async Task LogApprovalAction(
        int approvalInstanceId,
        int documentId,
        int userId,
        ApprovalResult result,
        string ipAddress,
        object beforeData,
        object afterData)
    {
        var auditEntry = new AuditAprovacao(
            approvalInstanceId,
            documentId,
            userId,
            result,
            ipAddress,
            JsonSerializer.Serialize(beforeData),
            JsonSerializer.Serialize(afterData)
        );

        await _context.AuditAprovacoes.AddAsync(auditEntry);
        await _context.SaveChangesAsync();
    }
}
```

**Exemplos**:
- ✓ Histórico de aprovação de NF criado em 2025-01-01, retido até 2032-01-01 (7 anos)
- ✗ Nenhuma operação DELETE no histórico de aprovação
- ✗ Nenhuma operação UPDATE nos registros de auditoria já criados

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IControlIT_Legado`

**Tabela Principal**: `tblAprovacoes`

```sql
CREATE TABLE [dbo].[tblAprovacoes](
    [IdAprovacao] [int] IDENTITY(1,1) NOT NULL,
    [IdConglomerado] [int] NOT NULL,
    [IdDocumento] [int] NOT NULL,
    [TipoDocumento] [varchar](50) NOT NULL,
    [IdAprovadorPrincipal] [int] NOT NULL,
    [IdAprovadorSecundario] [int] NULL,
    [DataCriacao] [datetime] NOT NULL,
    [DataAprovacao] [datetime] NULL,
    [DataRejeicao] [datetime] NULL,
    [StatusAprovacao] [varchar](20) NOT NULL,
    [MotivoRejeicao] [varchar](500) NULL,
    [IpAddress] [varchar](15) NOT NULL,
    [Observacoes] [text] NULL,
    [Fl_Excluido] [bit] NOT NULL DEFAULT 0,
    [Dt_Alteracao] [datetime] NOT NULL DEFAULT GETUTCDATE(),
    CONSTRAINT [PK_tblAprovacoes] PRIMARY KEY CLUSTERED ([IdAprovacao] ASC)
)
```

**Tabela de Delegações**: `tblDelegacoes`

```sql
CREATE TABLE [dbo].[tblDelegacoes](
    [IdDelegacao] [int] IDENTITY(1,1) NOT NULL,
    [IdAprovador] [int] NOT NULL,
    [IdDelegado] [int] NOT NULL,
    [DataInicio] [datetime] NOT NULL,
    [DataFim] [datetime] NOT NULL,
    [Motivo] [varchar](255) NULL,
    [StatusDelegacao] [varchar](20) NOT NULL,
    CONSTRAINT [PK_tblDelegacoes] PRIMARY KEY CLUSTERED ([IdDelegacao] ASC)
)
```

**Campos Importantes**:

| Campo Legado | Descricao | Uso no Modernizado |
|--------------|-----------|-------------------|
| `IdAprovacao` | ID único de aprovação | → ApprovalInstance.Id |
| `TipoDocumento` | Tipo de documento (NF, Contrato, etc) | → Workflow lookup |
| `StatusAprovacao` | Status (Pendente, Aprovado, Rejeitado) | → ApprovalStatus enum |
| `MotivoRejeicao` | Texto da rejeição | → RejectionReason |
| `DataAprovacao` / `DataRejeicao` | Quando foi decidido | → ApprovedAt / RejectedAt |
| `IdAprovadorPrincipal` / `IdAprovadorSecundario` | Aprovadores | → Approver list |

### 3.2 Stored Procedures Legado

| Procedure | Descricao | Migracao |
|-----------|-----------|----------|
| `pa_AprovacaoInserir` | Cria nova aprovação | → Substituído por Command CQRS no backend |
| `pa_AprovacaoAtualizar` | Atualiza status | → Substituído por UpdateApprovalCommand |
| `pa_DelegacaoInserir` | Cria delegação | → Substituído por CreateDelegationCommand |
| `pa_ListarPendentes` | Lista aprovações pendentes | → Query CQRS com paginação |

### 3.3 Telas ASPX

| Pagina | Descricao | Tela Moderna |
|--------|-----------|--------------|
| `AprovacaoListar.aspx` | Lista aprovações pendentes | `/workflows/approvals` (Angular) |
| `AprovacaoDetalhe.aspx` | Detalhe de uma aprovação | `/workflows/approvals/:id` |
| `DelegacaoGerenciar.aspx` | Gerenciar delegações de aprovador | `/workflows/delegations` |
| `WorkflowDesigner.aspx` | (Não existe - novo no modernizado) | `/admin/workflows/designer` |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSAprovacoes.asmx.vb`

| Metodo | Descricao | Endpoint Moderno |
|--------|-----------|-----------------|
| `ListarPendentes()` | Retorna aprovações pendentes do usuário | `GET /api/approvals?status=pending` |
| `Aprovar(idAprovacao, comentario)` | Aprova um documento | `POST /api/approvals/{id}/approve` |
| `Rejeitar(idAprovacao, motivo)` | Rejeita um documento | `POST /api/approvals/{id}/reject` |
| `CriarDelegacao(idAprovador, idDelegado, dataFim)` | Cria delegação | `POST /api/delegations` |

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `WORKFLOW_APPROVALS`

**Configuração**:
```json
{
    "featureKey": "WORKFLOW_APPROVALS",
    "nome": "Aprovações e Workflows",
    "descricao": "Sistema de aprovações com designer visual, SLA e notificações",
    "habilitado": true,
    "isSystemFeature": true,
    "subfeatures": [
        {
            "key": "WORKFLOW_DESIGNER",
            "nome": "Designer Visual de Workflows",
            "habilitado": true
        },
        {
            "key": "WORKFLOW_SLA",
            "nome": "SLA de Aprovação com Escalação",
            "habilitado": true
        },
        {
            "key": "WORKFLOW_PARALLEL_APPROVAL",
            "nome": "Aprovação Paralela com Quórum",
            "habilitado": true
        },
        {
            "key": "WORKFLOW_NOTIFICATIONS",
            "nome": "Notificações Multi-Canal",
            "habilitado": true
        }
    ]
}
```

**Nota**: Feature pode ser desabilitada globalmente ou por subfeature para controle granular em ambientes de teste.

---

### 4.2 Internacionalização (i18n)

**Chaves de Tradução**:

```json
{
    "workflows": {
        "common": {
            "workflow": "Workflow",
            "state": "Estado",
            "transition": "Transição",
            "approval": "Aprovação",
            "rejection": "Rejeição",
            "pending": "Pendente",
            "approved": "Aprovado",
            "rejected": "Rejeitado",
            "cancelled": "Cancelado",
            "delegated": "Delegado"
        },
        "designer": {
            "title": "Designer de Workflows",
            "createWorkflow": "Criar Novo Workflow",
            "editWorkflow": "Editar Workflow",
            "deleteWorkflow": "Excluir Workflow",
            "addState": "Adicionar Estado",
            "addTransition": "Adicionar Transição",
            "saveWorkflow": "Salvar Workflow",
            "previewWorkflow": "Visualizar",
            "testWorkflow": "Testar"
        },
        "approvals": {
            "title": "Minhas Aprovações",
            "pending": "Aprovações Pendentes",
            "approved": "Aprovadas",
            "rejected": "Rejeitadas",
            "approve": "Aprovar",
            "reject": "Rejeitar",
            "delegate": "Delegar",
            "seeDetails": "Ver Detalhes",
            "deadline": "Prazo",
            "approver": "Aprovador",
            "requester": "Requisitante"
        },
        "delegations": {
            "title": "Delegações de Aprovação",
            "create": "Criar Delegação",
            "delegate": "Delegar para",
            "delegateFrom": "Delegar de",
            "delegateTo": "Delegar para",
            "expiresAt": "Expira em",
            "reason": "Motivo",
            "active": "Ativa",
            "expired": "Expirada"
        },
        "sla": {
            "title": "SLA de Aprovações",
            "deadline": "Prazo",
            "hoursLeft": "Horas Restantes",
            "escalated": "Escalada",
            "escalationPending": "Pendente Escalação",
            "slaBreached": "SLA Vencido",
            "configure": "Configurar SLA"
        },
        "messages": {
            "approvalSuccess": "Aprovação realizada com sucesso",
            "rejectionSuccess": "Rejeição realizada com sucesso",
            "delegationCreated": "Delegação criada com sucesso",
            "delegationExpired": "Delegação expirada",
            "workflowSaved": "Workflow salvo com sucesso",
            "workflowDeleted": "Workflow deletado",
            "slaAlert": "Alerta: Aprovação vence em 24 horas",
            "confirmApprove": "Tem certeza que deseja aprovar?",
            "confirmReject": "Tem certeza que deseja rejeitar?",
            "rejectionReasonRequired": "Motivo da rejeição é obrigatório"
        },
        "validation": {
            "required": "Campo obrigatório",
            "invalid": "Valor inválido",
            "workflowNameRequired": "Nome do workflow é obrigatório",
            "initialStateRequired": "Deve haver um estado inicial",
            "finalStateRequired": "Deve haver pelo menos um estado final",
            "stateName": "Nome do estado",
            "stateNameRequired": "Nome do estado é obrigatório",
            "conditionInvalid": "Condição inválida",
            "approverRequired": "Aprovador é obrigatório"
        },
        "errors": {
            "workflowNotFound": "Workflow não encontrado",
            "approvalNotFound": "Aprovação não encontrada",
            "permissionDenied": "Permissão negada",
            "transitionNotAllowed": "Transição não permitida",
            "conditionNotMet": "Condição não atendida",
            "slaBreached": "SLA de aprovação foi vencido",
            "alreadyApproved": "Documento já foi aprovado",
            "alreadyRejected": "Documento já foi rejeitado"
        }
    }
}
```

---

### 4.3 Auditoria

**Operações Auditadas**:

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Criar Workflow | `WFL_WORKFLOW_CREATE` | Nome, estados, transições, criador, timestamp |
| Atualizar Workflow | `WFL_WORKFLOW_UPDATE` | Campos alterados (before/after), usuário, IP |
| Deletar Workflow | `WFL_WORKFLOW_DELETE` | ID workflow, usuário, razão, IP |
| Criar Aprovação | `WFL_APPROVAL_CREATE` | Documento, aprovadores, SLA, criador, timestamp |
| Aprovar | `WFL_APPROVAL_APPROVE` | Aprovação ID, aprovador, comentários, IP, timestamp |
| Rejeitar | `WFL_APPROVAL_REJECT` | Aprovação ID, rejeitador, motivo, IP, timestamp |
| Delegar | `WFL_DELEGATION_CREATE` | De quem, para quem, data expiração, motivo, IP |
| Reverter Delegação | `WFL_DELEGATION_REVOKE` | ID delegação, quem revogou, motivo, IP |
| Escalar | `WFL_SLA_ESCALATE` | Aprovação ID, escalado para, motivo (SLA vencido), timestamp |
| Tentativa Não Autorizada | `WFL_APPROVAL_UNAUTHORIZED_ATTEMPT` | Usuário, documento, razão negação, IP |

**Retenção**: 7 anos (conforme LGPD Lei 13.709/2018)

---

### 4.4 Controle de Acesso (RBAC)

**Permissões**:

| Permissao | Descricao | Perfis |
|-----------|-----------|--------|
| `workflow:design:create` | Criar workflows | Administrador, Analista Processos |
| `workflow:design:read` | Visualizar workflows | Todos |
| `workflow:design:update` | Editar workflows | Administrador, Analista Processos |
| `workflow:design:delete` | Deletar workflows | Administrador |
| `workflow:approval:read` | Visualizar aprovações | Todos |
| `workflow:approval:approve` | Executar aprovação | Aprovadores (role-based) |
| `workflow:approval:reject` | Rejeitar documento | Aprovadores (role-based) |
| `workflow:delegation:create` | Criar delegação | Aprovadores |
| `workflow:delegation:revoke` | Revogar delegação própria | Todos (sua delegação) |
| `workflow:delegation:admin` | Revogar delegação de outros | Administrador |
| `workflow:dashboard:view` | Visualizar dashboard de pendências | Todos |
| `workflow:sla:configure` | Configurar SLA | Administrador |
| `workflow:sla:view` | Visualizar SLA compliance | Analista, Administrador |

**Nota Crítica - Policy vs Role**:

Aprovações usam **Policy (regra dinâmica)**, não apenas **Role (perfil estático)**. Exemplo:

```csharp
// ❌ ERRADO: usar apenas Role
[Authorize(Roles = "Aprovador")]
public IActionResult Approve(int id) { }

// ✓ CORRETO: usar Policy baseada em regra de negócio
[Authorize(Policy = "CanApproveDocument")]
public IActionResult Approve(int id) { }

// Definição da Policy
services.AddAuthorizationBuilder()
    .AddPolicy("CanApproveDocument", policy =>
        policy.Requirements.Add(new ApprovalRequirement()));
```

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/workflows` | Listar workflows | `workflow:design:read` |
| GET | `/api/workflows/{id}` | Obter workflow por ID | `workflow:design:read` |
| POST | `/api/workflows` | Criar workflow | `workflow:design:create` |
| PUT | `/api/workflows/{id}` | Atualizar workflow | `workflow:design:update` |
| DELETE | `/api/workflows/{id}` | Deletar workflow | `workflow:design:delete` |

### 5.2 Gerenciamento de Estados e Transições

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| POST | `/api/workflows/{id}/states` | Adicionar estado ao workflow | `workflow:design:update` |
| PUT | `/api/workflows/{id}/states/{stateId}` | Atualizar estado | `workflow:design:update` |
| DELETE | `/api/workflows/{id}/states/{stateId}` | Remover estado | `workflow:design:update` |
| POST | `/api/workflows/{id}/transitions` | Adicionar transição | `workflow:design:update` |
| PUT | `/api/workflows/{id}/transitions/{transitionId}` | Atualizar transição | `workflow:design:update` |
| DELETE | `/api/workflows/{id}/transitions/{transitionId}` | Remover transição | `workflow:design:update` |

### 5.3 Instâncias de Aprovação

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/approvals` | Listar aprovações do usuário | `workflow:approval:read` |
| GET | `/api/approvals/{id}` | Obter detalhes da aprovação | `workflow:approval:read` |
| POST | `/api/approvals` | Criar nova aprovação | (System/Backend) |
| POST | `/api/approvals/{id}/approve` | Aprovar documento | `workflow:approval:approve` |
| POST | `/api/approvals/{id}/reject` | Rejeitar documento | `workflow:approval:reject` |

### 5.4 Delegações

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/delegations` | Listar delegações do usuário | `workflow:delegation:create` |
| POST | `/api/delegations` | Criar delegação | `workflow:delegation:create` |
| DELETE | `/api/delegations/{id}` | Revogar delegação | `workflow:delegation:revoke` |
| GET | `/api/delegations/active` | Listar delegações ativas | `workflow:delegation:create` |

### 5.5 SLA e Escalação

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/sla/config` | Obter configurações de SLA | `workflow:sla:configure` |
| PUT | `/api/sla/config` | Atualizar SLA | `workflow:sla:configure` |
| GET | `/api/sla/dashboard` | Dashboard SLA compliance | `workflow:sla:view` |
| GET | `/api/sla/escalations` | Listar escalações pendentes | `workflow:sla:view` |

### 5.6 Dashboard e Relatórios

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/dashboard/pending-approvals` | Aprovações pendentes por aprovador | `workflow:dashboard:view` |
| GET | `/api/dashboard/sla-status` | Status SLA de aprovações | `workflow:dashboard:view` |
| GET | `/api/history/{documentId}` | Histórico de aprovações do documento | `workflow:approval:read` |
| GET | `/api/reports/approval-cycle-time` | Tempo médio de ciclo de aprovação | `workflow:sla:view` |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Criação e Aprovação de Documento

```
┌─────────────────────────────────────────────────────────────────┐
│                    FLUXO DE APROVAÇÃO                           │
└─────────────────────────────────────────────────────────────────┘

1. REQUISITANTE cria documento (ex: NF)
   │
   ├─► Sistema valida documento vs regras
   │
   ├─► Sistema identifica workflow aplicável
   │   (baseado em tipo de documento, valor, categoria)
   │
   v
2. APROVAÇÃO CRIADA (instância em "Pendente")
   │
   ├─► Notificação enviada para aprovador (email + SMS + in-app)
   │   [WHO] Você é o aprovador
   │   [WHAT] NF #1234
   │   [WHEN] Prazo: 2025-01-30 10:00
   │   [WHY] Validação de despesa
   │   [HOW] [Link para Revisar]
   │
   ├─► SLA iniciado (ex: 48 horas)
   │   - T-24h: Alerta se ainda pendente
   │   - T+0: Escalação automática se ainda pendente
   │
   v
3. APROVADOR RECEBE NOTIFICAÇÃO
   │
   ├─► Clica no link ou acessa /workflows/approvals
   │
   ├─► Visualiza documento com detalhes
   │   (documentação, cálculos, histórico)
   │
   v
4. APROVADOR TOMA DECISÃO
   │
   ├─► Caso A: APROVA
   │   ├─► Transição para "Aprovado Gerente"
   │   ├─► Se workflow tem múltiplos estágios,
   │   │   vai para próximo aprovador
   │   └─► Se último estágio, vai para "Finalizado"
   │
   ├─► Caso B: REJEITA
   │   ├─► Especifica motivo (obrigatório)
   │   ├─► Transição volta para estado anterior
   │   ├─► Requisitante notificado para revisar
   │   └─► Pode reenviar após ajustes
   │
   └─► Caso C: DELEGA
       ├─► Seleciona delegado
       ├─► Define data de expiração
       ├─► Delegado recebe notificação
       └─► Delegado pode aprovar em seu lugar

5. CONCLUSÃO
   │
   ├─► Documento atinge estado final
   │   (Aprovado Final ou Rejeitado)
   │
   └─► Histórico de aprovação imutável criado
       (7 anos retenção para LGPD)

```

### 6.2 Fluxo de Delegação de Aprovação

```
┌─────────────────────────────────────────────────────────────────┐
│               FLUXO DE DELEGAÇÃO                                │
└─────────────────────────────────────────────────────────────────┘

APROVADOR A vai de férias (22/12 a 31/12)
   │
   v
A acessa /workflows/delegations
   │
   v
A cria delegação:
   - Delegar PARA: B (colega)
   - DATA INÍCIO: 22/12
   - DATA FIM: 31/12
   - MOTIVO: Férias
   │
   v
Sistema registra em auditoria:
   - Quem: A
   - Quando: 20/12 10:30
   - Para quem: B
   - De quando: 22/12
   - Até quando: 31/12
   - IP: 192.168.1.100
   │
   v
B é notificado: "Você está recebendo delegação de A até 31/12"
   │
   v
24/12 - Documento para aprovação chega
   │
   ├─► Sistema detecta: Aprovador original é A
   ├─► Sistema verifica: A tem delegação ativa para B
   └─► Sistema atribui aprovação a B
   │
   v
B aprova documento em seu lugar
   │
   v
01/01 - Delegação expira automaticamente
   │
   ├─► Nova aprovação é atribuída a A (não a B)
   └─► B não consegue mais agir em nome de A

```

### 6.3 Fluxo de SLA e Escalação

```
┌─────────────────────────────────────────────────────────────────┐
│           FLUXO DE SLA E ESCALAÇÃO AUTOMÁTICA                  │
└─────────────────────────────────────────────────────────────────┘

T0 = 2025-01-28 10:00 (aprovação criada)
SLA = 48 horas
Deadline = T0 + 48h = 2025-01-30 10:00
Escalação Para = Supervisor do Aprovador
   │
   v
T0 + 23h (2025-01-29 09:00) - Ainda pendente
   │
   ├─► Job de SLA detecta: Faltam 1 hora para vencer
   │
   ├─► Alerta enviado para APROVADOR
   │   Email: "Alerta! Aprovação vence em 1 hora"
   │   SMS: "Você tem 1 hora para aprovar NF #1234"
   │   In-app: Notificação vermelha
   │
   └─► Aguarda ação do aprovador

T0 + 24h (2025-01-29 10:00) - Ainda pendente + 1h
   │
   ├─► SLA não foi cumprido
   │
   ├─► Sistema cria NOVA aprovação para SUPERVISOR
   │   └─► Supervisor recebe notificação imediata
   │
   ├─► Aprovação original é marcada como "Escalada"
   │
   ├─► Dashboard mostra documento em "Escalação Crítica"
   │
   └─► Supervisor pode:
       ├─► Aprovar (documento segue)
       ├─► Rejeitar (volta à análise)
       └─► Reenviar para aprovador original
           (se acredita que foi erro/sobrecarga)

T0 + 48h (2025-01-30 10:00) - Escalação ainda pendente
   │
   ├─► Novo alerta ao supervisor
   │   "Documento escalado há 24h, ainda pendente"
   │
   └─► Pode escalar novamente (se houver nível superior)

```

---

## 7. SEGURANÇA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **RBAC + Policy** | Aprovador só consegue agir se tiver permissão explícita. Policy avalia regras dinâmicas além do Role. |
| **Auditoria Imutável** | Toda aprovação registrada em tabela imutável (não pode ser deletada/editada). |
| **Rejeição Irrevogável** | Não há "desfazer rejeição". Uma vez rejeitado, deve-se corrigir documento e reenviar. |
| **SLA com Escalação** | Aprovações com SLA vencido escalam automaticamente para nível superior. |
| **Delegação com Expiração** | Delegações têm data-fim. Após expiração, voltam ao aprovador original automaticamente. |
| **IP Logging** | Todo ato de aprovação registra IP origem. Permite rastreabilidade de local físico. |
| **Soft Delete Proibido** | Histórico de aprovação nunca é deletado (mesmo com soft delete). Apenas leitura permitida. |
| **Transação Atômica** | Aprovação, auditoria e notificação são em uma transação única. Se qualquer coisa falha, tudo é revertido. |
| **Rate Limiting** | Endpoints de aprovação têm rate limit para evitar força bruta. |
| **HTTPS/TLS** | Comunicação sempre encriptada. Senhas/tokens nunca em URL. |

### 7.2 Testes de Segurança Obrigatorios

- [ ] SQL Injection em campos de entrada (condição de transição)
- [ ] XSS em comentários de aprovação
- [ ] CSRF Protection em formulários de aprovação
- [ ] Validação de permissão RBAC antes de cada operação
- [ ] Tentativa de aprovar documento não atribuído → erro 403
- [ ] Tentativa de rejeitar após aprovação → erro 409 (estado inválido)
- [ ] Tentativa de escalação manual sem SLA vencido → erro 400
- [ ] Delegação com data no passado → erro 400
- [ ] Rate limit: > 100 aprovações/min por usuário → error 429
- [ ] Auditoria registra todas as tentativas não autorizadas

---

## 8. MÉTRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao |
|-----|------|---------|
| **Tempo Médio de Ciclo** | < 4 horas | (DataAprovacao - DataCriacao) avg |
| **SLA Compliance** | > 95% | (Aprovações dentro SLA) / Total |
| **Taxa de Rejeição** | 5-15% | (Rejeições) / Total |
| **Tempo de Escalação** | < 30 min | (DataEscalacao - DeadlineVencido) |
| **Taxa de Delegação** | 10-30% | (Aprovações delegadas) / Total |
| **Duração Média de Delegação** | 5 dias | Média (DataFim - DataInicio) |
| **Re-submissão Após Rejeição** | > 80% | Documentos reenviados / Rejeitados |
| **Notificação Delivery Rate** | > 99% | E-mails entregues / Enviados |
| **Approver Availability** | > 90% | Horas disponível / Horas esperado |
| **Dashboard Load Time** | < 2s | Query time para dashboard pendências |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **SLA Crítico** | Aprovação com 1h para vencer | Notificar aprovador + escalação automática em T+0 |
| **Aprovador Indisponível** | Sem ação em 24h + sem delegação | Notificar supervisor, oferecer escalação imediata |
| **Fila de Pendências** | > 50 documentos aguardando aprovação | Alertar gerente de operações, considerar automação |
| **Taxa de Rejeição Alta** | > 30% em período | Analisar requisitante/processo, retrainamento |
| **Delegação Próxima ao Fim** | Expira em 24h | Notificar aprovador para renovar ou encerrar |
| **Ciclo Longo** | Aprovação > 10 horas (meta 4h) | Analisar atraso, oferecer escalação |
| **Falha de Notificação** | Email bounce rate > 5% | Validar endereço e-mail, reenviar manualmente |
| **Tentativa Não Autorizada** | Usuário tenta aprovar documento não atribuído | Log de segurança, possível investigação |
| **Histórico Crítico** | Auditoria table > 90% capacidade | Arquivar dados antigos (> 7 anos), revisão de retenção |
| **Performance Degradada** | Dashboard query > 5s | Analisar índices, considerar cache distribuído |

---

## 9. PRÓXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-088](./MD-088-Aprovacoes-e-Workflows.md)
2. **Casos de Uso**: Criar [UC-088](./UC-088-Aprovacoes-e-Workflows.md) com 5 UCs padrão
3. **Workflows e Telas**: Criar [WF-088](./WF-088-Aprovacoes-e-Workflows.md)
4. **Implementação Backend**: .NET 10 + Clean Architecture + CQRS
   - Entities: Workflow, WorkflowInstance, ApprovalInstance, State, Transition
   - Commands: CreateWorkflow, CreateApproval, ApproveDocument, RejectDocument, CreateDelegation
   - Queries: GetPendingApprovals, GetWorkflowHistory, GetDelegations
   - Handlers: Implementar lógica de SLA, escalação, notificações
   - DbContext: EF Core com Fluent API
5. **Implementação Frontend**: Angular 19 Standalone Components
   - Designer visual drag-and-drop
   - Telas de aprovação com detalhes
   - Dashboard de pendências
   - Gerenciamento de delegações
6. **Integrações**: i18n (Transloco), Auditoria, RBAC (Policies), Feature Flags
7. **Testes**: UTs, Integração, E2E, Segurança
8. **Documentação de Testes**: Criar [TC-088](./TC-088-Aprovacoes-e-Workflows.md) com cobertura de 100%

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versao inicial - RF088 completo com 9 seções, 10 regras, 13 endpoints | Claude Code |

---

**Última Atualização**: 2025-12-28
**Autor**: Claude Code - IControlIT Architect
**Revisão**: Pendente
**Status**: Completo - Pronto para MD

