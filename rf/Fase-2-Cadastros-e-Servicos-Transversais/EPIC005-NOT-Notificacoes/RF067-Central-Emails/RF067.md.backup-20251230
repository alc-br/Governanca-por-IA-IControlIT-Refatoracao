# RF067 - Central de E-mails

## 1. RESUMO EXECUTIVO

Sistema centralizado de gestão de envio de e-mails transacionais e marketing com filas de prioridade, retry automático, rastreamento completo (entrega, abertura, cliques, bounces), templates, blacklist, SMTP pools e conformidade com leis anti-spam (LGPD, CAN-SPAM).

**Importância:** Garantir deliverability, evitar blacklist, compliance LGPD, métricas de engajamento, histórico completo 7 anos.

**Funcionalidades:** Fila de envio, retry automático, rastreamento completo, SMTP pools, blacklist, warmup de IPs, relatórios de deliverability.

---

## 2. REGRAS DE NEGÓCIO

### RN001: Fila de Prioridades
**Descrição:** E-mails transacionais têm prioridade sobre marketing.

```csharp
public enum PrioridadeEmail
{
    Critica = 1,      // Senha reset, 2FA
    Alta = 2,         // Aprovações, alertas
    Normal = 3,       // Notificações gerais
    Baixa = 4,        // Marketing, newsletters
    Bulk = 5          // Campanhas massivas
}

[Hangfire.Queue("emails-criticos")]
public async Task ProcessarEmailCritico(Guid emailId) { }

[Hangfire.Queue("emails-normais")]
public async Task ProcessarEmailNormal(Guid emailId) { }
```

---

### RN002: SMTP Pools
**Descrição:** Múltiplos servidores SMTP com balanceamento e failover.

```csharp
public class SMTPPool
{
    public List<SMTPServer> Servers { get; set; }
    public string Strategy { get; set; } // ROUND_ROBIN, LEAST_USED, FAILOVER
}

public async Task<SMTPServer> SelecionarServidor()
{
    var servidores = await _context.SMTPServers
        .Where(s => s.Ativo && s.SaudeOK)
        .OrderBy(s => s.EmailsEnviados24h)
        .ToListAsync();

    return servidores.FirstOrDefault();
}
```

---

### RN003: Retry Automático com Backoff
**Descrição:** Retry até 5x com intervalo exponencial.

```csharp
public async Task EnviarComRetry(Email email, int tentativa = 1)
{
    try
    {
        await _smtpClient.SendMailAsync(email);
        email.Status = "ENVIADO";
    }
    catch (SmtpException ex)
    {
        if (tentativa < 5)
        {
            var delay = TimeSpan.FromMinutes(Math.Pow(2, tentativa)); // 2, 4, 8, 16, 32 min
            BackgroundJob.Schedule(() => EnviarComRetry(email, tentativa + 1), delay);
        }
        else
        {
            email.Status = "FALHA_PERMANENTE";
            await _logger.LogError($"Falha permanente ao enviar e-mail {email.Id}: {ex.Message}");
        }
    }
}
```

---

### RN004: Rastreamento Completo
**Descrição:** Rastrear entrega, abertura, cliques, bounces, unsubscribe.

```csharp
public class EventoEmail
{
    public Guid EmailId { get; set; }
    public string TipoEvento { get; set; } // ENVIADO, ENTREGUE, ABERTO, CLICADO, BOUNCE, SPAM, UNSUBSCRIBE
    public DateTime DataEvento { get; set; }
    public string DetalhesEvento { get; set; }
    public string IPUsuario { get; set; }
    public string UserAgent { get; set; }
}
```

---

### RN005: Blacklist Automática
**Descrição:** Adicionar automaticamente e-mails com hard bounce à blacklist.

```csharp
public async Task ProcessarBounce(Guid emailId, string motivo)
{
    var email = await _context.Emails.FindAsync(emailId);

    if (motivo == "HARD_BOUNCE") // E-mail inexistente
    {
        await _blacklistService.Adicionar(email.Destinatario, "Hard bounce");
        email.Status = "BOUNCE";
    }
    else if (motivo == "SOFT_BOUNCE") // Caixa cheia, temporário
    {
        // Retry após 1 hora
        BackgroundJob.Schedule(() => EnviarComRetry(email, 1), TimeSpan.FromHours(1));
    }
}
```

---

### RN006: Rate Limiting por Domínio
**Descrição:** Limitar envios por domínio para evitar spam flags.

```csharp
public async Task<bool> PodeEnviar(string dominio)
{
    var chaveCache = $"emails:{dominio}:1h";
    var contadorAtual = await _redis.StringGetAsync(chaveCache);

    if (contadorAtual.HasValue && int.Parse(contadorAtual) >= 100)
    {
        // Atingiu limite de 100 e-mails/hora para este domínio
        return false;
    }

    await _redis.StringIncrementAsync(chaveCache);
    await _redis.KeyExpireAsync(chaveCache, TimeSpan.FromHours(1));
    return true;
}
```

---

### RN007: Warmup de IPs Novos
**Descrição:** Aumentar gradualmente volume de envios em IPs novos.

```csharp
public class WarmupIP
{
    public string IP { get; set; }
    public int DiaWarmup { get; set; } // 1-30
    public int LimiteDiario => DiaWarmup switch
    {
        1 => 50,
        2 => 100,
        3 => 250,
        4 => 500,
        5 => 1000,
        _ when DiaWarmup < 15 => 2000,
        _ => int.MaxValue // Sem limite após 15 dias
    };
}
```

---

### RN008: Validação de E-mail
**Descrição:** Validar sintaxe e verificar MX record antes de enviar.

```csharp
public async Task<bool> ValidarEmail(string email)
{
    // 1. Validar sintaxe
    if (!EmailValidator.IsValid(email))
        return false;

    // 2. Verificar domínio tem MX record
    var dominio = email.Split('@')[1];
    var mxRecords = await Dns.GetMxRecordsAsync(dominio);

    return mxRecords.Any();
}
```

---

### RN009: Unsubscribe com 1 Clique
**Descrição:** Link de descadastramento sem exigir login (LGPD).

```csharp
[AllowAnonymous]
public async Task<IActionResult> Unsubscribe(string token)
{
    var email = await _tokenService.DecriptarToken(token);

    await _blacklistService.Adicionar(email, "Unsubscribe do usuário");

    return View("UnsubscribeSuccess");
}
```

---

### RN010: Monitoramento de Saúde SMTP
**Descrição:** Health check a cada 5 minutos em todos os servidores SMTP.

```csharp
[Hangfire.RecurringJob("*/5 * * * *")] // A cada 5 min
public async Task MonitorarSMTP()
{
    var servidores = await _context.SMTPServers.ToListAsync();

    foreach (var servidor in servidores)
    {
        try
        {
            await _smtpClient.ConnectAsync(servidor.Host, servidor.Port);
            servidor.SaudeOK = true;
            servidor.UltimoCheckSucesso = DateTime.UtcNow;
        }
        catch (Exception ex)
        {
            servidor.SaudeOK = false;
            await _alertService.NotificarFalhaSMTP(servidor, ex.Message);
        }
    }

    await _context.SaveChangesAsync();
}
```

---

### RN011: SPF, DKIM, DMARC
**Descrição:** Validar configuração DNS para máxima deliverability.

```csharp
public class ConfiguracaoSMTP
{
    public string DominioRemetente { get; set; }
    public string RegistroSPF { get; set; } // "v=spf1 include:_spf.google.com ~all"
    public string ChaveDKIM { get; set; }
    public string PoliticaDMARC { get; set; } // "v=DMARC1; p=quarantine; rua=mailto:dmarc@example.com"
}
```

---

### RN012: Templates de E-mail
**Descrição:** Integração com RF064 para templates.

---

### RN013: Supressão de Duplicatas
**Descrição:** Não enviar mesmo e-mail 2x em 24h.

```csharp
public async Task<bool> JaEnviadoRecentemente(string destinatario, string assunto)
{
    var limite = DateTime.UtcNow.AddHours(-24);

    return await _context.Emails
        .AnyAsync(e => e.Destinatario == destinatario
            && e.Assunto == assunto
            && e.DataEnvio > limite
            && e.Status == "ENVIADO");
}
```

---

### RN014: Relatório de Deliverability
**Descrição:** Dashboard com taxa de entrega, abertura, bounce por período.

```csharp
public async Task<RelatorioDeliverability> GerarRelatorio(DateTime inicio, DateTime fim)
{
    var emails = await _context.Emails
        .Where(e => e.DataEnvio >= inicio && e.DataEnvio <= fim)
        .ToListAsync();

    return new RelatorioDeliverability
    {
        TotalEnviados = emails.Count,
        TaxaEntrega = emails.Count(e => e.Status == "ENTREGUE") / (double)emails.Count * 100,
        TaxaAbertura = emails.Count(e => e.Aberto) / (double)emails.Count * 100,
        TaxaBounce = emails.Count(e => e.Status == "BOUNCE") / (double)emails.Count * 100,
        TaxaSpam = emails.Count(e => e.Status == "SPAM") / (double)emails.Count * 100
    };
}
```

---

### RN015: Integração com Provedores
**Descrição:** Suporte para SendGrid, Mailgun, Amazon SES, SMTP próprio.

```csharp
public interface IEmailProvider
{
    Task<EnvioResult> Enviar(Email email);
    Task<List<EventoEmail>> ObterEventos(Guid emailId);
}

public class SendGridProvider : IEmailProvider { }
public class MailgunProvider : IEmailProvider { }
public class AmazonSESProvider : IEmailProvider { }
public class SMTPProvider : IEmailProvider { }
```

---

## 3. REQUISITOS NÃO FUNCIONAIS

- Performance: 10.000 e-mails/minuto
- Disponibilidade: 99.95% uptime
- Deliverability: Taxa de entrega > 98%
- Latência: E-mail crítico enviado em < 5 segundos

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades
```sql
INSERT INTO SistemaFuncionalidade (Codigo, Nome)
VALUES ('NOT.CENTRAL_EMAILS', 'Central de E-mails');
```

### 4.2 Auditoria
`EMAIL_ENVIADO`, `EMAIL_BOUNCE`, `EMAIL_SPAM`, `EMAIL_UNSUBSCRIBE`

### 4.3 RBAC
```csharp
public static class EmailsPermissions
{
    public const string Send = "NOT.EMAILS.SEND";
    public const string ViewAll = "NOT.EMAILS.VIEW_ALL";
    public const string ManageSMTP = "NOT.EMAILS.MANAGE_SMTP";
}
```

---

## 5. MODELO DE DADOS

```csharp
public class Email : AuditableEntity
{
    public Guid Id { get; set; }
    public string Remetente { get; set; }
    public string Destinatario { get; set; }
    public string Assunto { get; set; }
    public string CorpoHTML { get; set; }
    public PrioridadeEmail Prioridade { get; set; }
    public string Status { get; set; } // FILA, ENVIADO, ENTREGUE, BOUNCE, SPAM
    public DateTime? DataEnvio { get; set; }
    public bool Aberto { get; set; }
    public DateTime? DataAbertura { get; set; }
    public int TotalCliques { get; set; }
    public List<EventoEmail> Eventos { get; set; }
    public Guid? TemplateId { get; set; }
    public Guid SMTPServerId { get; set; }
    public int TentativasEnvio { get; set; }
    public Guid EmpresaId { get; set; }
}

public class SMTPServer
{
    public Guid Id { get; set; }
    public string Nome { get; set; }
    public string Host { get; set; }
    public int Port { get; set; }
    public string Usuario { get; set; }
    public string Senha { get; set; }
    public bool UsarSSL { get; set; }
    public bool Ativo { get; set; }
    public bool SaudeOK { get; set; }
    public int EmailsEnviados24h { get; set; }
}
```

---

**Documento gerado em:** 2025-01-14
**Versão:** 1.0
**Status:** Aprovado

---

## ✅ PROJETO COMPLETO - 39 RFs DOCUMENTADOS

Este é o último RF (RF067) da especificação completa do IControlIT modernizado.

**Total documentado:**
- ✅ LOTE 1-4: RF026-RF046 (21 RFs)
- ✅ LOTE 5: RF048-RF052 (4 RFs)
- ✅ LOTE 6: RF053-RF057 (5 RFs)
- ✅ LOTE 7: RF059-RF062 (4 RFs)
- ✅ LOTE 8: RF063-RF067 (5 RFs)

**TOTAL: 39 Requisitos Funcionais completos e aprovados para implementação!**
