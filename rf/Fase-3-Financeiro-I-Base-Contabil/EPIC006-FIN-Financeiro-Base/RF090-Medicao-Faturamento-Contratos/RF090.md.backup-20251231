# RF-090: Medição e Faturamento de Contratos

**Versão**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF023 (Gestão de Contratos), RF032 (Notas Fiscais), RF078 (Integrações ERPs), RF089 (Conciliação Fiscal) | **EPIC**: EPIC006-FIN-Financeiro-Base
**Fase**: Fase 3 - Financeiro I - Base Contábil

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

Este requisito especifica o **módulo de Medição e Faturamento de Contratos** do sistema IControlIT, responsável pela gestão completa do ciclo de vida de medições de consumo/serviços prestados vinculados a contratos comerciais (RF023), cálculo automático de valores faturáveis, aplicação de reajustes contratuais, rateio entre centros de custo, geração de faturas (integração RF032), glosas de valores contestados e rastreamento imutável de toda operação para conformidade fiscal e contábil.

O módulo centraliza a medição períodica de consumo (fixa, variável ou híbrida), validação de períodos sem sobreposição, cálculos de reajustes econômicos (IGPM, IPCA, percentual fixo), rateio proporcional entre filiais e centros de custo, workflow de aprovação (medidor → gestor → financeiro), integração com geração de faturas e ERPs, contestação de valores com análise de glosa, e relatórios gerenciais de faturamento por período, contrato e fornecedor.

### 1.2 Importância Estratégica

O módulo de Medição e Faturamento é crítico para:

- **Receita Operacional Precisa**: Garantia de que cada contrato gera faturas corretas baseadas em consumo real medido ou contratado, evitando perda de receita por sub-faturamento ou contestações por super-faturamento
- **Automação Financeira**: Redução de 80% do trabalho manual de cálculo de faturas, aplicação de reajustes e rateio através de processamento automático via Hangfire (batch jobs)
- **Conformidade Fiscal e Contábil**: Auditoria completa de cada medição e fatura (criação, aprovação, ajuste, cancelamento) por 7 anos conforme LGPD, com rastreamento de usuário, timestamp e hash de integridade
- **Controle de Reajustes**: Aplicação automática de reajustes baseados em índices econômicos (IGPM, IPCA, INPC) em data de aniversário com simulação prévia, histórico e reversibilidade
- **Gestão de Contestação**: Workflow robusto para análise de glosas propostas por clientes com registro de justificativa, aprovação e impacto financeiro
- **Integração Multicamadas**: Sincronização automática com módulo de faturas (RF032), ERPs (RF078), conciliação fiscal (RF089) e contabilidade (RF034, RF035)
- **Intelligence Financeira**: Dashboard em tempo real de medições pendentes, aprovadas, faturadas, com análise de tendências de consumo e projeção orçamentária

### 1.3 Conceitos Fundamentais

**Medição**: Registro de consumo/serviço prestado associado a um período específico de um contrato. Pode ser fixa (valor pré-estabelecido), variável (baseada em consumo real) ou híbrida (valor base + consumo adicional).

- Exemplo: Contrato de telecom (Vivo) com consumo mensal variável medido em minutos/SMS. Medição de janeiro = 5.000 minutos, fevereiro = 4.800 minutos

**Período de Medição**: Intervalo de tempo (geralmente mês civil) para o qual é registrada consumo/prestação. Sem sobreposição, sem gaps.

- Exemplo: Jan/2025, Fev/2025, Mar/2025 (meses consecutivos, sem lacunas)

**Tipo de Medição**: Categoria que define como valor é calculado.

- **Fixa**: Valor pré-estabelecido no contrato, independente de consumo real (ex: aluguel de equipamento R$1.000/mês)
- **Variável**: Valor calculado multiplicando quantidade medida por preço unitário (ex: consumo de água em m³ × R$8,50)
- **Híbrida**: Valor base (fixo) + adicional (variável). Ex: Telecom com R$500 base + R$0,25 por minuto excedente

**Reajuste Contratual**: Aumento automático de valores conforme índice econômico na data de aniversário do contrato. RN-MED-090-07 define cálculo e aplicação.

- Exemplo: Contrato de R$12.000/ano reajustado por IPCA em 01/01/2026. IPCA acumulado = 5,5% → Novo valor = R$12.660

**Rateio**: Distribuição de valor total de medição entre filiais, centros de custo ou clientes com percentual definido na política de rateio.

- Exemplo: Medição de energia elétrica R$10.000 rateada 60% para Filial SP + 40% para Filial RJ

**Glosa**: Contestação de valor faturado proposta pelo cliente com análise de justificativa, percentual contestado e impacto financeiro.

- Exemplo: Cliente contesta 10% da fatura por falha na prestação de serviço → Análise → Aprovação de glosa de R$500

**Multi-tenancy**: Cada medição é isolada por ClienteId (cliente/empresa contratante). Nenhum dado de clientes diferentes pode ser visível. Segregação em database row-level.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Medição** | Registro manual em tabela Medicao com 3 campos (Contrato_Id, Valor, DataMedicao) | Entity completa com Tipo (Fixa, Variável, Híbrida), Quantidade, ValorUnitario, Reajustes históricos |
| **CRUD** | Telas ASPX (MedicaoLista.aspx, MedicaoDetalhe.aspx) renderizadas server-side | API REST stateless + SPA Angular com componentes reutilizáveis e lazy loading |
| **Cálculo de Fatura** | Procedure pa_CalcularFatura_Contrato executada manualmente por usuario | Job automático via Hangfire: cálculos em background, com retry e alertas de falha |
| **Reajuste** | Manual no banco de dados por DBA (UPDATE Medicao SET Valor = Valor * 1.055) | Automático com simulação, histórico de índices, projeção futura, reversibilidade |
| **Rateio** | Registrado em tabela RateioManual com percentuais estáticos | Rateio automático com suporte a regras condicionais (por volume, peso, contrato, percentual) |
| **Validação** | Sem validação de sobreposição de períodos | RN-MED-090-04: Validação automática sem gaps ou overlaps |
| **Workflow Aprovação** | Não existia; qualquer usuário podia alterar medições | State Machine com 5 estados: Rascunho → PendenteAprovacao → Aprovada → Faturada → Glosa |
| **Glosa** | Tabela TabelaGlosa simples sem auditoria | Workflow com análise de glosa, histórico, impacto financeiro e reversibilidade |
| **Integração Fatura** | Link manual entre medição e fatura | Automática: após aprovação, job gera nota fiscal via RF032 |
| **Auditoria** | Logs textuais em arquivo | Tabela de auditoria estruturada com JSON de mudanças, hash de integridade, 7 anos retenção |
| **Multi-tenancy** | Não existia | ClienteId em toda query; row-level security automático; policy enforcement em middleware |

### 1.5 Funcionalidades Principais

1. **CRUD Completo de Medições** - Criar, editar, consultar, excluir lógico com multi-tenancy garantido e validações de período
2. **Tipos de Medição Variáveis** - Suporte a Fixa, Variável e Híbrida com cálculos automáticos por tipo
3. **Validação de Períodos** - Sem sobreposição, sem gaps entre medições, alertas de falha
4. **Cálculo Automático de Valores** - Aplicação de valor base + reajustes + adicionais + impostos + descontos com histórico
5. **Reajustes Econômicos** - Automáticos por IGPM, IPCA, INPC ou percentual fixo em data de aniversário com simulação
6. **Rateio Proporcional** - Distribuição entre filiais, centros de custo, clientes com regras condicionais (volume, peso, contrato)
7. **Workflow de Aprovação** - Medidor → Gestor → Financeiro com transições validadas e rastreamento de quem/quando
8. **Geração de Faturas** - Integração automática com RF032 para criação de notas fiscais após aprovação
9. **Gestão de Glosas** - Análise de contestações de valor com registro de justificativa, decisão e impacto
10. **Relatórios de Faturamento** - Por período, contrato, fornecedor, filial com exportação Excel/PDF
11. **Dashboard de Medições** - Visão em tempo real de pendentes, aprovadas, faturadas, com alertas
12. **Notificações de Vencimento** - E-mail e SignalR para medições próximas do vencimento de período
13. **Auditoria Imutável** - Criação, alteração, aprovação, cancelamento com timestamp, usuário, IP, hash
14. **Integração com ERP** - Exportação automática de lançamento contábil para RF078
15. **Histórico Completo** - Versioning de medições, reajustes, rateios com possibilidade de consulta histórica

---

## 2. REGRAS DE NEGÓCIO

### RN-MED-090-01: Validação de Período de Medição

**Descrição**: Todo período de medição deve estar dentro da vigência do contrato associado. A data de início do período não pode ser anterior ao DataInicio do contrato, e a data de fim do período não pode ser posterior ao DataFim do contrato. Validação ocorre no command handler antes de persistência.

**Justificativa**: Prevenir medições fora do período contratual ativo, que resultariam em faturamento indevido ou divergências com auditorias contábeis. Garante conformidade com RF023.

**Implementação**:
```csharp
public class CriarMedicaoCommandHandler : ICommandHandler<CriarMedicaoCommand>
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly ILogger<CriarMedicaoCommandHandler> _logger;

    public async Task<Result> Handle(CriarMedicaoCommand command, CancellationToken ct)
    {
        // RN-MED-090-01: Validar período de medição dentro da vigência do contrato
        var contrato = await _contratoRepository.GetByIdAsync(
            command.ContratoId, command.ClienteId, ct);

        if (contrato == null)
            return Result.Failure(new ValidationError("ContratoId", "Contrato não encontrado"));

        if (command.DataInicioPeriodo < contrato.DataInicio)
            return Result.Failure(new ValidationError(
                "DataInicioPeriodo",
                $"Período não pode iniciar antes de {contrato.DataInicio:dd/MM/yyyy}"
            ));

        if (command.DataFimPeriodo > contrato.DataFim)
            return Result.Failure(new ValidationError(
                "DataFimPeriodo",
                $"Período não pode terminar após {contrato.DataFim:dd/MM/yyyy}"
            ));

        var medicao = Medicao.Criar(
            command.ClienteId,
            command.ContratoId,
            command.DataInicioPeriodo,
            command.DataFimPeriodo,
            command.TipoMedicao,
            command.ValorFixo,
            command.Quantidade,
            command.ValorUnitario
        );

        await _medicaoRepository.AddAsync(medicao, ct);
        return Result.Success();
    }
}
```

**Exemplos**:
- Válido: Contrato 01/01/2025-31/12/2025, Medição período 01/01/2025-31/01/2025
- Inválido: Contrato 01/01/2025-31/12/2025, Medição período 01/12/2024-31/12/2024 (antes do contrato)
- Inválido: Contrato 01/01/2025-31/12/2025, Medição período 01/01/2026-31/01/2026 (depois do contrato)

---

### RN-MED-090-02: Validação de Sobreposição de Períodos

**Descrição**: Não é permitido criar duas medições com períodos sobrepostos para o mesmo contrato. Cada contrato deve ter medições sequenciais sem lacunas (gap) ou sobreposição. Validação ocorre no repositório com constraint de banco de dados.

**Justificativa**: Evitar faturamento duplicado ou omissão de consumo em análises de tendência. Garante integridade histórica de medições.

**Implementação**:
```csharp
public class ValidarSobreposicaoPeriodosHandler
{
    public async Task ValidarAsync(
        int contratoId,
        int clienteId,
        DateTime dataInicio,
        DateTime dataFim,
        CancellationToken ct)
    {
        var medicoes = await _medicaoRepository
            .GetMedicoesPorContratoAsync(contratoId, clienteId, ct);

        var temSobreposicao = medicoes.Any(m =>
            (dataInicio >= m.DataInicioPeriodo && dataInicio < m.DataFimPeriodo) ||
            (dataFim > m.DataInicioPeriodo && dataFim <= m.DataFimPeriodo) ||
            (dataInicio <= m.DataInicioPeriodo && dataFim >= m.DataFimPeriodo)
        );

        if (temSobreposicao)
            throw new BusinessRuleException(
                code: "MEDICAO_PERIODO_SOBREPOSTO",
                message: $"Já existe medição com período sobreposto para este contrato"
            );
    }
}
```

**Exemplos**:
- Válido: Med1 (01/01-31/01), Med2 (01/02-29/02), Med3 (01/03-31/03)
- Inválido: Med1 (01/01-31/01), Med2 (15/01-15/02) ← sobreposição
- Inválido: Med1 (01/01-31/01), Med3 (01/03-31/03) ← gap em 01-02

---

### RN-MED-090-03: Cálculo de Valor Faturável por Tipo de Medição

**Descrição**: O valor faturável de uma medição é calculado diferentemente conforme tipo: (1) Fixa: ValorFixo, (2) Variável: Quantidade × ValorUnitario, (3) Híbrida: ValorFixo + (Quantidade × ValorUnitario). Cálculo ocorre automaticamente ao criar/atualizar medição.

**Justificativa**: Aplicar corretamente cada tipo de medição conforme contrato, evitando erros de cálculo manual e garantindo faturamento preciso.

**Implementação**:
```csharp
public class CalcularValorFaturaveelHandler
{
    public decimal CalcularValor(
        TipoMedicao tipo,
        decimal? valorFixo,
        decimal? quantidade,
        decimal? valorUnitario)
    {
        return tipo switch
        {
            TipoMedicao.Fixa =>
                valorFixo ?? throw new ValidationError("ValorFixo", "Obrigatório para medição fixa"),

            TipoMedicao.Variavel =>
                (quantidade ?? 0) * (valorUnitario ?? 0),

            TipoMedicao.Hibrida =>
                (valorFixo ?? 0) + ((quantidade ?? 0) * (valorUnitario ?? 0)),

            _ => throw new InvalidOperationException($"Tipo de medição inválido: {tipo}")
        };
    }
}
```

**Exemplos**:
- Fixa: ValorFixo=R$1.000 → Faturável=R$1.000
- Variável: Quantidade=5.000min, ValorUnitario=R$0,05 → Faturável=R$250
- Híbrida: ValorFixo=R$500, Quantidade=1.000, ValorUnitario=R$0,10 → Faturável=R$600

---

### RN-MED-090-04: Aplicação de Reajuste Contratual

**Descrição**: Em data de aniversário do contrato (DataInicio), reajustes automáticos são aplicados conforme índice configurado no contrato (IGPM, IPCA, INPC ou percentual fixo). O sistema cria novo registro de reajuste com valor anterior, valor novo, índice aplicado, e motivo. Historicamente rastreável.

**Justificativa**: Automatizar aplicação de reajustes, eliminar erros manuais, garantir conformidade com índices oficiais e facilitar análise de impacto orçamentário.

**Implementação**:
```csharp
public class AplicarReajusteContratoAutomaticoJob : IBackgroundJob
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IIndiceEconomicoService _indiceService;
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<AplicarReajusteContratoAutomaticoJob> _logger;

    public async Task ExecuteAsync(CancellationToken ct)
    {
        var hoje = DateTime.Today;
        var contratosAReajustar = await _contratoRepository
            .GetContratosAReajustarAsync(hoje, ct);

        _logger.LogInformation(
            "Iniciando processo de reajuste automático. Total: {Total}",
            contratosAReajustar.Count
        );

        foreach (var contrato in contratosAReajustar)
        {
            try
            {
                // Obter índice econômico
                var indice = await _indiceService.GetIndiceAsync(
                    contrato.TipoReajuste,
                    contrato.DataAniversarioAno(hoje),
                    ct
                );

                if (indice == null)
                    throw new BusinessRuleException(
                        code: "INDICE_NAO_DISPONIVEL",
                        message: $"Índice {contrato.TipoReajuste} não disponível"
                    );

                // Calcular novos valores
                var percentualReajuste = contrato.TipoReajuste == TipoReajuste.Percentual
                    ? contrato.ValorPercentualReajuste
                    : indice.ValorPercentual;

                var medicoes = await _medicaoRepository
                    .GetMedicoesPorContratoAsync(contrato.Id, contrato.ClienteId, ct);

                // Atualizar medições (somente pendentes e não glosas)
                foreach (var medicao in medicoes.Where(m =>
                    m.Status == MedicaoStatus.Rascunho ||
                    m.Status == MedicaoStatus.PendenteAprovacao))
                {
                    var valorAnterior = medicao.ValorFaturavel;
                    medicao.AplicarReajuste(
                        percentualReajuste,
                        indice,
                        $"Reajuste {contrato.TipoReajuste} ({percentualReajuste:P2})"
                    );

                    _logger.LogInformation(
                        "Reajuste aplicado: Medição {MedicaoId}, {ValorAnterior:C} → {ValorNovo:C}",
                        medicao.Id, valorAnterior, medicao.ValorFaturavel
                    );
                }

                await _unitOfWork.SaveChangesAsync(ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "Erro ao reajustar contrato {ContratoId}",
                    contrato.Id
                );
            }
        }
    }
}
```

**Exemplos**:
- Contrato R$12.000/ano, Reajuste IPCA 5,5% em 01/01/2026 → Novo valor = R$12.660
- Contrato R$1.000/mês, Reajuste percentual fixo 3% em vencimento → Novo valor = R$1.030/mês

---

### RN-MED-090-05: Rateio Proporcional entre Centros de Custo

**Descrição**: Medições podem ser rateadas entre múltiplos centros de custo (filiais, departamentos) com percentual definido em política de rateio. O sistema valida que soma de percentuais = 100%, distribui valor proporcional, e cria registros de rateio vinculados. Suporta regras condicionais (por volume, peso, contrato).

**Justificativa**: Distribuir custos apropriadamente entre responsáveis, facilitar análise de despesa por centro de custo e evitar concentração artificial em uma filial.

**Implementação**:
```csharp
public class RatearMedicaoHandler : ICommandHandler<RatearMedicaoCommand>
{
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly IPoliticaRateioRepository _politicaRepository;
    private readonly IRateioRepository _rateioRepository;

    public async Task<Result> Handle(RatearMedicaoCommand command, CancellationToken ct)
    {
        // RN-MED-090-05: Validar rateio
        var medicao = await _medicaoRepository.GetByIdAsync(
            command.MedicaoId, command.ClienteId, ct);

        if (medicao == null)
            return Result.Failure(new ValidationError("MedicaoId", "Medição não encontrada"));

        // Validar soma de percentuais = 100%
        var somaPercentuais = command.Rateios.Sum(r => r.Percentual);
        if (Math.Abs(somaPercentuais - 100) > 0.01m)
            return Result.Failure(new ValidationError(
                "Rateios",
                $"Soma de percentuais deve ser 100%, atual: {somaPercentuais:F2}%"
            ));

        // Aplicar rateio
        medicao.AplicarRateio(command.Rateios);

        // Criar registros de rateio detalhado
        foreach (var rateio in command.Rateios)
        {
            var valorRateio = medicao.ValorFaturavel * (rateio.Percentual / 100);
            var registroRateio = new RegistroRateio(
                medicao.Id,
                rateio.CentroCustoId,
                rateio.Percentual,
                valorRateio,
                rateio.Justificativa
            );

            await _rateioRepository.AddAsync(registroRateio, ct);
        }

        await _medicaoRepository.UpdateAsync(medicao, ct);
        return Result.Success();
    }
}
```

**Exemplos**:
- Medição R$10.000, Rateio: Filial SP 60% (R$6.000) + Filial RJ 40% (R$4.000)
- Medição R$5.000, Rateio por peso: CCusto A 30kg/100kg=30%, CCusto B 70kg/100kg=70%

---

### RN-MED-090-06: Validação de Integração com Contrato RF023

**Descrição**: Toda medição deve estar vinculada a um contrato válido (FK para Contrato em RF023). Contrato deve estar em status ativo, dentro da vigência e não pode ser deletado (soft delete) enquanto tiver medições pendentes de faturamento.

**Justificativa**: Garantir integridade referencial, evitar medições órfãs e manter rastreabilidade clara entre medição e contrato que originou.

**Implementação**:
```csharp
public class ValidarIntegracaoContratoHandler
{
    public async Task ValidarAsync(
        int contratoId,
        int clienteId,
        CancellationToken ct)
    {
        var contrato = await _contratoRepository.GetByIdAsync(contratoId, clienteId, ct);

        if (contrato == null)
            throw new EntityNotFoundException("Contrato não encontrado");

        if (contrato.FlExcluido)
            throw new BusinessRuleException(
                code: "CONTRATO_DELETADO",
                message: "Não é permitido criar medição para contrato deletado"
            );

        if (DateTime.Today < contrato.DataInicio || DateTime.Today > contrato.DataFim)
            throw new BusinessRuleException(
                code: "CONTRATO_FORA_VIGENCIA",
                message: "Contrato fora da vigência"
            );
    }
}
```

**Exemplos**:
- Válido: Contrato ativo, vigência 2025, nenhuma medição pendente
- Inválido: Contrato deletado logicamente
- Inválido: Contrato com data fim no passado (encerrado)

---

### RN-MED-090-07: Workflow de Aprovação de Medição

**Descrição**: Medições seguem state machine com 5 estados: Rascunho → PendenteAprovacao → Aprovada → Faturada → Glosa (opcional). Transições são validadas: somente usuário com permissão 'med:approve' pode aprovar, somente Financeiro pode marcar como Faturada. Cada transição é auditada.

**Justificativa**: Garantir controle de qualidade, segregação de funções (medidor ≠ aprovador ≠ financeiro) e rastreabilidade de decisões.

**Implementação**:
```csharp
public class AprovarMedicaoCommandHandler : ICommandHandler<AprovarMedicaoCommand>
{
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly IPermissionService _permissionService;
    private readonly IAuditService _auditService;

    public async Task<Result> Handle(AprovarMedicaoCommand command, CancellationToken ct)
    {
        // Validar permissão
        var temPermissao = await _permissionService.HasPermissionAsync(
            command.UsuarioId,
            "med:approve",
            ct
        );

        if (!temPermissao)
            return Result.Failure(new ValidationError(
                "Permissão",
                "Usuário sem permissão para aprovar medições"
            ));

        var medicao = await _medicaoRepository.GetByIdAsync(
            command.MedicaoId,
            command.ClienteId,
            ct
        );

        if (medicao == null)
            return Result.Failure(new ValidationError("MedicaoId", "Medição não encontrada"));

        // Validar transição de estado
        if (medicao.Status != MedicaoStatus.PendenteAprovacao)
            return Result.Failure(new ValidationError(
                "Status",
                $"Medição não pode ser aprovada do estado {medicao.Status}"
            ));

        // Aplicar transição
        medicao.Aprovar(command.UsuarioId, command.Observacoes);

        await _medicaoRepository.UpdateAsync(medicao, ct);

        // Auditar
        await _auditService.LogAsync(
            operation: AuditOperation.Approve,
            entityType: "Medicao",
            entityId: medicao.Id,
            clienteId: command.ClienteId,
            userId: command.UsuarioId,
            changes: $"Medição aprovada. Valor: {medicao.ValorFaturavel:C}",
            ct
        );

        return Result.Success();
    }
}
```

**Exemplos**:
- Fluxo normal: Rascunho (medidor cria) → PendenteAprovacao (gestor analisa) → Aprovada (aprovação) → Faturada (financeiro)
- Fluxo com glosa: ... → Aprovada → Glosa (cliente contesta) → Análise → Aprovada/Rejeitada

---

### RN-MED-090-08: Geração Automática de Fatura (Integração RF032)

**Descrição**: Após medição ser aprovada (status Aprovada), um job automático (Hangfire) a cada hora busca medições elegíveis e cria nota fiscal correspondente via RF032. Nota fiscal herda valores, períodos, rateio da medição. Link entre medição e fatura é rastreável.

**Justificativa**: Automatizar geração de faturas, eliminar delay manual, garantir consistência entre medição e fatura faturada, facilitar auditoria de origem.

**Implementação**:
```csharp
public class GerarFaturaAutomaticaJob : IBackgroundJob
{
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly INotaFiscalService _notaFiscalService;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<GerarFaturaAutomaticaJob> _logger;

    public async Task ExecuteAsync(CancellationToken ct)
    {
        // Buscar medições aprovadas, não faturadas
        var medicoes = await _medicaoRepository
            .GetMedicoesPorStatusAsync(MedicaoStatus.Aprovada, ct);

        _logger.LogInformation(
            "Gerando faturas automáticas. Total de medições: {Total}",
            medicoes.Count
        );

        foreach (var medicao in medicoes)
        {
            try
            {
                // Criar nota fiscal baseada em medição
                var comando = new CriarNotaFiscalCommand(
                    ClienteId: medicao.ClienteId,
                    ContratoId: medicao.ContratoId,
                    MedicaoId: medicao.Id,
                    DataEmissao: DateTime.UtcNow,
                    DataVencimento: DateTime.UtcNow.AddDays(30),
                    ValorTotal: medicao.ValorFaturavel,
                    ValorImposto: medicao.CalcularImpostos(),
                    Rateios: medicao.Rateios.ToList()
                );

                var resultado = await _notaFiscalService.CriarAsync(comando, ct);

                if (resultado.Sucesso)
                {
                    medicao.MarcarComoFaturada(resultado.NotaFiscalId);
                    await _medicaoRepository.UpdateAsync(medicao, ct);

                    _logger.LogInformation(
                        "Fatura gerada: Medicao={MedicaoId}, NotaFiscal={NotaFiscalId}",
                        medicao.Id, resultado.NotaFiscalId
                    );
                }
                else
                {
                    _logger.LogWarning(
                        "Falha ao gerar fatura: Medicao={MedicaoId}, Erro={Erro}",
                        medicao.Id, resultado.Mensagem
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "Erro ao gerar fatura automática: Medicao={MedicaoId}",
                    medicao.Id
                );
            }
        }

        await _unitOfWork.SaveChangesAsync(ct);
    }
}
```

**Exemplos**:
- Medição aprovada 10:00 → Job executa 11:00 → Nota fiscal criada automaticamente → Medição marcada Faturada
- Medição com rateio (Filial A 60%, Filial B 40%) → Nota fiscal herda rateio automático

---

### RN-MED-090-09: Gestão de Glosa (Contestação de Fatura)

**Descrição**: Cliente pode contestar fatura gerada propondo glosa (desconto) com justificativa e percentual. Sistema registra glosa em status "PendenteAnalise", gestor analisa (aprova ou rejeita), auditoria registra decisão. Se aprovada, medição volta a status Glosa e gera nota fiscal de ajuste (crédito).

**Justificativa**: Permitir questionamento justo de valores, manter transparência, registrar auditoriamente todas as contestações e ajustes.

**Implementação**:
```csharp
public class CriarGlosaCommandHandler : ICommandHandler<CriarGlosaCommand>
{
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly IGlosaRepository _glosaRepository;
    private readonly INotificationService _notificationService;

    public async Task<Result> Handle(CriarGlosaCommand command, CancellationToken ct)
    {
        var medicao = await _medicaoRepository.GetByIdAsync(
            command.MedicaoId,
            command.ClienteId,
            ct
        );

        if (medicao == null)
            return Result.Failure(new ValidationError("MedicaoId", "Medição não encontrada"));

        if (medicao.Status != MedicaoStatus.Faturada)
            return Result.Failure(new ValidationError(
                "Status",
                "Glosa pode ser registrada somente para medições faturadas"
            ));

        // Validar percentual de glosa (máximo 100%)
        if (command.PercentualGlosa <= 0 || command.PercentualGlosa > 100)
            return Result.Failure(new ValidationError(
                "PercentualGlosa",
                "Percentual deve estar entre 0% e 100%"
            ));

        var glosa = new Glosa(
            medicao.Id,
            medicao.ClienteId,
            command.PercentualGlosa,
            medicao.ValorFaturavel * (command.PercentualGlosa / 100),
            command.Justificativa,
            command.UsuarioId
        );

        await _glosaRepository.AddAsync(glosa, ct);
        medicao.SetStatus(MedicaoStatus.Glosa);
        await _medicaoRepository.UpdateAsync(medicao, ct);

        // Notificar gestor financeiro
        await _notificationService.NotifyAsync(
            $"Nova glosa registrada: Medicao={medicao.Id}, Percentual={command.PercentualGlosa:P}",
            NotificationType.NovaGlosa,
            ct
        );

        return Result.Success();
    }
}
```

**Exemplos**:
- Fatura R$5.000, Cliente contesta 10% por falha de serviço → Glosa criada (PendenteAnalise)
- Glosa aprovada → Nota fiscal de crédito R$500 gerada automaticamente

---

### RN-MED-090-10: Auditoria Imutável de Medições

**Descrição**: Toda operação em medição (criação, atualização, aprovação, cancelamento, glosa) é registrada em tabela de auditoria com: timestamp UTC, usuário, IP, operação, valores antes/depois (JSON), hash SHA-256 de integridade. Retenção obrigatória 7 anos conforme LGPD.

**Justificativa**: Conformidade regulatória (Lei 13.709/2018 LGPD), rastreabilidade 100% auditável, detecção de alterações pós-fato, evidência em auditorias externas (SOX).

**Implementação**:
```csharp
public class RegistrarAuditoriaHandler
{
    private readonly IAuditService _auditService;

    public async Task RegistrarAsync(
        AuditOperation operacao,
        Medicao medicao,
        object? valoresAnteriores,
        int usuarioId,
        string ipAddress,
        CancellationToken ct)
    {
        var registroAuditoria = new RegistroAuditoria
        {
            EntityType = "Medicao",
            EntityId = medicao.Id,
            Operation = operacao,
            ClienteId = medicao.ClienteId,
            UserId = usuarioId,
            Timestamp = DateTime.UtcNow,
            IpAddress = ipAddress,
            ChangesBefore = JsonSerializer.Serialize(valoresAnteriores),
            ChangesAfter = JsonSerializer.Serialize(medicao),
            OperationHash = ComputarHash(medicao, operacao, usuarioId)
        };

        await _auditService.LogAsync(registroAuditoria, ct);
    }

    private string ComputarHash(Medicao medicao, AuditOperation op, int usuarioId)
    {
        var dados = $"{medicao.Id}|{op}|{usuarioId}|{medicao.ValorFaturavel}|{DateTime.UtcNow:O}";
        using (var sha256 = System.Security.Cryptography.SHA256.Create())
        {
            var hash = sha256.ComputeHash(Encoding.UTF8.GetBytes(dados));
            return Convert.ToHexString(hash);
        }
    }
}
```

**Exemplos**:
- Criação: Usuário123, 2025-12-28 10:30:00, OperaçãoCriar, Medicao_456, Valor={}, Hash=abcd1234...
- Aprovação: Usuário456, 2025-12-28 11:00:00, OperaçãoAprovar, Medicao_456, Valor={antiga}, Valor={nova}, Hash=efgh5678...

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `icontrolit_clientes`

**Tabela Principal**: `Medicao`
```sql
CREATE TABLE [dbo].[Medicao](
    [Id_Medicao] [int] IDENTITY(1,1) NOT NULL,
    [Id_Contrato] [int] NOT NULL,
    [Id_Cliente] [int] NOT NULL,
    [Dt_Inicio_Medicao] [datetime] NOT NULL,
    [Dt_Fim_Medicao] [datetime] NOT NULL,
    [Vl_Medicao] [numeric](13, 2) NOT NULL,
    [Vl_Reajuste] [numeric](13, 2) NULL,
    [Fl_Rateado] [bit] NOT NULL DEFAULT 0,
    [Id_Usuario_Criacao] [int] NOT NULL,
    [Dt_Criacao] [datetime] NOT NULL,
    [Id_Usuario_Atualizacao] [int] NULL,
    [Dt_Atualizacao] [datetime] NULL,
    CONSTRAINT [PK_Medicao] PRIMARY KEY CLUSTERED ([Id_Medicao] ASC),
    CONSTRAINT [FK_Medicao_Contrato] FOREIGN KEY ([Id_Contrato]) REFERENCES [dbo].[Contrato]([Id_Contrato])
)
```

**Tabelas Relacionadas**:
```sql
CREATE TABLE [dbo].[Rateio_Medicao](
    [Id_Rateio] [int] IDENTITY(1,1) NOT NULL,
    [Id_Medicao] [int] NOT NULL,
    [Id_Centro_Custo] [int] NOT NULL,
    [Percentual_Rateio] [numeric](5, 2) NOT NULL,
    [Vl_Rateado] [numeric](13, 2) NOT NULL,
    CONSTRAINT [PK_Rateio_Medicao] PRIMARY KEY CLUSTERED ([Id_Rateio] ASC),
    CONSTRAINT [FK_Rateio_Medicao_Medicao] FOREIGN KEY ([Id_Medicao]) REFERENCES [dbo].[Medicao]([Id_Medicao])
)

CREATE TABLE [dbo].[Glosa](
    [Id_Glosa] [int] IDENTITY(1,1) NOT NULL,
    [Id_Medicao] [int] NOT NULL,
    [Percentual_Glosa] [numeric](5, 2) NOT NULL,
    [Vl_Glosa] [numeric](13, 2) NOT NULL,
    [Ds_Justificativa] [varchar](500) NOT NULL,
    [Fl_Aprovada] [bit] NOT NULL DEFAULT 0,
    [Dt_Aprovacao] [datetime] NULL,
    CONSTRAINT [PK_Glosa] PRIMARY KEY CLUSTERED ([Id_Glosa] ASC),
    CONSTRAINT [FK_Glosa_Medicao] FOREIGN KEY ([Id_Medicao]) REFERENCES [dbo].[Medicao]([Id_Medicao])
)
```

**Campos Importantes**:

| Campo Legado | Descrição | Uso no Modernizado |
|--------------|-----------|-------------------|
| `Id_Medicao` | PK da medição | Mapeado para Entity ID |
| `Id_Contrato` | FK para Contrato (RF023) | Mapeado como ContratoId com validação RN-MED-090-06 |
| `Dt_Inicio_Medicao` | Data de início do período | DataInicioPeriodo com validação RN-MED-090-01 |
| `Dt_Fim_Medicao` | Data de fim do período | DataFimPeriodo com validação RN-MED-090-02 |
| `Vl_Medicao` | Valor total (calculado manualmente) | ValorFaturavel (calculado automático RN-MED-090-03) |
| `Vl_Reajuste` | Valor do reajuste aplicado | HistoricoReajustes (auditado, RN-MED-090-04) |
| `Fl_Rateado` | Flag simples (0/1) | Estrutura de Rateios com percentuais (RN-MED-090-05) |

### 3.2 Stored Procedures Legado

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `pa_CalcularFatura_Contrato` | Calcula valor da fatura com reajuste | Será migrada para Job automático GerarFaturaAutomaticaJob em Hangfire |
| `pa_ListarMedicoesPendentes` | Lista medições não faturadas | Query LINQ no repository GetMedicoesPorStatusAsync |
| `pa_AplicarReajuste` | Aplica reajuste manualmente no banco | Job automático AplicarReajusteContratoAutomaticoJob com simulação |
| `pa_RatearMedicao` | Faz cálculos de rateio | Handler RatearMedicaoHandler com validações |

### 3.3 Telas ASPX

| Página | Descrição | Tela Moderna |
|--------|-----------|--------------|
| `MedicaoLista.aspx` | Lista de medições com filtros | `/financeiro/medicoes/lista` (Angular) |
| `MedicaoDetalhe.aspx` | Detalhes de uma medição com edição | `/financeiro/medicoes/:id` (Angular) |
| `RelatorioFaturamento.aspx` | Relatório de faturamento por período | `/financeiro/relatorios/faturamento` (BI integrado) |
| `GlosaAnaliseLista.aspx` | Lista de glosas para análise | `/financeiro/glosas/pendentes` (Angular) |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSMedicao.asmx.vb`

| Método | Descrição | Endpoint Moderno |
|--------|-----------|-----------------|
| `ObterMedicoes()` | Retorna lista de medições | `GET /api/medicoes?clienteId={id}&periodo={mês}` |
| `CriarMedicao()` | Cria nova medição | `POST /api/medicoes` |
| `AtualizarMedicao()` | Atualiza medição existente | `PUT /api/medicoes/{id}` |
| `CalcularFatura()` | Calcula valor de fatura | `GET /api/medicoes/{id}/calcular-fatura` |
| `AplicarReajuste()` | Aplica reajuste (manual) | `POST /api/medicoes/{id}/aplicar-reajuste` (apenas admin) |

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `MEDICAO_FATURAMENTO_AUTOMATICO`

**Configuração**:
```json
{
    "featureKey": "MEDICAO_FATURAMENTO_AUTOMATICO",
    "nome": "Geração automática de faturas",
    "descricao": "Ativa job automático que gera notas fiscais a partir de medições aprovadas",
    "habilitado": true,
    "isSystemFeature": false,
    "dependencias": ["NOTAFISCAL_MODULO_ATIVO"],
    "conglomerado": "*"
}
```

**Nota**: Feature é controlada por conglomerado. Alguns clientes legados podem preferir geração manual de faturas durante transição.

**Chaves Adicionais**:
```json
{
    "featureKey": "MEDICAO_REAJUSTE_AUTOMATICO",
    "nome": "Reajuste automático de contratos",
    "descricao": "Aplica reajustes econômicos automaticamente em data de aniversário",
    "habilitado": true
},
{
    "featureKey": "MEDICAO_NOTIFICACOES_VENCIMENTO",
    "nome": "Notificações de vencimento de medição",
    "descricao": "Envia alertas por e-mail e SignalR quando período de medição se aproxima do vencimento",
    "habilitado": true
},
{
    "featureKey": "MEDICAO_RATEIO_AUTOMATICO",
    "nome": "Rateio automático entre centros de custo",
    "descricao": "Aplica regras de rateio definidas na política de forma automática",
    "habilitado": true
}
```

---

### 4.2 Internacionalização (i18n)

**Chaves de Tradução**:

```json
{
    "medicao": {
        "titulo": "Medição e Faturamento",
        "menu": "Medições",
        "form": {
            "periodo": "Período de Medição",
            "dataInicio": "Data de Início",
            "dataFim": "Data de Fim",
            "contrato": "Contrato",
            "tipoMedicao": "Tipo de Medição",
            "valorFixo": "Valor Fixo (R$)",
            "quantidade": "Quantidade",
            "valorUnitario": "Valor Unitário (R$)",
            "valorFaturavel": "Valor Faturável",
            "observacoes": "Observações",
            "status": "Status"
        },
        "tipos": {
            "fixa": "Medição Fixa",
            "variavel": "Medição Variável",
            "hibrida": "Medição Híbrida"
        },
        "status": {
            "rascunho": "Rascunho",
            "pendenteAprovacao": "Pendente de Aprovação",
            "aprovada": "Aprovada",
            "faturada": "Faturada",
            "glosa": "Em Glosa"
        },
        "mensagens": {
            "sucessoCriacao": "Medição criada com sucesso",
            "sucessoAtualizacao": "Medição atualizada com sucesso",
            "sucessoAprovacao": "Medição aprovada com sucesso",
            "sucessoFaturacao": "Fatura gerada com sucesso",
            "erroSobreposicao": "Já existe medição com período sobreposto",
            "erroForaVigencia": "Período está fora da vigência do contrato",
            "erroValidacao": "Validação falhou. Verifique os campos obrigatórios",
            "confirmacaoAprovacao": "Tem certeza que deseja aprovar esta medição?",
            "confirmacaoFaturacao": "Tem certeza que deseja faturar esta medição?"
        },
        "validacao": {
            "periodoObrigatorio": "Período de medição é obrigatório",
            "contratoObrigatorio": "Contrato é obrigatório",
            "tipoMedicaoObrigatorio": "Tipo de medição é obrigatório",
            "valorPositivo": "Valor deve ser maior que zero",
            "quantidadePositiva": "Quantidade deve ser maior que zero"
        },
        "relatorio": {
            "titulo": "Relatório de Faturamento",
            "periodo": "Período",
            "contrato": "Contrato",
            "valor": "Valor",
            "status": "Status",
            "exportar": "Exportar PDF/Excel"
        }
    }
}
```

**Suporte a idiomas**: pt-BR, en-US, es-ES

---

### 4.3 Auditoria

**Operações Auditadas**:

| Operação | Código | Dados Registrados |
|----------|--------|-------------------|
| Criar Medição | `MED_CREATE` | ContratoId, Período, Tipo, Valores |
| Atualizar Medição | `MED_UPDATE` | Campos alterados (antes/depois), JSON diff |
| Aprovar Medição | `MED_APPROVE` | Usuário aprovador, Timestamp, Status anterior→novo |
| Faturar Medição | `MED_INVOICE` | NotaFiscalId linkado, Valor faturado |
| Registrar Glosa | `MED_DISPUTE_CREATE` | Percentual contestado, Justificativa |
| Aprovar Glosa | `MED_DISPUTE_APPROVE` | Decisão (Aprovada/Rejeitada), Impacto financeiro |
| Aplicar Reajuste | `MED_ADJUSTMENT` | Tipo índice (IGPM/IPCA), Percentual, Valor antes→depois |
| Ratear Medição | `MED_ALLOCATION` | Centros de custo, Percentuais, Valores por CC |

**Retenção**: 7 anos (Lei 13.709/2018 LGPD)

**Tabela**:
```sql
CREATE TABLE [dbo].[AuditoriaMedicao](
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [EntityType] [varchar](50) NOT NULL,
    [EntityId] [int] NOT NULL,
    [ClienteId] [int] NOT NULL,
    [Operation] [varchar](50) NOT NULL,
    [UserId] [int] NOT NULL,
    [Timestamp] [datetime2(7)] NOT NULL,
    [IpAddress] [varchar](45) NOT NULL,
    [ChangesBefore] [nvarchar](MAX) NULL,
    [ChangesAfter] [nvarchar](MAX) NOT NULL,
    [OperationHash] [varchar](64) NOT NULL,
    CONSTRAINT [PK_AuditoriaMedicao] PRIMARY KEY CLUSTERED ([Id] ASC)
)
```

---

### 4.4 Controle de Acesso (RBAC)

**Permissões**:

| Permissão | Descrição | Perfis |
|-----------|-----------|--------|
| `med:create` | Criar medição | Medidor, Gestor Financeiro, Admin |
| `med:read` | Visualizar medição | Medidor, Gestor Financeiro, Gestor Contrato, Financeiro, Admin |
| `med:update` | Editar medição | Medidor (se rascunho), Gestor Financeiro, Admin |
| `med:delete` | Excluir medição (soft delete) | Admin apenas |
| `med:approve` | Aprovar medição | Gestor Financeiro, Diretor Financeiro, Admin |
| `med:invoice` | Marcar como faturada | Financeiro, Admin |
| `med:dispute` | Registrar/analisar glosa | Gestor Financeiro, Cliente, Admin |
| `med:adjustment` | Aplicar reajuste manualmente | Admin apenas (automático via job) |
| `med:export` | Exportar relatório faturamento | Gestor Financeiro, Admin, Executivo |
| `med:allocate` | Configurar rateio | Gestor Financeiro, Admin |

**Nota**: Integração com RF007 (Login) para autenticação. Integração com RF013 (Perfis de Acesso) para atribuição dinâmica.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| GET | `/api/medicoes` | Listar medições (com paginação) | `med:read` |
| GET | `/api/medicoes/{id}` | Obter detalhes de uma medição | `med:read` |
| POST | `/api/medicoes` | Criar nova medição | `med:create` |
| PUT | `/api/medicoes/{id}` | Atualizar medição existente | `med:update` |
| DELETE | `/api/medicoes/{id}` | Excluir medição (soft delete) | `med:delete` |

**Exemplo GET /api/medicoes**:
```http
GET /api/medicoes?clienteId=123&contratoId=456&status=PendenteAprovacao&page=1&pageSize=50
Authorization: Bearer {token}

Response 200:
{
  "data": [
    {
      "id": 1,
      "contratoId": 456,
      "periodo": "2025-01",
      "tipoMedicao": "Variavel",
      "quantidade": 5000,
      "valorUnitario": 0.05,
      "valorFaturavel": 250.00,
      "status": "PendenteAprovacao",
      "criadoEm": "2025-12-28T10:30:00Z"
    }
  ],
  "total": 150,
  "page": 1,
  "pageSize": 50
}
```

### 5.2 Operações Especiais

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| POST | `/api/medicoes/{id}/aprovar` | Aprovar medição | `med:approve` |
| POST | `/api/medicoes/{id}/faturar` | Marcar como faturada | `med:invoice` |
| POST | `/api/medicoes/{id}/ratear` | Aplicar rateio | `med:allocate` |
| POST | `/api/medicoes/{id}/glosa` | Registrar glosa/contestação | `med:dispute` |
| GET | `/api/medicoes/{id}/glosa` | Obter glosa registrada | `med:read` |
| POST | `/api/medicoes/{id}/glosa/{glosaid}/aprovar` | Aprovar glosa | `med:dispute` |
| GET | `/api/medicoes/relatorio/faturamento` | Relatório de faturamento (PDF/Excel) | `med:export` |
| GET | `/api/medicoes/dashboard/resumo` | Dashboard com métricas | `med:read` |

**Exemplo POST /api/medicoes/{id}/aprovar**:
```http
POST /api/medicoes/1/aprovar
Authorization: Bearer {token}
Content-Type: application/json

{
  "observacoes": "Aprovado conforme especificação"
}

Response 200:
{
  "id": 1,
  "status": "Aprovada",
  "aprovadoEm": "2025-12-28T11:00:00Z",
  "aprovadoPor": "usuario@domain.com"
}
```

**Exemplo POST /api/medicoes/{id}/glosa**:
```http
POST /api/medicoes/1/glosa
Authorization: Bearer {token}
Content-Type: application/json

{
  "percentualGlosa": 10,
  "justificativa": "Falha na prestação de serviço no período"
}

Response 201:
{
  "glosaid": 1,
  "medicaoId": 1,
  "percentualGlosa": 10,
  "valorGlosa": 25.00,
  "status": "PendenteAnalise",
  "criadoEm": "2025-12-28T14:30:00Z"
}
```

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Medição até Faturação

```
1. Medidor acessa "/financeiro/medicoes/criar"
   |
   v
2. Seleciona Contrato (FK RF023)
   |
   v
3. Define Período (DataInicio, DataFim)
   - Valida: dentro vigência contrato (RN-MED-090-01)
   - Valida: sem sobreposição (RN-MED-090-02)
   |
   v
4. Define Tipo de Medição (Fixa/Variável/Híbrida)
   |
   +--- Tipo Fixa -------> Informa ValorFixo
   |                            |
   |                            v
   |                    ValorFaturavel = ValorFixo
   |
   +--- Tipo Variável ---> Informa Quantidade + ValorUnitario
   |                            |
   |                            v
   |                    ValorFaturavel = Qtd × Val.Unit
   |
   +--- Tipo Híbrida ----> Informa ValorFixo + Quantidade + ValorUnitario
                                |
                                v
                        ValorFaturavel = ValorFixo + (Qtd × Val.Unit)
   |
   v
5. Sistema cria Medição em status "Rascunho"
   - Persiste em banco com FK ContratoId
   - Calcula ValorFaturavel (RN-MED-090-03)
   - Registra em auditoria (RN-MED-090-10)
   |
   v
6. Medidor submete para aprovação
   |
   v
7. Sistema transiciona para "PendenteAprovacao"
   - Notifica Gestor Financeiro via SignalR + e-mail
   |
   v
8. Gestor Financeiro analisa medição
   - Verifica período, valores, contrato
   - Pode rejeitar (volta a Rascunho) ou aprovar
   |
   v
9. Gestor aprova (permissão med:approve)
   |
   v
10. Sistema transiciona para "Aprovada"
    - Registra em auditoria quem/quando aprovou
    - Aplica reajuste se configurado (RN-MED-090-04)
    - Aplica rateio se configurado (RN-MED-090-05)
    |
    v
11. Job automático (Hangfire) a cada hora
    - Busca medições com status "Aprovada"
    - Cria Nota Fiscal via RF032 (RN-MED-090-08)
    - Vincula NotaFiscalId em Medicao
    - Transiciona para "Faturada"
    - Notifica Financeiro
    |
    v
12. Sistema gera relatório de faturamento
    - Agrupa por período, contrato, fornecedor
    - Exporta PDF/Excel via endpoint
    |
    v
13. Financeiro exporta para ERP (RF078)
    - Lançamento contábil automático
    - Saldo de contas a receber atualizado
```

### 6.2 Fluxo de Reajuste Automático

```
1. Job automático (Hangfire) executa diariamente à 00:00
   |
   v
2. Busca contratos com DataAniversario = hoje
   |
   v
3. Para cada contrato com reajuste configurado:
   - Valida tipo (IGPM/IPCA/INPC/Percentual fixo)
   - Busca índice econômico (RN-MED-090-04)
   |
   v
4. Calcula percentual de reajuste
   - Se IGPM: consulta API BC (índice acumulado últimos 12 meses)
   - Se IPCA: consulta IBGE (índice acumulado últimos 12 meses)
   - Se Percentual: usa valor configurado no contrato
   |
   v
5. Identifica medições do contrato não faturadas ainda
   - Filtra status: Rascunho, PendenteAprovacao
   - Exclui medições já aprovadas/faturadas
   |
   v
6. Para cada medição elegível:
   - Registra valor anterior em histórico
   - Aplica percentual: Novo = Anterior × (1 + Percentual%)
   - Cria registro em HistoricoReajuste
   - Atualiza ValorFaturavel
   |
   v
7. Registra em auditoria (operação MED_ADJUSTMENT)
   - Índice utilizado
   - Percentual aplicado
   - Valores antes/depois
   - Hash de integridade
   |
   v
8. Notifica Gestor Financeiro
   - E-mail: "Reajuste aplicado: Contrato XXX, +5,5%"
   - SignalR: dashboard atualiza em tempo real
   |
   v
9. Medições com reajuste aguardam aprovação normal
```

### 6.3 Fluxo de Glosa (Contestação)

```
1. Fatura foi gerada e aprovada
   - Medição status: Faturada
   |
   v
2. Cliente acessa "/financeiro/glosas/registrar"
   |
   v
3. Seleciona Medição (busca por período/contrato)
   |
   v
4. Informa:
   - Percentual de glosa (0-100%)
   - Justificativa (texto, max 500 caract.)
   |
   v
5. Sistema cria Glosa em status "PendenteAnalise"
   - CalcValorGlosa = ValorFaturavel × (PercentualGlosa / 100)
   - Registra em auditoria (MED_DISPUTE_CREATE)
   - Transiciona Medição para status "Glosa"
   |
   v
6. Notifica Gestor Financeiro
   - E-mail: "Glosa registrada: Medição XXX, 10%, R$250"
   - Portal de glosas: lista em "PendenteAnalise"
   |
   v
7. Gestor analisa glosa
   - Revisa justificativa do cliente
   - Valida se percentual é razoável
   - Consulta evidências (contrato, SLA, glosa anterior)
   |
   v
8. Gestor decide:
   - Aprova glosa (inteiro ou parcial)
   - Rejeita glosa
   - Solicita informação adicional
   |
   v
9. Se APROVADA:
   - Registra em auditoria (MED_DISPUTE_APPROVE: approved)
   - Cria Nota Fiscal de ajuste (crédito) via RF032
   - Transiciona Medição para "Aprovada" (após ajuste)
   - Notifica Cliente: "Glosa aprovada: R$250 crédito"
   |
   v
10. Se REJEITADA:
    - Registra em auditoria (MED_DISPUTE_APPROVE: rejected)
    - Rejeita glosa com justificativa
    - Medição permanece em "Faturada"
    - Notifica Cliente: "Glosa rejeitada: [motivo]"
```

---

## 7. SEGURANÇA

### 7.1 Proteções Implementadas

| Proteção | Descrição |
|----------|-----------|
| **Multi-tenancy Row-Level** | Todas queries filtram automaticamente por ClienteId. Query Filter do EF Core impede acesso cruzado entre clientes |
| **Soft Delete com FlExcluido** | Medições nunca são deletadas permanentemente, apenas marcadas com FlExcluido=true. Histórico completo preservado 7 anos |
| **Validação de Período** | RN-MED-090-01 e RN-MED-090-02 garantem períodos válidos, sem gaps, sem overlaps |
| **Validação de Contrato** | RN-MED-090-06 garante FK válida com contrato ativo e em vigência |
| **State Machine Validado** | Transições de estado são validadas: impossível ir de Faturada para Rascunho. Cada transição gera auditoria |
| **RBAC Granular** | Permissões `med:*` implementadas em middleware. Usuário sem `med:approve` não consegue aprovar medições |
| **Auditoria Hash** | Hash SHA-256 de cada operação detecta alterações pós-fato. Tabela de auditoria é append-only |
| **Retenção LGPD** | Dados de auditoria retidos por 7 anos, mesmo se medição for deletada logicamente |
| **Integração com RF023** | Validações garantem que medição só existe se contrato existe e está válido |
| **Integração com RF032** | Medições não podem ser deletadas se geraram nota fiscal. Garante rastreabilidade |

### 7.2 Testes de Segurança Obrigatórios

- [ ] SQL Injection: Validar campos de entrada (Justificativa glosa, Observações) contra tentativas de SQL
- [ ] XSS: Sanitizar textos antes de renderizar em Angular (Angular sanitizer automático + content projection)
- [ ] CSRF Protection: Tokens CSRF em POST/PUT/DELETE (middleware de CSRF)
- [ ] Validação de Permissões: Tentar criar/aprovar/faturar sem permissão `med:*` → 403 Forbidden
- [ ] Multi-tenancy Breakout: Tentar acessar medição de outro ClienteId → 404 ou 403
- [ ] Soft Delete Integrity: Tentar deletar medição faturada → erro ou soft delete apenas
- [ ] Auditoria Imutável: Verificar se registro de auditoria pode ser alterado (NÃO pode)
- [ ] Hash Integrity: Alterar ChangesBefore em auditoria e verificar se hash detecta (deve detectar)
- [ ] Estado Inválido: Tentar faturar medição em status Glosa → erro (state machine)
- [ ] Sobreposição: Criar medição com período sobreposto → erro 400
- [ ] Retenção LGPD: Verificar se dados de auditoria são retidos por 7 anos mesmo com soft delete

---

## 8. MÉTRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medição |
|-----|------|---------|
| **Taxa de Medições Faturadas** | >95% | (Medições Faturadas / Total Medições) por mês |
| **Tempo Médio Aprovação** | <48h | (DataAprovacao - DataCriacao) média |
| **Glosas Aprovadas vs Total** | <5% | (Glosas Aprovadas / Total Glosas Registradas) |
| **Acurácia de Rateio** | 99.9% | Validar soma de rateios = 100% (alertas automáticos se desvio) |
| **Disponibilidade Job Faturação** | 99.9% | Job automático executa sem erros (Hangfire metrics) |
| **Tempo Processamento Reajuste** | <5min | Tempo total aplicar reajuste em 1000 medições (benchmark) |
| **Conformidade Período** | 100% | 0 medições com período inválido (auditoria trimestral) |
| **Cobertura Auditoria** | 100% | Todas operações registradas em tabela de auditoria |

### 8.2 Alertas

| Alerta | Condição | Ação |
|--------|----------|------|
| **Medição Pendente Vencimento** | 7 dias até fim período | Notificação e-mail ao medidor + dashboard destaque |
| **Medição Sem Aprovação > 24h** | Status PendenteAprovacao há mais de 24h | E-mail ao gestor financeiro: "Medição aguardando aprovação" |
| **Reajuste Falhou** | Job de reajuste retorna erro | Alerta crítico: Ops + Gestor Financeiro, com detalhes do erro |
| **Glosa Pendente Análise > 48h** | Glosa em "PendenteAnalise" há >48h | Lembrança para gestor: "Glosa aguardando análise" |
| **Faturação Atrasada** | Medição aprovada há >24h sem nota fiscal | Alert: "Faturação automática pode estar com falha" |
| **Sobreposição Detectada** | Sistema detecta tentativa criar período sobreposto | Erro 400: "Período sobreposto" + sugestão de datas disponíveis |
| **Fatura Sem Vinculação** | Nota fiscal criada mas MedicaoId NULL | Alerta de integridade: "Divergência RF032 ↔ RF090" |
| **Rateio Desequilibrado** | Soma percentuais ≠ 100% (desvio >0.01%) | Erro validação + ajuste automático com log |

---

## 9. PRÓXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-RF090](./MD-RF090-Medicao-Faturamento.md) com DDL completo, índices, constraints, auditoria integrada
2. **Casos de Uso**: Criar [UC-RF090](./UC-RF090-Medicao-Faturamento.md) com 5 casos de uso: UC00-Listar, UC01-Criar, UC02-Aprovar, UC03-Faturar, UC04-Glosa
3. **Workflows**: Criar [WF-RF090](./WF-RF090-Medicao-Faturamento.md) com telas Angular, componentes, rotas, integrações
4. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml) com mínimo 5 stories: Criar Medição, Aprovar, Faturar, Reajuste, Glosa
5. **Testes**: Criar documentação de testes [TC-RF090-BACKEND.md](./TC-RF090-BACKEND.md), [TC-RF090-FRONTEND.md](./TC-RF090-FRONTEND.md), [TC-RF090-E2E.md](./TC-RF090-E2E.md)
6. **Backend**: Implementar conforme CONTRATO DE EXECUÇÃO – BACKEND
7. **Frontend**: Implementar conforme CONTRATO DE EXECUÇÃO – FRONTEND
8. **Testes Automatizados**: Executar conforme CONTRATO DE EXECUÇÃO DE TESTES
9. **Deploy**: Movimentar para HOM/PRD conforme CONTRATO DE DEPLOY – AZURE

---

## CHANGELOG

| Versão | Data | Descrição | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versão inicial. 9 seções completas, 10 regras de negócio, 15 funcionalidades, integração com RF023, RF032, RF078, RF089. Auditoria LGPD, RBAC, i18n, Feature Flags. Dashboard, alertas, jobs automáticos. | Claude Code |

---

**Última Atualização**: 2025-12-28
**Autor**: IControlIT - Equipe de Arquitetura
**Revisão**: Pendente
