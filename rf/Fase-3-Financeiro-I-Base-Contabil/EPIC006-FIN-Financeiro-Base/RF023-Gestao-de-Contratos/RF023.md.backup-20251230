# RF-023: Gestão de Contratos

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF022 (Gestão de Fornecedores), RF090 (Medição e Faturamento de Contratos), RF092 (Garantias e Seguros Contratuais), RF093 (Indicadores de Performance e Compliance) | **EPIC**: EPIC006-FIN-Financeiro-Base
**Fase**: Fase 3 - Financeiro I - Base Contábil

---

## 1. RESUMO EXECUTIVO

### 1.1 Descricao Geral

Este requisito especifica o **módulo de Gestão de Contratos** do sistema IControlIT, responsável pela administração completa do ciclo de vida de contratos comerciais, de fornecimento, locação, manutenção e telecomunicações com fornecedores, operadoras e prestadores de serviço.

O módulo centraliza a gestão de documentos contratuais, vigências, valores, reajustes, anexos, workflows de aprovação, alertas automáticos, medições, garantias e histórico completo de alterações, garantindo conformidade legal e controle financeiro rigoroso. É componente crítico da base financeira da plataforma.

### 1.2 Importancia Estrategica

O modulo de Gestão de Contratos é critico para:

- **Conformidade Legal**: Registro e rastreabilidade 100% auditável de todos os compromissos contratuais com terceiros, garantindo evidência em auditorias externas
- **Controle Financeiro**: Previsibilidade de custos, reajustes automáticos, vencimentos e impacto orçamentário com projeções de caixa
- **Eficiência Operacional**: Renovação automática, alertas inteligentes de vencimento, workflow de aprovação por alçadas e redução de retrabalho manual
- **Segurança Jurídica**: Versionamento de contratos, histórico completo de alterações, rastreabilidade de aprovações e garantias documentadas
- **Inteligência Estratégica**: Métricas de performance do fornecedor, indicadores de SLA, relatórios gerenciais comparativos e análise de custos por categoria

### 1.3 Conceitos Fundamentais

**Contrato**: Documento formal que estabelece direitos, obrigações e condições entre a empresa (ClienteId) e um terceiro (fornecedor, operadora, prestador). Pode ter múltiplas vigências, versionamento e histórico de alterações.

- Exemplo: Contrato de manutenção de equipamentos com operadora Claro, válido de 01/01/2025 a 31/12/2026, renovável automaticamente

**Vigência**: Período de validade do contrato (DataInicio até DataFim). Contratos podem ter renovação automática ou exigir confirmação manual de renovação.

- Exemplo: Contrato em vigência ativa → DataInicio: 01/01/2025, DataFim: 31/12/2025, RenovacaoAutomatica: true

**Workflow de Aprovação**: Fluxo de autorização baseado em alçadas de valores. Exemplo: Até R$1.000 = Gestor, Até R$10.000 = Diretor, Acima = CCFO. Cada nível pode aprovar, rejeitar ou solicitar informações adicionais.

**Reajuste Contratual**: Aumento automático de valores conforme índice econômico (IGPM, IPCA, INPC) na data de aniversário do contrato. RN-CTR-023-07 define validação e cálculo.

**Medição**: Associação entre contrato e faturas de consumo/serviços prestados (FK para RF090). Exemplo: Contrato de telecom tem 12 medições mensais (uma por mês).

**Multi-tenancy**: Cada contrato é isolado por ClienteId (cliente/empresa contratante). Nenhum dado de clientes diferentes pode ser visível. Segregação em database row-level.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Arquitetura** | WebService ASMX monolítico em um único arquivo | DDD + Clean Architecture + Event Sourcing com separação de responsabilidades |
| **Banco de Dados** | SQL Server com tabela Contrato monolítica (sem auditoria integrada) | PostgreSQL com particionamento por ClienteId, auditoria integrada e soft delete |
| **CRUD** | Telas ASPX (Contrato.aspx, ContratoLista.aspx) renderizadas server-side | API REST stateless + SPA Angular com componentes reutilizáveis e lazy loading |
| **Workflow** | Tabela de status estática (Rascunho, Ativo, Vencido, Renovado) com 4 estados | State Machine pattern com 10 estados, transições validadas e rastreamento de quem/quando |
| **Alertas** | Job SQL Server agendado diariamente à noite | SignalR em tempo real (push notifications) + notificação por e-mail assíncrona com retry |
| **Anexos** | Salvos em pasta compartilhada (\\\\server\\contratos) sem versionamento | Azure Blob Storage com versionamento, metadata, CRC32 para integridade e controle de acesso granular |
| **Auditoria** | Logs textuais em arquivo text.log (sem estrutura) | Tabela de auditoria estruturada com JSON de mudanças, hash de integridade e retenção de 7 anos |
| **Multi-tenancy** | Não existia; todos os dados visíveis a todos | ClienteId em toda query; row-level security no banco de dados; policy enforcement em middleware |
| **Reajustes** | Manual no banco de dados por DBA | Automático com simulação de cenários, histórico de índices, projeções futuras |
| **Relatórios** | Crystal Reports estáticos em servidor de relatórios | BI integrado com filtros dinâmicos, exportação Excel/PDF, gráficos interativos |
| **Validações** | Validações mínimas no backend | Validações rigorosas: regras de negócio, contratos de dados, validações de domínio |

### 1.5 Funcionalidades Principais

1. **CRUD Completo de Contratos** - Criar, editar, consultar, excluir lógico com multi-tenancy garantido
2. **Gestão de Tipos de Contrato** - Compra, Locação, Manutenção, Telecom, Serviço (catálogo extensível e configurável)
3. **Controle de Vigência** - Data início, data fim, renovação automática, alertas de vencimento (30/60/90 dias)
4. **Gestão de Anexos Contratuais** - Upload/download de PDF, DOCX, XML com versioning e validação de assinatura
5. **Controle de Valores** - Valor total, valor mensal, moeda, reajuste por índice econômico, simulação de custos futuros
6. **Workflow de Aprovação** - Solicitante → Gestor → Jurídico → Diretoria com alçadas de valor dinâmicas
7. **Medição e Faturamento** - FK para RF090, rastreamento de consumo/faturamento associado ao contrato
8. **Garantias e Seguros** - FK para RF092, registro de valores de garantia, prazos, cobertura e apólices
9. **Indicadores de Performance** - FK para RF093, cálculo de SLAs, multas contratuais, bônus por performance
10. **Versionamento de Contratos** - Histórico completo de alterações, comparação entre versões, rollback se necessário
11. **Relatórios Gerenciais** - Contratos ativos, a vencer, vencidos, análise de custos, pipeline orçamentário, exportação
12. **Integração com Fornecedores** - FK para RF022, validação de CNPJ, relacionamento hierárquico e histórico de contratos
13. **Multi-tenancy Rigida** - Isolamento total por ClienteId em todas as operações, queries e endpoints
14. **Auditoria Imutável** - Criação, alteração, aprovação, cancelamento com timestamp, usuário, IP e hash de integridade
15. **Alertas Automáticos** - E-mail e SignalR para vencimentos, aprovações pendentes, reajustes e eventos críticos

---

## 2. REGRAS DE NEGOCIO

### RN-CTR-023-01: Validacao de Vigencia Contratual

**Descricao**: A data de término (DataFim) de um contrato deve ser sempre maior ou igual à data de início (DataInicio). Não é permitido criar ou atualizar contrato com datas inválidas. Validação ocorre no command handler antes de persistência.

**Justificativa**: Prevenir erros operacionais que resultariam em contratos com períodos inválidos ou impossíveis, comprometendo relatórios, cálculos de custo e auditoria.

**Implementacao**:
```csharp
public class ValidarVigenciaContratoHandler : ICommandHandler<CriarContratoCommand>
{
    private readonly IContratoRepository _contratoRepository;
    private readonly ILogger<ValidarVigenciaContratoHandler> _logger;

    public async Task<Result> Handle(CriarContratoCommand command, CancellationToken ct)
    {
        // RN-CTR-023-01: Validação de vigência
        if (command.DataFim <= command.DataInicio)
        {
            _logger.LogWarning(
                "Tentativa de criar contrato com datas inválidas: DataInicio={DataInicio}, DataFim={DataFim}",
                command.DataInicio, command.DataFim
            );

            return Result.Failure(
                new ValidationError(
                    "DataFim",
                    "A data de término deve ser superior à data de início"
                )
            );
        }

        // Validações adicionais
        var diasVigencia = (command.DataFim - command.DataInicio).TotalDays;
        if (diasVigencia > 3650) // Limite de 10 anos
        {
            return Result.Failure(
                new ValidationError(
                    "DataFim",
                    "Vigência não pode exceder 10 anos"
                )
            );
        }

        var contrato = Contrato.Criar(
            command.ClienteId,
            command.FornecedorId,
            command.TipoContrato,
            command.Descricao,
            command.DataInicio,
            command.DataFim,
            command.ValorTotal,
            command.ValorMensal
        );

        await _contratoRepository.AddAsync(contrato, ct);
        return Result.Success();
    }
}
```

**Exemplos**:
- Válido: DataInicio = 01/01/2025, DataFim = 31/12/2025 (364 dias)
- Inválido: DataInicio = 31/12/2025, DataFim = 01/01/2025 (negativo)
- Inválido: DataInicio = DataFim (zero dias de vigência)

---

### RN-CTR-023-02: Calculo Automatico de Valor Mensal Proporcional

**Descricao**: Quando um contrato é criado, o sistema calcula automaticamente o valor mensal proporcional dividindo ValorTotal pela quantidade de meses da vigência. Se usuário informar ValorMensal explícito, este prevalece e ValorTotal é recalculado para manter consistência.

**Justificativa**: Evitar erros de cálculo manual, garantir consistência entre valor total e valor mensal em toda gestão financeira e facilitar comparações de custo.

**Implementacao**:
```csharp
public class CalcularValorMensalContratoHandler
{
    public decimal CalcularValorMensal(
        decimal valorTotal,
        DateTime dataInicio,
        DateTime dataFim)
    {
        if (valorTotal < 0)
            throw new DomainException("Valor total não pode ser negativo");

        var diasVigencia = (dataFim - dataInicio).TotalDays;
        var mesesVigencia = diasVigencia / 30.44m; // média de dias por mês (365/12)

        if (mesesVigencia <= 0)
            throw new DomainException("Vigência inválida para cálculo de valor mensal");

        return Math.Round(valorTotal / (decimal)mesesVigencia, 2);
    }

    public decimal RecalcularValorTotal(
        decimal valorMensal,
        DateTime dataInicio,
        DateTime dataFim)
    {
        if (valorMensal < 0)
            throw new DomainException("Valor mensal não pode ser negativo");

        var diasVigencia = (dataFim - dataInicio).TotalDays;
        var mesesVigencia = diasVigencia / 30.44m;

        var novoValorTotal = Math.Round(valorMensal * (decimal)mesesVigencia, 2);
        return novoValorTotal;
    }
}
```

**Exemplos**:
- Contrato: ValorTotal = R$12.000, DataInicio = 01/01/2025, DataFim = 31/12/2025 (12 meses)
- Resultado: ValorMensal = R$1.000 (12.000 / 12)
- Se atualizar para ValorMensal = R$1.100 → ValorTotal será recalculado para R$13.200

---

### RN-CTR-023-03: Renovacao Automatica de Contrato

**Descricao**: Contratos configurados com RenovacaoAutomatica = true são prolongados automaticamente por um novo período igual ao anterior quando a data de término é atingida. Um novo registro de contrato é criado com status "RenovacaoAutomatica" e o contrato anterior passa para status "Renovado".

**Justificativa**: Reduzir intervenções manuais em contratos de longa duração, garantir continuidade operacional sem gaps de cobertura e evitar suspensão de serviços críticos.

**Implementacao**:
```csharp
public class RenovarContratoAutomaticoJob : IBackgroundJob
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly INotificationService _notificationService;
    private readonly ILogger<RenovarContratoAutomaticoJob> _logger;

    public async Task ExecuteAsync(CancellationToken ct)
    {
        var hoje = DateTime.Today;
        var contratosAVencer = await _contratoRepository
            .GetContratosPorRenovarAsync(hoje, ct);

        _logger.LogInformation(
            "Iniciando processo de renovação automática. Total de contratos: {Total}",
            contratosAVencer.Count
        );

        foreach (var contrato in contratosAVencer)
        {
            if (!contrato.RenovacaoAutomatica)
                continue;

            try
            {
                var periodicidade = (contrato.DataFim - contrato.DataInicio).Days;

                var novoContrato = Contrato.Criar(
                    contrato.ClienteId,
                    contrato.FornecedorId,
                    contrato.TipoContrato,
                    contrato.Descricao,
                    contrato.DataFim.AddDays(1),
                    contrato.DataFim.AddDays(periodicidade + 1),
                    contrato.ValorTotal,
                    contrato.ValorMensal
                );
                novoContrato.SetStatus(ContratoStatus.RenovacaoAutomatica);
                novoContrato.SetContratoAnterior(contrato.Id);

                await _contratoRepository.AddAsync(novoContrato, ct);

                contrato.SetStatus(ContratoStatus.Renovado);
                await _contratoRepository.UpdateAsync(contrato, ct);

                await _notificationService.NotifyAsync(
                    contrato.ClienteId,
                    $"Contrato {contrato.Numero} renovado automaticamente até {novoContrato.DataFim:dd/MM/yyyy}",
                    NotificationType.ContratoRenovado,
                    ct
                );

                _logger.LogInformation(
                    "Contrato {ContratoNumero} renovado automaticamente. Novo ID: {NovoId}",
                    contrato.Numero, novoContrato.Id
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "Erro ao renovar contrato {ContratoId}",
                    contrato.Id
                );
            }
        }

        await _unitOfWork.SaveChangesAsync(ct);
    }
}
```

**Exemplos**:
- Contrato original: Válido até 31/12/2025, RenovacaoAutomatica = true, periodicidade = 365 dias
- Em 31/12/2025: Sistema cria novo contrato válido até 31/12/2026
- Status: Contrato original → "Renovado", Novo contrato → "RenovacaoAutomatica"

---

### RN-CTR-023-04: Alertas Automaticos de Vencimento

**Descricao**: O sistema gera alertas automáticos (e-mail + SignalR em tempo real) para usuários responsáveis quando um contrato se aproxima do vencimento em 30, 60 ou 90 dias. Alertas são gravados na tabela AuditoriaAlerta para rastreamento e evitar duplicatas.

**Justificativa**: Notificar stakeholders com antecedência permite decisões proativas de renovação, renegociação ou encerramento, evitando gaps de serviço.

**Implementacao**:
```csharp
public class GerarAlertasVencimentoContratoJob : IBackgroundJob
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IEmailService _emailService;
    private readonly INotificationHub _notificationHub;
    private readonly IAuditoriaRepository _auditoriaRepository;
    private readonly ILogger<GerarAlertasVencimentoContratoJob> _logger;

    public async Task ExecuteAsync(CancellationToken ct)
    {
        var hoje = DateTime.Today;
        var diasAlerta = new[] { 30, 60, 90 };

        _logger.LogInformation("Iniciando geração de alertas de vencimento");

        foreach (var dias in diasAlerta)
        {
            var dataAlerta = hoje.AddDays(dias);
            var contratos = await _contratoRepository
                .GetContratosPorDataVencimentoAsync(dataAlerta, ct);

            _logger.LogInformation(
                "Encontrados {Total} contratos vencendo em {Dias} dias",
                contratos.Count, dias
            );

            foreach (var contrato in contratos)
            {
                // Verificar se alerta já foi enviado para este período
                var alertaExistente = await _auditoriaRepository
                    .GetAlertaAsync(contrato.Id, dias, ct);

                if (alertaExistente != null)
                {
                    _logger.LogDebug(
                        "Alerta com {Dias} dias já foi enviado para contrato {ContratoId}",
                        dias, contrato.Id
                    );
                    continue;
                }

                var mensagem = $"Contrato {contrato.Numero} ({contrato.Descricao}) " +
                    $"vencerá em {dias} dias ({contrato.DataFim:dd/MM/yyyy})";

                try
                {
                    // Enviar e-mail assíncrono
                    await _emailService.SendAsync(
                        contrato.UsuarioResponsavelEmail,
                        "Alerta de Vencimento de Contrato",
                        mensagem,
                        ct
                    );

                    // Notificar via SignalR (real-time)
                    await _notificationHub.SendAlertAsync(
                        contrato.ClienteId,
                        mensagem,
                        AlertaTipo.Contrato,
                        contrato.Id,
                        ct
                    );

                    // Registrar auditoria
                    var auditoria = new AuditoriaAlerta(
                        contrato.ClienteId,
                        contrato.Id,
                        "CTR_CONTRATO_ALERTA_VENCIMENTO",
                        $"Alerta automático com {dias} dias de antecedência",
                        new { Dias = dias, DataVencimento = contrato.DataFim }
                    );
                    await _auditoriaRepository.AddAsync(auditoria, ct);

                    _logger.LogInformation(
                        "Alerta gerado para contrato {ContratoId} com {Dias} dias",
                        contrato.Id, dias
                    );
                }
                catch (Exception ex)
                {
                    _logger.LogError(
                        ex,
                        "Erro ao gerar alerta para contrato {ContratoId}",
                        contrato.Id
                    );
                }
            }
        }

        await _auditoriaRepository.SaveChangesAsync(ct);
    }
}
```

**Exemplos**:
- Contrato com DataFim = 31/01/2025
- Alertas enviados em: 02/12/2024 (90 dias), 02/01/2025 (30 dias)
- Cada alerta registrado na auditoria para rastreamento

---

### RN-CTR-023-05: Workflow de Aprovacao por Alcada de Valor

**Descricao**: Contratos são submetidos a workflow de aprovação baseado em faixas de valor configuráveis. State-machine: Rascunho → PendenteAprovacao → Aprovado/Rejeitado. Cada nível de aprovação (Gestor, Jurídico, Diretoria) valida regras específicas de alçada e registra auditoria.

**Justificativa**: Garantir controle gerencial, segregação de responsabilidades conforme políticas corporativas e conformidade com limites de autorização.

**Implementacao**:
```csharp
public class WorkflowAprovacaoContratoHandler : ICommandHandler<SubmeterParaAprovacaoCommand>
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IAlcadaRepository _alcadaRepository;
    private readonly IAuditoriaRepository _auditoriaRepository;
    private readonly ILogger<WorkflowAprovacaoContratoHandler> _logger;

    public async Task<Result> Handle(
        SubmeterParaAprovacaoCommand command,
        CancellationToken ct)
    {
        var contrato = await _contratoRepository
            .GetByIdAsync(command.ContratoId, ct);

        if (contrato == null)
            return Result.Failure("Contrato não encontrado");

        // RN-CTR-023-05: Validar que apenas contratos em rascunho podem ser submetidos
        if (contrato.Status != ContratoStatus.Rascunho)
            return Result.Failure(
                $"Apenas contratos em rascunho podem ser submetidos. Status atual: {contrato.Status}"
            );

        // Determinar próximo aprovador conforme alçada
        var alcada = await _alcadaRepository
            .GetAlcadaParaValorAsync(contrato.ClienteId, contrato.ValorTotal, ct);

        if (alcada == null)
            return Result.Failure("Nenhuma alçada configurada para este valor de contrato");

        var proximoAprovador = alcada.PerfilRequerido; // Ex: "Gestor", "Jurista", "Diretor"

        contrato.SetStatus(ContratoStatus.PendenteAprovacao);
        contrato.SetProximoAprovador(proximoAprovador);
        contrato.SetDataSubmissao(DateTime.UtcNow);
        contrato.SetSubmitidoPor(command.UsuarioId);

        await _contratoRepository.UpdateAsync(contrato, ct);

        // Auditoria
        var auditoria = new AuditoriaOperacao(
            contrato.ClienteId,
            contrato.Id,
            "CTR_CONTRATO_SUBMIT_APROVACAO",
            $"Contrato submetido para aprovação por {proximoAprovador}. Valor: {contrato.ValorTotal:C}",
            new { AlcadaValor = alcada.Valor, Perfil = proximoAprovador, UsuarioId = command.UsuarioId }
        );
        await _auditoriaRepository.AddAsync(auditoria, ct);

        _logger.LogInformation(
            "Contrato {ContratoId} submetido para aprovação. Próximo aprovador: {Aprovador}",
            contrato.Id, proximoAprovador
        );

        return Result.Success();
    }
}

public class AprovarContratoHandler : ICommandHandler<AprovarContratoCommand>
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IAlcadaRepository _alcadaRepository;
    private readonly IAuditoriaRepository _auditoriaRepository;
    private readonly ILogger<AprovarContratoHandler> _logger;

    public async Task<Result> Handle(AprovarContratoCommand command, CancellationToken ct)
    {
        var contrato = await _contratoRepository
            .GetByIdAsync(command.ContratoId, ct);

        if (contrato == null)
            return Result.Failure("Contrato não encontrado");

        // Validar permissão do usuário para aprovar neste nível
        var permissaoOk = await ValidarPermissaoAprovacaoAsync(
            command.UsuarioId,
            contrato.ClienteId,
            contrato.ValorTotal,
            ct
        );

        if (!permissaoOk)
        {
            _logger.LogWarning(
                "Tentativa de aprovação sem permissão. Usuário: {UsuarioId}, Contrato: {ContratoId}, Valor: {Valor}",
                command.UsuarioId, contrato.Id, contrato.ValorTotal
            );
            return Result.Failure(
                "Usuário não possui alçada de aprovação para este valor de contrato"
            );
        }

        contrato.SetStatus(ContratoStatus.Aprovado);
        contrato.SetDataAprovacao(DateTime.UtcNow);
        contrato.SetAprovadoPor(command.UsuarioId);

        await _contratoRepository.UpdateAsync(contrato, ct);

        var auditoria = new AuditoriaOperacao(
            contrato.ClienteId,
            contrato.Id,
            "CTR_CONTRATO_APPROVED",
            $"Contrato aprovado por {command.UsuarioId} em {DateTime.UtcNow:dd/MM/yyyy HH:mm:ss}",
            new { Valor = contrato.ValorTotal, AprovadoPor = command.UsuarioId }
        );
        await _auditoriaRepository.AddAsync(auditoria, ct);

        _logger.LogInformation(
            "Contrato {ContratoId} aprovado por {UsuarioId}",
            contrato.Id, command.UsuarioId
        );

        return Result.Success();
    }

    private async Task<bool> ValidarPermissaoAprovacaoAsync(
        string usuarioId,
        string clienteId,
        decimal valorContrato,
        CancellationToken ct)
    {
        var alcada = await _alcadaRepository
            .GetAlcadaParaValorAsync(clienteId, valorContrato, ct);

        if (alcada == null)
            return false;

        // Verificar se usuário tem permissão para perfil de alçada
        var temPermissao = await _alcadaRepository
            .ValidarPermissaoUsuarioAsync(usuarioId, alcada.PerfilRequerido, ct);

        return temPermissao;
    }
}
```

**Exemplos**:
- Contrato valor R$5.000: Requer aprovação de Gestor (alçada até R$10.000)
- Contrato valor R$50.000: Requer aprovação de Diretor (alçada até R$100.000)
- Status: Rascunho → PendenteAprovacao → Aprovado

---

### RN-CTR-023-06: Bloqueio de Exclusao com Medicoes Associadas

**Descricao**: Um contrato não pode ser excluído (soft delete) se possuir medições ou faturas associadas (FK em RF090). O sistema retorna erro HTTP 409 Conflict informando quantidade exata de medições bloqueando a exclusão.

**Justificativa**: Garantir integridade referencial e auditoria. Medições precisam manter vínculo com contrato original para rastreabilidade financeira e conformidade legal.

**Implementacao**:
```csharp
public class ExcluirContratoHandler : ICommandHandler<ExcluirContratoCommand>
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IMedicaoRepository _medicaoRepository;
    private readonly IAuditoriaRepository _auditoriaRepository;
    private readonly ILogger<ExcluirContratoHandler> _logger;

    public async Task<Result> Handle(ExcluirContratoCommand command, CancellationToken ct)
    {
        var contrato = await _contratoRepository
            .GetByIdAsync(command.ContratoId, ct);

        if (contrato == null)
            return Result.Failure("Contrato não encontrado");

        // RN-CTR-023-06: Verificar se existem medições associadas
        var medicoes = await _medicaoRepository
            .GetMedicoesPorContratoAsync(command.ContratoId, ct);

        if (medicoes.Count > 0)
        {
            var valor = medicoes.Sum(m => m.ValorTotal);

            _logger.LogWarning(
                "Tentativa de excluir contrato com medições. Contrato: {ContratoId}, Medições: {Total}, Valor: {Valor}",
                command.ContratoId, medicoes.Count, valor
            );

            return Result.Failure(
                new DomainException(
                    $"Não é possível excluir contrato com {medicoes.Count} medição(ões) associada(s) " +
                    $"(Valor total: R${valor:F2}). Exclua as medições primeiro ou entre em contato com suporte."
                )
            );
        }

        // Soft delete
        contrato.SetIsDeleted(true);
        contrato.SetDataDelecao(DateTime.UtcNow);
        contrato.SetDeletadoPor(command.UsuarioId);

        await _contratoRepository.UpdateAsync(contrato, ct);

        // Auditoria
        var auditoria = new AuditoriaOperacao(
            contrato.ClienteId,
            contrato.Id,
            "CTR_CONTRATO_DELETE",
            $"Contrato excluído por {command.UsuarioId}",
            new
            {
                NumeroContrato = contrato.Numero,
                ValorTotal = contrato.ValorTotal,
                FornecedorId = contrato.FornecedorId,
                DataDelecao = DateTime.UtcNow
            }
        );
        await _auditoriaRepository.AddAsync(auditoria, ct);

        _logger.LogInformation(
            "Contrato {ContratoId} excluído com sucesso",
            contrato.Id
        );

        return Result.Success();
    }
}
```

**Exemplos**:
- Exclusão bem-sucedida: Contrato sem medições
- Bloqueado: Contrato com 5 medições (erro HTTP 409: "Não é possível excluir contrato com 5 medição(ões)")

---

### RN-CTR-023-07: Controle de Reajuste por Indice

**Descricao**: Contratos podem ter reajustes automáticos anuais conforme índice econômico (IGPM, IPCA, INPC, etc). O reajuste é calculado na data de aniversário (data de início) e aplicado ao ValorMensal e ValorTotal. Histórico de reajustes é registrado em tabela de auditoria.

**Justificativa**: Adequar valores contratuais à inflação e índices econômicos, conforme práticas comerciais e legislação. Garante revisão periódica automática.

**Implementacao**:
```csharp
public class AplicarReajusteContratoJob : IBackgroundJob
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IIndiceEconomicoService _indiceService;
    private readonly IAuditoriaRepository _auditoriaRepository;
    private readonly ILogger<AplicarReajusteContratoJob> _logger;

    public async Task ExecuteAsync(CancellationToken ct)
    {
        var hoje = DateTime.Today;

        // RN-CTR-023-07: Buscar contratos com reajuste automático e data de aniversário = hoje
        var contratosParaReajustar = await _contratoRepository
            .GetContratosPorReajusteAsync(hoje, ct);

        _logger.LogInformation(
            "Iniciando aplicação de reajustes. Total de contratos: {Total}",
            contratosParaReajustar.Count
        );

        foreach (var contrato in contratosParaReajustar)
        {
            if (string.IsNullOrEmpty(contrato.IndiceReajuste))
                continue;

            try
            {
                // Obter percentual do índice
                var percentualIndice = await _indiceService
                    .GetPercentualAsync(contrato.IndiceReajuste, ct);

                var valorMensalAnterior = contrato.ValorMensal;
                var valorTotalAnterior = contrato.ValorTotal;

                var novoValorMensal = Math.Round(
                    valorMensalAnterior * (1 + percentualIndice),
                    2
                );

                // Recalcular valor total
                var novoValorTotal = CalcularValorTotal(
                    novoValorMensal,
                    contrato.DataInicio,
                    contrato.DataFim
                );

                // Atualizar contrato
                contrato.SetValorMensal(novoValorMensal);
                contrato.SetValorTotal(novoValorTotal);
                contrato.SetDataUltimoReajuste(hoje);

                await _contratoRepository.UpdateAsync(contrato, ct);

                // Auditoria com detalhes completos
                var auditoria = new AuditoriaReajuste(
                    contrato.ClienteId,
                    contrato.Id,
                    "CTR_CONTRATO_REAJUSTE",
                    contrato.IndiceReajuste,
                    percentualIndice,
                    valorMensalAnterior,
                    novoValorMensal,
                    valorTotalAnterior,
                    novoValorTotal
                );
                await _auditoriaRepository.AddAsync(auditoria, ct);

                _logger.LogInformation(
                    "Reajuste aplicado. Contrato: {ContratoId}, Índice: {Indice}, " +
                    "Percentual: {Percentual}%, Valor anterior: R${ValorAnt}, Novo valor: R${NovoVal}",
                    contrato.Id, contrato.IndiceReajuste, percentualIndice * 100,
                    valorMensalAnterior, novoValorMensal
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "Erro ao aplicar reajuste para contrato {ContratoId}",
                    contrato.Id
                );
            }
        }

        await _auditoriaRepository.SaveChangesAsync(ct);
    }

    private decimal CalcularValorTotal(
        decimal valorMensal,
        DateTime dataInicio,
        DateTime dataFim)
    {
        var diasVigencia = (dataFim - dataInicio).TotalDays;
        var mesesVigencia = diasVigencia / 30.44m;
        return Math.Round(valorMensal * (decimal)mesesVigencia, 2);
    }
}
```

**Exemplos**:
- Contrato: IGPM, ValorMensal = R$1.000, data aniversário = 01/01
- IGPM em janeiro = 0,5% (obtido do serviço de índices)
- Novo ValorMensal = R$1.005 (1.000 * 1.005)
- Novo ValorTotal recalculado proporcionalmente

---

### RN-CTR-023-08: Validacao de CNPJ do Fornecedor

**Descricao**: Todo contrato deve estar associado a um fornecedor válido (FK para RF022). O CNPJ do fornecedor é validado no momento da criação/edição do contrato. CNPJ inválido ou fornecedor inativo retorna erro de validação HTTP 400.

**Justificativa**: Garantir que contratos sejam celebrados apenas com fornecedores cadastrados, validados e ativos na empresa, evitando fraude e inconsistências.

**Implementacao**:
```csharp
public class ValidarFornecedorContratoHandler : ICommandHandler<CriarContratoCommand>
{
    private readonly IFornecedorRepository _fornecedorRepository;
    private readonly IValidadorCNPJ _validadorCNPJ;
    private readonly ILogger<ValidarFornecedorContratoHandler> _logger;

    public async Task<Result> Handle(CriarContratoCommand command, CancellationToken ct)
    {
        // RN-CTR-023-08: Verificar se fornecedor existe e está ativo
        var fornecedor = await _fornecedorRepository
            .GetByIdAsync(command.FornecedorId, ct);

        if (fornecedor == null)
        {
            _logger.LogWarning(
                "Tentativa de criar contrato com fornecedor inexistente. FornecedorId: {FornecedorId}",
                command.FornecedorId
            );
            return Result.Failure("Fornecedor não encontrado");
        }

        if (!fornecedor.IsAtivo)
        {
            _logger.LogWarning(
                "Tentativa de criar contrato com fornecedor inativo. FornecedorId: {FornecedorId}, CNPJ: {CNPJ}",
                fornecedor.Id, fornecedor.CNPJ
            );
            return Result.Failure($"Fornecedor {fornecedor.RazaoSocial} está inativo");
        }

        // Validar CNPJ do fornecedor
        if (!_validadorCNPJ.IsValid(fornecedor.CNPJ))
        {
            _logger.LogError(
                "CNPJ inválido para fornecedor. FornecedorId: {FornecedorId}, CNPJ: {CNPJ}",
                fornecedor.Id, fornecedor.CNPJ
            );
            return Result.Failure(
                $"CNPJ do fornecedor {fornecedor.RazaoSocial} é inválido ({fornecedor.CNPJ})"
            );
        }

        // Prosseguir com criação do contrato
        var contrato = Contrato.Criar(
            command.ClienteId,
            fornecedor.Id,
            command.TipoContrato,
            command.Descricao,
            command.DataInicio,
            command.DataFim,
            command.ValorTotal,
            command.ValorMensal
        );

        return Result.Success();
    }
}
```

**Exemplos**:
- Válido: Fornecedor ABC LTDA com CNPJ 12.345.678/0001-90 (ativo e CNPJ válido)
- Inválido: Fornecedor XYZ (CNPJ 11.111.111/1111-11 = inválido)
- Inválido: Fornecedor inativo (IsAtivo = false)

---

### RN-CTR-023-09: Multi-tenancy (ClienteId Obrigatorio)

**Descricao**: Todos os contratos são isolados por ClienteId. Nenhuma operação (read, write, delete) pode ser realizada sem validação de ClienteId. Queries sempre filtram por ClienteId do usuário autenticado. Tentativa de acesso a contrato de outro cliente retorna HTTP 403 Forbidden.

**Justificativa**: Garantir isolamento total de dados entre clientes, atendendo requisitos de confidencialidade, LGPD, compliance e segregação de dados SaaS.

**Implementacao**:
```csharp
public class ContratoRepository : IContratoRepository
{
    private readonly ApplicationDbContext _dbContext;
    private readonly IUserContext _userContext; // Obtém ClienteId do usuário autenticado

    public async Task<Contrato> GetByIdAsync(
        Guid contratoId,
        CancellationToken ct)
    {
        var clienteId = _userContext.ClienteId;

        // RN-CTR-023-09: Sempre filtrar por ClienteId do usuário
        var contrato = await _dbContext.Contratos
            .Where(c => c.Id == contratoId && c.ClienteId == clienteId && !c.IsDeleted)
            .FirstOrDefaultAsync(ct);

        if (contrato == null)
            throw new NotFoundException(
                $"Contrato não encontrado ou acesso negado. ClienteId esperado: {clienteId}"
            );

        return contrato;
    }

    public async Task<IEnumerable<Contrato>> GetAllAsync(CancellationToken ct)
    {
        var clienteId = _userContext.ClienteId;

        // Sempre filtrar por ClienteId
        return await _dbContext.Contratos
            .Where(c => c.ClienteId == clienteId && !c.IsDeleted)
            .OrderBy(c => c.Numero)
            .ToListAsync(ct);
    }

    public async Task<bool> UpdateAsync(Contrato contrato, CancellationToken ct)
    {
        var clienteId = _userContext.ClienteId;

        // Validar que contrato pertence ao cliente autenticado
        if (contrato.ClienteId != clienteId)
            throw new UnauthorizedAccessException(
                $"Acesso negado. Contrato pertence a outro cliente. " +
                $"Cliente autenticado: {clienteId}, Cliente do contrato: {contrato.ClienteId}"
            );

        _dbContext.Contratos.Update(contrato);
        await _dbContext.SaveChangesAsync(ct);

        return true;
    }

    public async Task<bool> DeleteAsync(Guid contratoId, CancellationToken ct)
    {
        var clienteId = _userContext.ClienteId;

        var contrato = await GetByIdAsync(contratoId, ct);

        // Validação redundante (GetByIdAsync já fez, mas ser explícito)
        if (contrato.ClienteId != clienteId)
            throw new UnauthorizedAccessException("Acesso negado");

        contrato.SetIsDeleted(true);
        contrato.SetDataDelecao(DateTime.UtcNow);

        _dbContext.Contratos.Update(contrato);
        await _dbContext.SaveChangesAsync(ct);

        return true;
    }
}

// Middleware que valida ClienteId em toda requisição
public class ClienteIsolationMiddleware
{
    private readonly RequestDelegate _next;

    public ClienteIsolationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var clienteIdClaim = context.User
            .FindFirst("ClienteId")?
            .Value;

        if (string.IsNullOrEmpty(clienteIdClaim))
        {
            context.Response.StatusCode = StatusCodes.Status403Forbidden;
            await context.Response.WriteAsync("ClienteId não encontrado no token");
            return;
        }

        // Adicionar ClienteId ao context para ser usado por toda aplicação
        context.Items["ClienteId"] = clienteIdClaim;

        await _next(context);
    }
}
```

**Exemplos**:
- Cliente A (ClienteId: "aaa-111"): Vê apenas seus 10 contratos
- Cliente B (ClienteId: "bbb-222"): Vê apenas seus 15 contratos
- Tentativa de Cliente A acessar contrato de Cliente B: HTTP 403 Forbidden

---

### RN-CTR-023-10: Soft Delete com Auditoria

**Descricao**: Contratos nunca são deletados fisicamente do banco. Ao excluir (soft delete), a coluna IsDeleted é marcada como true, DataDelecao é registrada com timestamp, DeletadoPor registra usuário e uma entrada de auditoria é criada. Queries padrão filtram IsDeleted = false automaticamente.

**Justificativa**: Manter auditoria completa e permitir recuperação de dados em caso de erros operacionais, requisito legal de retenção e compliance.

**Implementacao**:
```csharp
public class ExcluirContratoHandler : ICommandHandler<ExcluirContratoCommand>
{
    private readonly IContratoRepository _contratoRepository;
    private readonly IAuditoriaRepository _auditoriaRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<ExcluirContratoHandler> _logger;

    public async Task<Result> Handle(ExcluirContratoCommand command, CancellationToken ct)
    {
        var contrato = await _contratoRepository
            .GetByIdAsync(command.ContratoId, ct);

        // RN-CTR-023-10: Soft delete com rastreamento
        contrato.SetIsDeleted(true);
        contrato.SetDataDelecao(DateTime.UtcNow);
        contrato.SetDeletadoPor(command.UsuarioId);

        await _contratoRepository.UpdateAsync(contrato, ct);

        // Auditoria com snapshot completo
        var snapshot = new
        {
            Id = contrato.Id,
            NumeroContrato = contrato.Numero,
            ValorTotal = contrato.ValorTotal,
            ValorMensal = contrato.ValorMensal,
            FornecedorId = contrato.FornecedorId,
            DataInicio = contrato.DataInicio,
            DataFim = contrato.DataFim,
            Status = contrato.Status,
            DeletadoEm = contrato.DataDelecao,
            DeletadoPor = command.UsuarioId,
            Motivo = command.Motivo
        };

        var auditoria = new AuditoriaOperacao(
            contrato.ClienteId,
            contrato.Id,
            "CTR_CONTRATO_DELETE",
            $"Contrato excluído com soft delete. Motivo: {command.Motivo}",
            snapshot
        );
        await _auditoriaRepository.AddAsync(auditoria, ct);

        await _unitOfWork.SaveChangesAsync(ct);

        _logger.LogInformation(
            "Contrato {ContratoId} deletado com soft delete. Snapshot salvo na auditoria",
            contrato.Id
        );

        return Result.Success();
    }
}

// Extension method para filtro automático
public static IQueryable<Contrato> IncluindoAtivos(
    this IQueryable<Contrato> query)
    => query.Where(c => !c.IsDeleted);

// Uso em repository
public async Task<IEnumerable<Contrato>> GetAllAsync(CancellationToken ct)
{
    var clienteId = _userContext.ClienteId;

    return await _dbContext.Contratos
        .IncluindoAtivos() // Filtro automático
        .Where(c => c.ClienteId == clienteId)
        .ToListAsync(ct);
}
```

**Exemplos**:
- Contrato excluído: IsDeleted = true, DataDelecao = 2025-12-28 10:30:45, DeletadoPor = "user-123"
- Auditoria registra: Quem deletou, quando, motivo, snapshot completo dos dados
- Relatórios automaticamente não mostram contratos deletados

---

## 3. REFERENCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IC1_Sistema_Producao`

**Tabela Principal**: `dbo.Contrato`
```sql
CREATE TABLE [dbo].[Contrato](
    [idContrato] [int] IDENTITY(1,1) NOT NULL,
    [idFornecedor] [int] NOT NULL,
    [idTipoContrato] [int] NOT NULL,
    [NumeroContrato] [varchar](50) NOT NULL,
    [Descricao] [varchar](500) NULL,
    [DataInicio] [datetime] NOT NULL,
    [DataFim] [datetime] NOT NULL,
    [ValorTotal] [decimal](18,2) NOT NULL,
    [ValorMensal] [decimal](18,2) NULL,
    [Status] [varchar](20) NOT NULL,
    [Ativo] [bit] NOT NULL,
    [DataCriacao] [datetime] NOT NULL,
    [DataUltimaAlteracao] [datetime] NULL,
    [UsuarioCriacao] [varchar](100) NOT NULL,
    [UsuarioAlteracao] [varchar](100) NULL,
    CONSTRAINT [PK_Contrato] PRIMARY KEY CLUSTERED ([idContrato] ASC),
    CONSTRAINT [FK_Contrato_Fornecedor] FOREIGN KEY ([idFornecedor])
        REFERENCES [dbo].[Fornecedor] ([idFornecedor]),
    CONSTRAINT [FK_Contrato_TipoContrato] FOREIGN KEY ([idTipoContrato])
        REFERENCES [dbo].[TipoContrato] ([idTipoContrato])
)
```

**Campos Importantes**:

| Campo Legado | Descrição | Uso no Modernizado |
|--------------|-----------|-------------------|
| `idContrato` | ID do contrato (PK auto-increment) | Mapeado para Contrato.Id (GUID com Identity) |
| `idFornecedor` | FK para fornecedor (int) | Mapeado para Contrato.FornecedorId (GUID) com integridade referencial |
| `NumeroContrato` | Número único do contrato (varchar 50) | Mantido como Contrato.Numero (string, unique por ClienteId) |
| `Descricao` | Descrição do contrato (varchar 500) | Expandido para Contrato.Descricao (nvarchar max) |
| `DataInicio` | Data de início da vigência | Mantido como DataInicio (DateTime) com validação RN-CTR-023-01 |
| `DataFim` | Data de fim da vigência | Mantido como DataFim (DateTime) com validação |
| `ValorTotal` | Valor total do contrato | Mantido como ValorTotal (decimal 18,2) com RN-CTR-023-02 |
| `ValorMensal` | Valor mensal | Mantido como ValorMensal (decimal 18,2) com cálculo automático |
| `Status` | Status (Rascunho, Ativo, Vencido) | Expandido para State Machine (10 estados) com workflow |
| `Ativo` | Flag de atividade (bit 1=Sim, 0=Não) | Transformado em IsDeleted (bit inverso) + Status detalhado |
| `DataCriacao` | Data de criação | Migrado para AuditoriaOperacao.DataOperacao (timestamp UTC) |
| `UsuarioCriacao` | Usuário que criou | Migrado para AuditoriaOperacao.UsuarioId (GUID ou email) |

### 3.2 Stored Procedures Legado

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `pa_ContratoBuscarTodos` | Listar todos os contratos com filtros básicos | GET /api/contratos com filtros dinâmicos (OrderBy, Filter, Pagination) |
| `pa_ContratoBuscarPorId` | Obter contrato por ID | GET /api/contratos/{id} |
| `pa_ContratoInserir` | Inserir novo contrato | POST /api/contratos (CriarContratoCommand) |
| `pa_ContratoAtualizar` | Atualizar contrato existente | PUT /api/contratos/{id} (AtualizarContratoCommand) |
| `pa_ContratoDeletar` | Deletar contrato (hard delete) | DELETE /api/contratos/{id} (soft delete com IsDeleted) |
| `pa_ContratoVencimentos` | Buscar contratos próximos de vencer | GET /api/contratos/vencimentos?dias=30 |
| `pa_ContratoRelatorio` | Gerar relatório em Excel | GET /api/contratos/export?formato=excel |

### 3.3 Telas ASPX

| Página | Descrição | Tela Moderna |
|--------|-----------|--------------|
| `Contrato.aspx` | Formulário de criação/edição de contrato | `/contratos/novo`, `/contratos/{id}/editar` (Angular) |
| `ContratoLista.aspx` | Listagem e busca de contratos | `/contratos` (SPA com DataTable/Grid) |
| `ContratoDetalhes.aspx` | Visualização de detalhes | `/contratos/{id}` (Card view com tabs) |
| `ContratoAnexos.aspx` | Gestão de anexos contratuais | `/contratos/{id}/anexos` (Upload/Download com preview) |
| `ContratoRelatorio.aspx` | Geração de relatórios | `/relatorios/contratos` (BI com filtros) |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSContrato.asmx.vb`

| Método | Descrição | Endpoint Moderno |
|--------|-----------|-----------------|
| `ListarContratos()` | Retorna lista de todos os contratos sem paginação | `GET /api/contratos` (com paginação: ?page=1&pageSize=50) |
| `BuscarPorId(idContrato)` | Obtém contrato completo por ID | `GET /api/contratos/{id}` |
| `Inserir(contrato)` | Cria novo contrato (validações mínimas) | `POST /api/contratos` (com 10 RNs de validação) |
| `Atualizar(contrato)` | Atualiza contrato existente | `PUT /api/contratos/{id}` |
| `Deletar(idContrato)` | Deleta contrato (hard delete) | `DELETE /api/contratos/{id}` (soft delete com RN-CTR-023-06) |
| `BuscarVencimentos(diasAntecipacao)` | Busca contratos próximos de vencer | `GET /api/contratos/vencimentos?dias=30` |
| `GerarRelatorio(filtros)` | Exporta relatório em Excel/PDF | `GET /api/contratos/export?formato=pdf` |
| `UploadAnexo(idContrato, arquivo)` | Upload de anexo contratual | `POST /api/contratos/{id}/anexos` |
| `ListarAnexos(idContrato)` | Lista anexos do contrato | `GET /api/contratos/{id}/anexos` |

---

## 4. INTEGRACOES OBRIGATORIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `CONTRATOS_GESTAO`, `CONTRATOS_WORKFLOW`, `CONTRATOS_ALERTAS`, `CONTRATOS_REAJUSTES`, `CONTRATOS_RENOVACAO_AUTOMATICA`

**Configuracao**:
```json
{
    "features": [
        {
            "featureKey": "CONTRATOS_GESTAO",
            "nome": "Gestão de Contratos",
            "descricao": "CRUD e operações básicas de contratos",
            "habilitado": true,
            "isSystemFeature": false,
            "ambiente": ["DEV", "HOM", "PRD"]
        },
        {
            "featureKey": "CONTRATOS_WORKFLOW",
            "nome": "Workflow de Aprovação de Contratos",
            "descricao": "Workflow de aprovação por alçadas de valor",
            "habilitado": true,
            "isSystemFeature": false,
            "ambiente": ["HOM", "PRD"]
        },
        {
            "featureKey": "CONTRATOS_ALERTAS",
            "nome": "Alertas de Vencimento",
            "descricao": "Alertas automáticos de vencimento de contratos (30/60/90 dias)",
            "habilitado": true,
            "isSystemFeature": false,
            "ambiente": ["HOM", "PRD"]
        },
        {
            "featureKey": "CONTRATOS_REAJUSTES",
            "nome": "Reajustes Automáticos",
            "descricao": "Reajustes automáticos por índices econômicos (IGPM, IPCA, INPC)",
            "habilitado": true,
            "isSystemFeature": false,
            "ambiente": ["HOM", "PRD"]
        },
        {
            "featureKey": "CONTRATOS_RENOVACAO_AUTOMATICA",
            "nome": "Renovação Automática",
            "descricao": "Renovação automática de contratos ao vencimento",
            "habilitado": true,
            "isSystemFeature": false,
            "ambiente": ["HOM", "PRD"]
        }
    ]
}
```

**Nota**: Feature flags permitem ativar/desativar funcionalidades sem deploy. Exemplo: se `CONTRATOS_ALERTAS` for desabilitado, jobs de alerta não executam.

---

### 4.2 Internacionalizacao (i18n)

**Chaves de Traducao**:

```json
{
    "contratos": {
        "gestao": {
            "title": "Gestão de Contratos",
            "description": "Administração de contratos com fornecedores e prestadores de serviço",
            "form": {
                "numero": "Número do Contrato",
                "fornecedor": "Fornecedor",
                "tipoContrato": "Tipo de Contrato",
                "descricao": "Descrição",
                "dataInicio": "Data de Início",
                "dataFim": "Data de Término",
                "valorTotal": "Valor Total",
                "valorMensal": "Valor Mensal",
                "moeda": "Moeda",
                "indiceReajuste": "Índice de Reajuste",
                "renovacaoAutomatica": "Renovação Automática",
                "status": "Status",
                "anexos": "Anexos"
            },
            "status": {
                "rascunho": "Rascunho",
                "pendenteAprovacao": "Pendente Aprovação",
                "aprovado": "Aprovado",
                "rejeitado": "Rejeitado",
                "ativo": "Ativo",
                "vencido": "Vencido",
                "renovado": "Renovado",
                "renovacaoAutomatica": "Renovação Automática",
                "cancelado": "Cancelado"
            },
            "tipoContrato": {
                "compra": "Compra",
                "locacao": "Locação",
                "manutencao": "Manutenção",
                "telecom": "Telecomunicações",
                "servico": "Serviço"
            },
            "messages": {
                "success": "Contrato salvo com sucesso",
                "error": "Erro ao salvar contrato",
                "delete": "Contrato excluído com sucesso",
                "deleteError": "Não é possível excluir contrato com medições associadas",
                "approval": "Contrato encaminhado para aprovação",
                "approved": "Contrato aprovado",
                "rejected": "Contrato rejeitado"
            },
            "validation": {
                "required": "Campo obrigatório",
                "dataFimGreaterThanDataInicio": "Data de término deve ser maior que data de início",
                "cnpjInvalid": "CNPJ do fornecedor é inválido",
                "fornecedorInativo": "Fornecedor está inativo"
            },
            "labels": {
                "criar": "Novo Contrato",
                "editar": "Editar Contrato",
                "visualizar": "Detalhes do Contrato",
                "excluir": "Excluir Contrato",
                "aprovar": "Aprovar Contrato",
                "rejeitar": "Rejeitar Contrato",
                "renovar": "Renovar Contrato",
                "anexos": "Anexos",
                "historico": "Histórico"
            },
            "alerts": {
                "vencimento30dias": "Contrato vencerá em 30 dias",
                "vencimento60dias": "Contrato vencerá em 60 dias",
                "vencimento90dias": "Contrato vencerá em 90 dias",
                "aguardandoAprovacao": "Contrato aguardando aprovação",
                "reajusteAplicado": "Reajuste aplicado ao contrato"
            }
        }
    }
}
```

**Suporte de idiomas**: pt-BR, en-US, es-ES

---

### 4.3 Auditoria

**Operacoes Auditadas**:

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Criar contrato | `CTR_CONTRATO_CREATE` | ID, Número, Fornecedor, Datas, Valores, UsuarioId |
| Editar contrato | `CTR_CONTRATO_UPDATE` | ID, Campos alterados (before/after JSON), UsuarioId |
| Excluir contrato | `CTR_CONTRATO_DELETE` | ID, Número, Motivo da exclusão, DataDelecao, UsuarioId |
| Aprovar contrato | `CTR_CONTRATO_APPROVE` | ID, Aprovador, Nível de aprovação, DataAprovacao |
| Rejeitar contrato | `CTR_CONTRATO_REJECT` | ID, Motivo da rejeição, UsuarioId |
| Upload de anexo | `CTR_CONTRATO_ANEXO_UPLOAD` | ID contrato, Nome do anexo, Tamanho, CRC32 |
| Aplicar reajuste | `CTR_CONTRATO_REAJUSTE` | ID, Índice, Percentual, Valores antes/depois |
| Renovar contrato | `CTR_CONTRATO_RENOVACAO` | ID contrato original, ID contrato novo, Periodicidade |
| Gerar alerta | `CTR_CONTRATO_ALERTA_VENCIMENTO` | ID, Dias de antecedência, DestinatarioEmail |

**Retenção**: 7 anos (conforme legislação fiscal brasileira e LGPD)

---

### 4.4 Controle de Acesso (RBAC)

**Permissoes**:

| Permissão | Descrição | Perfis |
|-----------|-----------|--------|
| `contratos:contratos:create` | Criar contrato | Gestor, Gerente Contrato, Admin |
| `contratos:contratos:read` | Visualizar contrato | Gestor, Gerente Contrato, Admin, Financeiro |
| `contratos:contratos:update` | Editar contrato | Gerente Contrato, Admin |
| `contratos:contratos:delete` | Excluir contrato | Admin |
| `contratos:contratos:approve` | Aprovar contrato | Gerente Contrato, Jurista, Diretor |
| `contratos:contratos:reject` | Rejeitar contrato | Gerente Contrato, Jurista, Diretor |
| `contratos:contratos:export` | Exportar relatório | Gerente Contrato, Admin, Financeiro |
| `contratos:anexos:upload` | Upload de anexo | Gerente Contrato, Admin |
| `contratos:anexos:read` | Visualizar anexo | Gestor, Gerente Contrato, Admin |
| `contratos:renovacao:criar` | Criar renovação | Gerente Contrato, Admin |

**Nota**: Perfis de aprovação são baseados em alçadas de valor configuráveis. Exemplo: Diretor aprova valores acima de R$100.000.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Metodo | Endpoint | Descricao | Permissao | Status HTTP |
|--------|----------|-----------|-----------|-------------|
| GET | `/api/contratos` | Listar contratos com filtros | `contratos:contratos:read` | 200, 403 |
| GET | `/api/contratos/{id}` | Obter contrato por ID | `contratos:contratos:read` | 200, 403, 404 |
| POST | `/api/contratos` | Criar contrato | `contratos:contratos:create` | 201, 400, 403 |
| PUT | `/api/contratos/{id}` | Atualizar contrato | `contratos:contratos:update` | 200, 400, 403, 404 |
| DELETE | `/api/contratos/{id}` | Excluir contrato (soft delete) | `contratos:contratos:delete` | 204, 403, 404, 409 |
| GET | `/api/contratos/buscar` | Busca avançada com paginação | `contratos:contratos:read` | 200, 400 |

### 5.2 Operacoes Especiais

| Metodo | Endpoint | Descricao | Permissao | Status HTTP |
|--------|----------|-----------|-----------|-------------|
| POST | `/api/contratos/{id}/anexos` | Upload de anexo | `contratos:anexos:upload` | 201, 400, 403, 404 |
| GET | `/api/contratos/{id}/anexos` | Listar anexos | `contratos:anexos:read` | 200, 403, 404 |
| GET | `/api/contratos/{id}/anexos/{anexoId}` | Download de anexo | `contratos:anexos:read` | 200, 403, 404 |
| DELETE | `/api/contratos/{id}/anexos/{anexoId}` | Excluir anexo | `contratos:anexos:upload` | 204, 403, 404 |
| POST | `/api/contratos/{id}/aprovar` | Aprovar contrato | `contratos:contratos:approve` | 200, 400, 403, 404 |
| POST | `/api/contratos/{id}/rejeitar` | Rejeitar contrato | `contratos:contratos:reject` | 200, 400, 403, 404 |
| POST | `/api/contratos/{id}/renovar` | Renovar contrato | `contratos:renovacao:criar` | 201, 400, 403, 404 |
| GET | `/api/contratos/vencimentos` | Contratos próximos de vencer | `contratos:contratos:read` | 200, 400 |
| GET | `/api/contratos/export` | Exportar relatório (Excel/PDF) | `contratos:contratos:export` | 200, 400, 403 |
| GET | `/api/contratos/{id}/historico` | Histórico de alterações | `contratos:contratos:read` | 200, 403, 404 |
| POST | `/api/contratos/{id}/simular-reajuste` | Simular reajuste futuro | `contratos:contratos:read` | 200, 400, 403, 404 |
| GET | `/api/contratos/metricas` | Métricas gerenciais | `contratos:contratos:read` | 200, 403 |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Criacao de Contrato

```
Usuário acessa /contratos/novo
    |
    v
Sistema carrega formulário (fornecedores, tipos, índices)
    |
    v
Usuário preenche dados (número, vigência, valores)
    |
    +--- Validações: CNPJ, datas, valores --------> Erro: HTTP 400 (loop para corrigir)
    |
    v
Usuário envia (POST /api/contratos)
    |
    v
Backend valida todas RNs (RN-CTR-023-01 até RN-CTR-023-09)
    |
    +--- Validação falha ----> Erro: HTTP 400, JSON com detalhes
    |
    v
Contrato criado (Status = Rascunho)
    |
    v
Auditoria registra CTR_CONTRATO_CREATE
    |
    v
Sistema retorna HTTP 201 + ID do contrato
    |
    v
Tela de confirmação: "Contrato criado com sucesso. Enviar para aprovação?"
```

### 6.2 Fluxo de Aprovacao (Workflow)

```
Usuário submete contrato para aprovação (POST /api/contratos/{id}/aprovar)
    |
    v
Sistema valida alçada de valor (RN-CTR-023-05)
    |
    +--- Valor até R$5.000 --------> Aprovador = Gestor
    |
    +--- Valor R$5.001 - R$50.000 -> Aprovador = Jurista
    |
    +--- Valor > R$50.000 --------> Aprovador = Diretor
    |
    v
Contrato passa para Status = PendenteAprovacao
    |
    v
Sistema notifica aprovador (E-mail + SignalR)
    |
    v
Aprovador acessa /contratos (dashboard pessoal com filtro de pendências)
    |
    v
Aprovador clica "Aprovar" ou "Rejeitar"
    |
    +--- Clicou "Aprovar" --------> Status = Aprovado, auditoria CTR_CONTRATO_APPROVE
    |
    +--- Clicou "Rejeitar" --------> Status = Rejeitado, auditoria CTR_CONTRATO_REJECT
    |
    v
Solicitante é notificado (E-mail + SignalR com resultado)
    |
    v
Fluxo termina
```

### 6.3 Fluxo de Alerta de Vencimento

```
Job BackgroundService dispara diariamente (00:00 UTC)
    |
    v
Job busca contratos com DataFim = hoje + 30/60/90 dias
    |
    v
Para cada contrato encontrado:
    |
    +--- Verifica se alerta já foi enviado --------> Sim: pula, Não: continua
    |
    v
Envia e-mail para usuário responsável (RN-CTR-023-04)
    |
    v
Envia notificação SignalR (tempo real no dashboard)
    |
    v
Registra auditoria (CTR_CONTRATO_ALERTA_VENCIMENTO)
    |
    v
Fim
```

---

## 7. SEGURANCA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **Multi-tenancy Isolamento** | ClienteId validado em todos os endpoints; tentativas de acesso a outro cliente retorna HTTP 403 |
| **Validação de Entrada** | Todos os campos validados (tipo, tamanho, range); valores fora do esperado retornam HTTP 400 |
| **RBAC + Alçadas** | Permissões baseadas em perfil + alçadas de valor; aprovações bloqueadas se usuário sem permissão |
| **Soft Delete Auditado** | Exclusões nunca removem dados; IsDeleted + DataDelecao + auditoria sempre registradas |
| **SQL Injection Protection** | Queries parametrizadas; ORM (EF Core) com proteção built-in contra SQL injection |
| **XSS Prevention** | Inputs sanitizados no backend; encoding no Angular; Content-Security-Policy headers |
| **CSRF Protection** | Tokens CSRF obrigatórios em POST/PUT/DELETE; validação no middleware |
| **Auditoria Imutável** | Logs de auditoria gravados em tabela separada com timestamp e hash de integridade |
| **Criptografia de Dados Sensíveis** | CNPJ, dados de anexos, informações de garantia criptografados em repouso |
| **Rate Limiting** | Máximo 1000 requisições/hora por IP; proteção contra brute force e DoS |

### 7.2 Testes de Seguranca Obrigatorios

- [ ] SQL Injection em campos: /api/contratos?filtro=' OR 1=1 --
- [ ] XSS em descrição: <script>alert('XSS')</script>
- [ ] CSRF: POST sem token CSRF
- [ ] Validação de permissões: Cliente A tenta acessar contrato de Cliente B
- [ ] Alçada não autorizada: Gestor tenta aprovar contrato de R$1.000.000
- [ ] Bypass de soft delete: Tentar referenciar contrato deletado
- [ ] Validação de CNPJ: CNPJ inválido deve ser rejeitado
- [ ] Datas inválidas: DataFim < DataInicio deve ser rejeitado
- [ ] Upload malicioso: Tentar upload de .exe disfarçado de .pdf
- [ ] Rate limiting: 1001+ requisições em uma hora devem ser bloqueadas

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao |
|-----|------|---------|
| **Contratos Ativos** | Manter >= 80% dos contratos em status Aprovado/Ativo | Contagem mensal em dashboard |
| **Taxa de Aprovação** | >= 90% dos contratos aprovados em até 5 dias | Diferença (DataAprovacao - DataSubmissao) |
| **Alertas de Vencimento Enviados** | 100% dos contratos a vencer recebem alerta | Contagem de CTR_CONTRATO_ALERTA_VENCIMENTO |
| **Renovações Automáticas Sucesso** | >= 95% das renovações automáticas executadas com sucesso | Contagem de renovações bem-sucedidas / total |
| **Tempo Médio de Aprovação** | <= 3 dias por nível de aprovação | (DataAprovacao - DataSubmissao) / níveis |
| **Cobertura de Medições** | >= 80% dos contratos tem medições associadas | Contratos com FK em Medicao / total |
| **Aderência de Reajustes** | 100% dos reajustes automáticos aplicados conforme índice | Reajustes aplicados / reajustes esperados |
| **Integridade de Anexos** | 100% dos anexos com hash de integridade validado | Anexos com hash válido / total |
| **Conformidade de Vigência** | 0 contratos com DataFim inválida | Contratos com DataFim < DataInicio |
| **Taxa de Exclusão Bloqueada** | 100% das exclusões bloqueadas com motivo claro | Exclusões rejeitadas com RN-CTR-023-06 |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **Contrato Vencido Não Renovado** | DataFim < Hoje E Status != Renovado E RenovacaoAutomatica = false | Notificar gestor (e-mail + SignalR) |
| **Reajuste Não Aplicado** | DataUltimoReajuste < (Hoje - 1 ano) E IndiceReajuste IS NOT NULL | Notificar admin, revisar configuração |
| **Anexo Corrompido** | Hash do anexo diferente ao download | Notificar admin, bloquear download |
| **Aprovação Travada** | PendenteAprovacao > 5 dias | Escalar para gerente direto |
| **Fornecedor Inativo** | Contrato associado a fornecedor com Ativo = false | Notificar gestor, bloquear renovação |
| **Valor Fora de Alçada** | Contrato criado com valor que viola alçada de aprovador | Bloquear submissão, exigir aprovador correto |
| **Multi-tenancy Violado** | Tentativa de acesso a contrato de outro ClienteId | Log de segurança, HTTP 403, notificar admin |
| **Taxa Limite Atingida** | > 1000 requisições por hora de um IP | Rate limiting: HTTP 429, IP bloqueado por 1 hora |

---

## 9. PROXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-RF023](./MD-RF023.md)
2. **Casos de Uso**: Criar [UC-RF023](./UC-RF023.md)
3. **Workflow de Telas**: Criar [WF-RF023](./WF-RF023.md)
4. **User Stories**: Criar [user-stories.yaml](./user-stories.yaml)
5. **Implementação Backend**: Commands/Queries/Handlers/Controllers
6. **Implementação Frontend**: Componentes Angular/Telas/Rotas
7. **Testes Automatizados**: Unit tests, Integration tests, E2E (Playwright)
8. **Testes de Segurança**: SQL Injection, XSS, CSRF, Permissões
9. **Documentação de Testes**: [TC-RF023-BACKEND.md](./TC-RF023-BACKEND.md), [TC-RF023-FRONTEND.md](./TC-RF023-FRONTEND.md)
10. **Deploy em HOM**: Validação do ambiente de homologação

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versão inicial com 10 RNs, 13+ endpoints, fluxos, segurança e KPIs | Claude Code |

---

**Ultima Atualizacao**: 2025-12-28 10:35:00
**Autor**: Claude Code
**Revisao**: Pendente
