# RF066 - Notificações e Alertas

**Versão:** 2.0
**Data:** 2025-12-30
**Responsável:** Equipe de Arquitetura IControlIT
**Fase:** Fase-2-Cadastros-e-Servicos-Transversais
**EPIC:** EPIC005-NOT-Notificacoes

---

## SEÇÃO 1: VISÃO GERAL

### 1.1 Objetivo

Implementar sistema centralizado de notificações multi-canal que permita envio automatizado de alertas, comunicados e avisos para usuários através de múltiplos meios de comunicação (e-mail, SMS, push notifications, WhatsApp Business e notificações in-app), com suporte a preferências individuais, priorização, agrupamento inteligente, retry automático em caso de falha, rastreamento de entrega, histórico completo e métricas de engajamento.

### 1.2 Importância Estratégica

O sistema de notificações é fundamental para:

- **Comunicação Proativa**: Alertar usuários sobre eventos críticos (SLA vencendo, aprovações pendentes, erros críticos) antes que se tornem problemas
- **Redução de SLA Breach**: Notificar responsáveis imediatamente quando prazos estão próximos de vencimento
- **Engajamento de Usuários**: Manter usuários informados sobre mudanças, atualizações e ações necessárias
- **Compliance com Comunicações Obrigatórias**: Garantir que comunicações regulatórias sejam entregues conforme exigido
- **Experiência do Usuário**: Permitir que usuários escolham como e quando querem ser notificados
- **Rastreabilidade**: Manter histórico completo de todas as comunicações enviadas para auditoria e compliance

### 1.3 Escopo

**Incluído neste RF:**

- Envio de notificações via 5 canais: E-mail, SMS, Push Notifications (mobile/web), WhatsApp Business API, In-App (SignalR)
- Configuração de preferências de usuário por tipo de notificação e canal
- Priorização de notificações (Baixa, Normal, Alta, Urgente, Crítica)
- Quiet Hours configurável (padrão 22h-8h) para notificações não urgentes
- Agrupamento inteligente de notificações do mesmo tipo (evitar spam)
- Retry automático com backoff exponencial (3 tentativas: imediato, 2min, 4min, 8min)
- Notificações in-app em tempo real via SignalR (push WebSocket)
- Templates de notificação integrados com RF063 (Gestão de Templates)
- Rastreamento de entrega (SMS entregue, e-mail aberto, push recebido, in-app visualizada)
- Notificações obrigatórias (compliance) que não podem ser desabilitadas pelo usuário
- Digest diário opcional (resumo às 18h ao invés de notificações imediatas)
- Ações rápidas em notificações (botões: Aprovar, Rejeitar, Ver Detalhes, Responder)
- Expiração automática de notificações antigas (>30 dias lidas, >90 dias não lidas = arquivadas)
- Rate limiting anti-spam (máximo 50 notificações por usuário por dia)
- Integração com WhatsApp Business API (mensagens transacionais)
- Dashboard central de notificações (filtros, busca, marcar todas como lidas, arquivar)
- Métricas de entrega e engajamento (taxa de abertura, taxa de clique, tempo médio de leitura)
- Histórico completo de notificações enviadas com auditoria

**Excluído deste RF:**

- Envio de newsletters marketing (coberto por ferramenta externa de email marketing)
- Notificações push para aplicativos mobile nativos iOS/Android (será coberto por RF futuro quando apps nativos forem desenvolvidos)
- Gestão de templates de notificação (coberto por RF063)
- Configuração de remetentes de e-mail e SMTP (coberto por RF001 - Parâmetros do Sistema)
- Análise avançada de métricas e dashboards executivos (será coberto por RF de BI)

---

## SEÇÃO 2: FUNCIONALIDADES

### 2.1 Enviar Notificação Multi-Canal

**Descrição**: Permite ao sistema ou usuário autorizado enviar notificação para um ou múltiplos destinatários através de um ou mais canais de comunicação simultaneamente.

**Atores**: Sistema (automático via eventos), Administrador, Gestor de Notificações

**Pré-condições**: Usuário destinatário cadastrado, canais configurados (credenciais SMTP, API keys SMS/WhatsApp)

**Fluxo**:
1. Sistema ou usuário dispara evento de notificação (ex: "SLA vencendo em 1 hora")
2. Sistema identifica usuários destinatários baseado em regras de negócio
3. Para cada destinatário, sistema consulta preferências de canal
4. Sistema aplica regras de priorização e quiet hours
5. Sistema verifica agrupamento inteligente (se múltiplas notificações do mesmo tipo em 30min, agrupar)
6. Sistema enfileira jobs assíncronos no Hangfire para envio por canal:
   - E-mail: via SMTP configurado
   - SMS: via API SMS provider (Twilio, Nexmo, etc.)
   - Push: via Firebase Cloud Messaging (web push)
   - WhatsApp: via WhatsApp Business API
   - In-App: via SignalR (push imediato)
7. Sistema registra notificação no banco com status "Enfileirada"
8. Jobs processam envios em background
9. Sistema atualiza status para "Enviada" ou "Falha" conforme resultado
10. Em caso de falha, aplica retry automático com backoff exponencial

**Pós-condições**: Notificação enviada por todos os canais configurados, histórico registrado, métricas atualizadas

### 2.2 Configurar Preferências de Notificação

**Descrição**: Permite ao usuário configurar quais tipos de notificação deseja receber e por quais canais, definindo preferências personalizadas de comunicação.

**Atores**: Usuário Final, Administrador (configurando para outro usuário)

**Pré-condições**: Usuário autenticado

**Fluxo**:
1. Usuário acessa tela "Minhas Preferências de Notificação"
2. Sistema exibe lista de tipos de notificação disponíveis agrupados por categoria:
   - Aprovações (Aprovação Pendente, Aprovação Rejeitada)
   - SLA (SLA Vencendo em 1h, SLA Vencido)
   - Solicitações (Nova Solicitação Atribuída, Solicitação Atualizada)
   - Sistema (Manutenção Programada, Erro Crítico)
   - Financeiro (Fatura Processada, Glosa Identificada)
3. Para cada tipo, usuário seleciona canais habilitados (checkboxes: E-mail, SMS, Push, WhatsApp, In-App)
4. Usuário pode marcar "Digest Diário" para receber resumo às 18h ao invés de notificações imediatas
5. Usuário pode configurar horários de quiet hours personalizados (padrão 22h-8h)
6. Usuário salva preferências
7. Sistema valida que notificações obrigatórias (compliance) não podem ser desabilitadas
8. Sistema salva configurações no banco

**Pós-condições**: Preferências salvas, próximas notificações respeitarão configurações

### 2.3 Visualizar Central de Notificações

**Descrição**: Exibe dashboard centralizado com todas as notificações in-app recebidas pelo usuário, permitindo filtros, busca, marcar como lida, arquivar e executar ações rápidas.

**Atores**: Usuário Final

**Pré-condições**: Usuário autenticado

**Fluxo**:
1. Usuário clica em ícone de sino (notificações) no header
2. Sistema exibe painel lateral com notificações não lidas (mais recentes primeiro)
3. Cada notificação exibe:
   - Ícone do tipo (aprovação, alerta, info)
   - Título resumido
   - Tempo relativo (5min atrás, 2h atrás, ontem)
   - Badge de prioridade (se Alta/Urgente/Crítica)
   - Botões de ação rápida (se aplicável): Aprovar, Rejeitar, Ver Detalhes
4. Usuário pode clicar em notificação para expandir e ver mensagem completa
5. Sistema marca automaticamente como lida ao expandir
6. Usuário pode usar filtros:
   - Não lidas / Lidas / Todas
   - Por tipo (Aprovações, SLA, etc.)
   - Por período (Hoje, Últimos 7 dias, Últimos 30 dias)
7. Usuário pode buscar por texto livre em título/mensagem
8. Usuário pode marcar todas como lidas
9. Usuário pode arquivar notificações antigas
10. Sistema atualiza badge de contador no ícone de sino em tempo real via SignalR

**Pós-condições**: Notificações visualizadas e gerenciadas, contador atualizado

### 2.4 Receber Notificação In-App em Tempo Real

**Descrição**: Usuário recebe notificação in-app instantaneamente via SignalR (WebSocket push) enquanto está com o sistema aberto, sem necessidade de refresh manual.

**Atores**: Usuário Final

**Pré-condições**: Usuário autenticado e com sistema aberto em navegador/app

**Fluxo**:
1. Sistema gera evento de notificação (ex: aprovação pendente atribuída ao usuário)
2. Backend cria registro de notificação no banco
3. Backend envia mensagem SignalR para Hub de Notificações
4. Hub identifica conexões WebSocket ativas do usuário destinatário (pode ter múltiplas abas abertas)
5. Hub envia push para todas as conexões do usuário
6. Frontend recebe evento SignalR e:
   - Exibe toast notification no canto superior direito (3 segundos)
   - Incrementa badge de contador no ícone de sino
   - Adiciona notificação na lista do painel lateral (se aberto)
   - Reproduz som de notificação (se habilitado nas preferências)
7. Usuário pode clicar no toast para ir direto para ação relacionada
8. Toast desaparece automaticamente após 3 segundos

**Pós-condições**: Notificação entregue em tempo real, usuário ciente imediatamente

### 2.5 Agrupar Notificações Inteligentemente

**Descrição**: Sistema agrupa automaticamente múltiplas notificações do mesmo tipo recebidas em curto período de tempo (30 minutos) para evitar spam e melhorar experiência do usuário.

**Atores**: Sistema (automático)

**Pré-condições**: Múltiplas notificações do mesmo tipo para mesmo usuário em janela de 30min

**Fluxo**:
1. Sistema identifica que há mais de 5 notificações do mesmo tipo (ex: "Nova Solicitação") para mesmo usuário em últimos 30 minutos
2. Sistema cancela envio individual de notificações pendentes desse tipo
3. Sistema cria notificação agrupada única: "Você tem 12 novas solicitações aguardando atribuição"
4. Sistema envia notificação agrupada por canais configurados
5. Sistema marca notificações individuais como "Enviada via agrupamento"
6. Quando usuário clica na notificação agrupada, é direcionado para lista filtrada com todas as solicitações relacionadas

**Pós-condições**: Usuário recebe 1 notificação ao invés de 12, reduzindo ruído

### 2.6 Aplicar Retry Automático em Falhas

**Descrição**: Sistema tenta automaticamente reenviar notificações que falharam (ex: timeout de API SMS, servidor SMTP indisponível) com backoff exponencial até 3 tentativas.

**Atores**: Sistema (Hangfire background job)

**Pré-condições**: Falha no envio de notificação por canal

**Fluxo**:
1. Job Hangfire tenta enviar notificação via SMS
2. API SMS retorna erro de timeout
3. Sistema registra falha e incrementa contador de tentativas
4. Sistema agenda retry com backoff exponencial:
   - 1ª tentativa: imediata (já falhou)
   - 2ª tentativa: após 2 minutos
   - 3ª tentativa: após 4 minutos (total 6min desde falha inicial)
   - 4ª tentativa: após 8 minutos (total 14min desde falha inicial)
5. Se 4ª tentativa falhar, sistema marca notificação como "Falha Permanente"
6. Sistema envia alerta para administradores de sistema sobre falha permanente
7. Sistema registra log detalhado com stack trace para investigação

**Pós-condições**: Notificação reenviada automaticamente ou marcada como falha permanente após 3 retries

### 2.7 Rastrear Entrega e Engajamento

**Descrição**: Sistema rastreia métricas de entrega e engajamento de notificações (SMS entregue, e-mail aberto, link clicado, push recebido) para análise de efetividade.

**Atores**: Sistema (webhooks de providers), Gestor de Notificações (visualização de métricas)

**Pré-condições**: Notificação enviada, webhooks configurados

**Fluxo**:
1. Sistema envia e-mail com pixel de rastreamento e links com parâmetros UTM
2. Sistema envia SMS via provider que suporta delivery receipts
3. Providers externos (Twilio, SendGrid) enviam webhooks para sistema quando:
   - SMS entregue (ou falha de entrega)
   - E-mail aberto (pixel carregado)
   - Link em e-mail/SMS clicado
   - Push notification recebido no dispositivo
4. Sistema recebe webhook e atualiza registro de notificação:
   - `DataEntrega`: quando SMS/e-mail foi entregue
   - `DataAbertura`: quando e-mail foi aberto ou push foi recebido
   - `DataClique`: quando link foi clicado
5. Sistema calcula métricas agregadas:
   - Taxa de entrega: (entregues / enviadas) × 100
   - Taxa de abertura: (abertas / entregues) × 100
   - Taxa de clique (CTR): (cliques / abertas) × 100
   - Tempo médio de leitura: média de (DataAbertura - DataEnvio)
6. Gestor pode visualizar dashboard com métricas por tipo de notificação, canal, período

**Pós-condições**: Métricas de engajamento disponíveis para análise

### 2.8 Executar Ações Rápidas em Notificações

**Descrição**: Permite ao usuário executar ações diretamente na notificação (aprovar, rejeitar, ver detalhes, responder) sem necessidade de navegar para tela específica.

**Atores**: Usuário Final

**Pré-condições**: Notificação recebida com ações configuradas

**Fluxo**:
1. Usuário recebe notificação "Solicitação #1234 aguardando aprovação"
2. Notificação exibe botões de ação rápida: [Aprovar] [Rejeitar] [Ver Detalhes]
3. Usuário clica em "Aprovar"
4. Sistema exibe modal confirmação: "Tem certeza que deseja aprovar Solicitação #1234?"
5. Usuário confirma
6. Sistema executa ação (chama endpoint de aprovação)
7. Sistema marca notificação como "Ação Executada"
8. Sistema exibe toast de sucesso: "Solicitação #1234 aprovada com sucesso"
9. Sistema remove notificação da lista de pendentes
10. Sistema envia notificação para solicitante informando aprovação

**Pós-condições**: Ação executada sem necessidade de navegar para outra tela, produtividade aumentada

### 2.9 Aplicar Quiet Hours

**Descrição**: Sistema respeita configuração de horários de silêncio (quiet hours), não enviando notificações não urgentes durante período configurado (padrão 22h-8h).

**Atores**: Sistema (scheduler)

**Pré-condições**: Notificação com prioridade Normal ou Baixa gerada fora de horário comercial

**Fluxo**:
1. Sistema gera notificação "Relatório mensal disponível" às 23h (prioridade Normal)
2. Sistema verifica que hora atual (23h) está dentro de quiet hours (22h-8h)
3. Sistema verifica que prioridade não é Urgente nem Crítica
4. Sistema agenda envio da notificação para próximo horário permitido (8h do dia seguinte)
5. Sistema enfileira job Hangfire com delay: `Schedule(() => EnviarNotificacao(id), DateTime.Today.AddDays(1).AddHours(8))`
6. Às 8h, job é executado e notificação é enviada normalmente
7. Notificações Urgentes ou Críticas ignoram quiet hours e são enviadas imediatamente

**Pós-condições**: Usuário não recebe notificações não críticas durante período de descanso

### 2.10 Enviar Digest Diário

**Descrição**: Para usuários que optaram por digest diário, sistema envia resumo consolidado de todas as notificações do dia em único e-mail às 18h ao invés de envios individuais.

**Atores**: Sistema (Hangfire recorrente diário)

**Pré-condições**: Usuário configurou opção "Digest Diário" em preferências

**Fluxo**:
1. Job Hangfire recorrente executa diariamente às 18h
2. Job consulta usuários com preferência "Digest Diário" habilitada
3. Para cada usuário, consulta notificações geradas nas últimas 24h
4. Sistema agrupa notificações por tipo:
   - Aprovações Pendentes: 3
   - SLA Vencendo: 1
   - Novas Solicitações: 5
5. Sistema renderiza template de e-mail com resumo:
   - Cabeçalho: "Seu resumo diário - 12 de Dezembro de 2025"
   - Seções por tipo de notificação
   - Links diretos para ações
6. Sistema envia e-mail único consolidado
7. Sistema marca notificações individuais como "Enviada via digest"
8. Notificações Urgentes ou Críticas não aguardam digest e são enviadas imediatamente

**Pós-condições**: Usuário recebe 1 e-mail consolidado ao invés de múltiplos durante o dia

### 2.11 Arquivar Notificações Antigas

**Descrição**: Sistema arquiva automaticamente notificações antigas (lidas há mais de 30 dias ou não lidas há mais de 90 dias) para manter performance e organização.

**Atores**: Sistema (Hangfire recorrente semanal)

**Pré-condições**: Notificações antigas no sistema

**Fluxo**:
1. Job Hangfire recorrente executa semanalmente (domingos às 2h)
2. Job consulta notificações que atendem critérios de arquivamento:
   - Lidas há mais de 30 dias: `Lida = true AND DataLeitura < DateTime.UtcNow.AddDays(-30)`
   - Não lidas há mais de 90 dias: `Lida = false AND DataCriacao < DateTime.UtcNow.AddDays(-90)`
3. Para cada notificação identificada:
   - Move para tabela de arquivo frio `NotificacoesArquivadas` (otimização de performance)
   - Ou marca flag `Arquivada = true` (abordagem mais simples)
4. Job registra quantidade de notificações arquivadas em log
5. Notificações arquivadas não aparecem em consultas padrão da central de notificações
6. Usuário pode acessar "Notificações Arquivadas" em tela específica se necessário

**Pós-condições**: Tabela de notificações ativas otimizada, histórico preservado em arquivo

### 2.12 Aplicar Rate Limiting Anti-Spam

**Descrição**: Sistema limita quantidade máxima de notificações que um usuário pode receber por dia (padrão 50) para prevenir spam e sobrecarga.

**Atores**: Sistema (validação antes de envio)

**Pré-condições**: Tentativa de enviar notificação para usuário

**Fluxo**:
1. Sistema tenta enviar notificação para usuário
2. Sistema consulta quantidade de notificações enviadas para esse usuário nas últimas 24h
3. Se contador < 50 (limite configurável):
   - Sistema prossegue com envio normalmente
4. Se contador >= 50:
   - Sistema verifica prioridade da notificação
   - Se prioridade for Crítica ou Urgente: ignora limite e envia
   - Se prioridade for Normal ou Baixa: descarta envio
   - Sistema registra log de rate limiting aplicado
   - Sistema envia alerta único para administradores: "Usuário X atingiu limite de 50 notificações/dia"
5. Contador é resetado a cada 24h

**Pós-condições**: Usuário protegido contra spam, notificações críticas sempre entregues

### 2.13 Integrar com WhatsApp Business API

**Descrição**: Envia notificações transacionais via WhatsApp Business API para usuários que configuraram telefone e optaram por receber notificações por este canal.

**Atores**: Sistema

**Pré-condições**: WhatsApp Business API configurado (credenciais, templates aprovados pelo WhatsApp), usuário com telefone válido cadastrado

**Fluxo**:
1. Sistema identifica que usuário tem WhatsApp habilitado nas preferências
2. Sistema valida que template de mensagem foi aprovado pelo WhatsApp (requisito da API)
3. Sistema envia request para WhatsApp Business API:
   - Número destinatário (formato internacional: +5511999999999)
   - Template ID
   - Parâmetros do template (ex: nome do usuário, número da solicitação)
4. WhatsApp API retorna ID da mensagem
5. Sistema registra ID no banco para rastreamento
6. WhatsApp envia webhooks de status (enviado, entregue, lido, falha)
7. Sistema atualiza status da notificação conforme webhooks

**Pós-condições**: Notificação enviada via WhatsApp, status rastreado

---

## SEÇÃO 3: REGRAS DE NEGÓCIO

### RN-NOT-066-01: Canais de Notificação Suportados

**Descrição**: O sistema deve suportar exatamente 5 canais de notificação: E-mail (via SMTP configurado), SMS (via API de provider externo como Twilio ou Nexmo), Push Notifications (via Firebase Cloud Messaging para web push), WhatsApp Business (via WhatsApp Business API) e In-App (via SignalR WebSocket). Cada canal possui características específicas de entrega e rastreamento.

**Motivação**: Permitir que usuários escolham o canal mais conveniente para cada tipo de notificação, aumentando engajamento e garantindo entrega mesmo se um canal falhar.

**Impacto**: Backend deve implementar interface abstrata `INotificationChannel` com implementações concretas para cada canal. Frontend deve permitir seleção individual de canais nas preferências do usuário.

### RN-NOT-066-02: Preferências Granulares por Tipo e Canal

**Descrição**: Usuários devem poder configurar preferências de notificação de forma granular, escolhendo para cada tipo de notificação (ex: Aprovação Pendente, SLA Vencendo, Nova Solicitação) quais canais desejam habilitar (E-mail, SMS, Push, WhatsApp, In-App). Um mesmo tipo pode ter múltiplos canais habilitados simultaneamente (ex: receber por E-mail E In-App). Preferências padrão caso usuário não configure: E-mail e In-App habilitados para todos os tipos.

**Motivação**: Respeitar preferências individuais de comunicação, evitar spam e melhorar experiência do usuário permitindo controle total sobre como ser notificado.

**Impacto**: Tabela `PreferenciasNotificacao` deve ter chave composta (UsuarioId, TipoNotificacao) com lista de canais habilitados. Sistema deve consultar preferências antes de enviar cada notificação e respeitar configurações.

### RN-NOT-066-03: Priorização com 5 Níveis

**Descrição**: Notificações devem ser classificadas em 5 níveis de prioridade: Baixa (informações não urgentes, cor azul), Normal (notificações padrão, cor cinza), Alta (requer atenção breve, cor laranja), Urgente (requer ação imediata, cor vermelha) e Crítica (falhas críticas do sistema, cor vermelha piscante). Prioridade determina comportamento de envio: Baixa e Normal respeitam quiet hours, Alta/Urgente/Crítica ignoram quiet hours e são enviadas imediatamente. Prioridade Crítica ignora rate limiting.

**Motivação**: Garantir que comunicações realmente importantes sejam entregues imediatamente enquanto notificações menos urgentes respeitam horários de descanso do usuário.

**Impacto**: Enum `Prioridade` com 5 valores. Lógica de envio deve verificar prioridade antes de aplicar quiet hours e rate limiting. Frontend deve exibir badges visuais distintos por prioridade.

### RN-NOT-066-04: Quiet Hours Configurável

**Descrição**: Sistema deve implementar conceito de Quiet Hours (horários de silêncio) durante os quais notificações de prioridade Baixa e Normal não devem ser enviadas. Horário padrão: 22h às 8h. Usuários podem customizar horários nas preferências (ex: 23h às 7h). Notificações geradas durante quiet hours são agendadas automaticamente para próximo horário permitido (8h ou horário customizado do usuário). Notificações com prioridade Alta, Urgente ou Crítica ignoram quiet hours e são enviadas imediatamente.

**Motivação**: Respeitar horário de descanso dos usuários, evitando acordá-los com notificações não urgentes durante a madrugada, melhorando satisfação e evitando fadiga de notificações.

**Impacto**: Implementar job scheduler que verifica horário atual e prioridade antes de enviar. Se dentro de quiet hours E prioridade Baixa/Normal, agendar com delay até próximo horário permitido usando `BackgroundJob.Schedule()` do Hangfire.

### RN-NOT-066-05: Agrupamento Inteligente

**Descrição**: Se mais de 5 notificações do mesmo tipo (ex: "Nova Solicitação") forem geradas para mesmo usuário em janela de 30 minutos, sistema deve cancelar envios individuais e enviar notificação agrupada única consolidando todas (ex: "Você tem 12 novas solicitações"). Agrupamento se aplica apenas para notificações de prioridade Baixa e Normal. Alta/Urgente/Crítica nunca são agrupadas e são sempre enviadas individualmente. Usuário pode desabilitar agrupamento nas preferências se desejar receber notificações individuais.

**Motivação**: Evitar spam quando múltiplos eventos do mesmo tipo ocorrem simultaneamente (ex: 50 solicitações criadas em importação em lote), melhorando experiência do usuário e reduzindo custos de SMS.

**Impacto**: Job scheduler deve consultar notificações pendentes agrupáveis nos últimos 30min, agrupar quando contador > 5, gerar notificação consolidada e marcar individuais como "Enviada via agrupamento".

### RN-NOT-066-06: Retry Automático com Backoff Exponencial

**Descrição**: Se envio de notificação falhar (timeout de API, servidor indisponível, credenciais inválidas), sistema deve tentar reenviar automaticamente até 3 vezes com intervalos crescentes: 1ª tentativa imediata (falhou), 2ª tentativa após 2 minutos, 3ª tentativa após 4 minutos (total 6min), 4ª tentativa após 8 minutos (total 14min). Se 4ª tentativa falhar, marcar como Falha Permanente e enviar alerta para administradores. Retry se aplica a todos os canais exceto In-App (que é síncrono via SignalR). Cada canal tem retry independente (falha em SMS não afeta envio por E-mail).

**Motivação**: Garantir resiliência a falhas temporárias de infraestrutura (API provider fora do ar por minutos, timeout de rede), maximizando taxa de entrega sem precisar intervenção manual.

**Impacto**: Configurar atributo `[AutomaticRetry(Attempts = 4, DelaysInSeconds = new[] { 0, 120, 240, 480 })]` em jobs Hangfire. Registrar cada tentativa em log com timestamp e motivo da falha para análise posterior.

### RN-NOT-066-07: Notificações In-App em Tempo Real via SignalR

**Descrição**: Notificações In-App devem ser entregues instantaneamente via SignalR (WebSocket push) para usuários que estejam com sistema aberto em navegador ou aplicação web. Backend deve enviar evento para Hub SignalR após salvar notificação no banco. Hub identifica todas as conexões ativas do usuário destinatário (pode ter múltiplas abas abertas) e envia push para todas. Frontend exibe toast notification no canto superior direito (3 segundos), incrementa badge de contador no ícone de sino, adiciona notificação no painel lateral e opcionalmente reproduz som (se habilitado). Se usuário não estiver conectado, notificação fica armazenada e será exibida quando fizer login.

**Motivação**: Fornecer feedback instantâneo de eventos críticos (aprovação rejeitada, SLA vencido) sem necessidade de usuário fazer refresh manual, melhorando experiência e permitindo reação rápida.

**Impacto**: Implementar Hub SignalR `NotificationHub` com método `NotifyUser(userId, notification)`. Backend invoca hub após cada notificação salva. Frontend estabelece conexão SignalR no login e escuta evento `ReceiveNotification`.

### RN-NOT-066-08: Templates Integrados com RF063

**Descrição**: Mensagens de notificação devem utilizar templates pré-definidos do RF063 (Gestão de Templates) com suporte a placeholders dinâmicos. Cada tipo de notificação tem template associado (ex: template "APROVACAO_PENDENTE" contém placeholders: {nomeUsuario}, {numeroSolicitacao}, {dataVencimento}). Sistema substitui placeholders por valores reais antes de enviar. Templates podem ter versões por canal (template de e-mail pode ser HTML rico, template de SMS deve ser texto simples curto). Administradores podem editar templates via RF063 sem alterar código.

**Motivação**: Padronizar comunicações, permitir personalização de mensagens sem deploy de código, suportar multi-idioma (templates em pt-BR, en-US, es-ES via integração i18n).

**Impacto**: Sistema deve consultar template via API do RF063 passando código do template e idioma do usuário, receber HTML/texto renderizado, substituir placeholders com dados do contexto da notificação, e enviar resultado final.

### RN-NOT-066-09: Rastreamento de Entrega e Engajamento

**Descrição**: Sistema deve rastrear métricas detalhadas de entrega e engajamento para cada notificação enviada: Data de Envio, Data de Entrega (confirmação do provider de SMS/e-mail), Data de Abertura (e-mail aberto via pixel tracking ou push recebido no dispositivo), Data de Clique (link em e-mail/SMS clicado), Ação Executada (se usuário executou ação rápida tipo aprovar/rejeitar). Providers externos (Twilio SMS, SendGrid e-mail) enviam webhooks confirmando entrega e abertura. Sistema expõe endpoints para receber webhooks e atualizar registros. Dashboard de métricas exibe taxas agregadas: Taxa de Entrega, Taxa de Abertura, Taxa de Clique (CTR), Tempo Médio de Leitura.

**Motivação**: Medir efetividade das comunicações, identificar canais com melhor engajamento, detectar problemas de entrega (taxas baixas indicam configuração incorreta ou spam filtering), permitir otimizações baseadas em dados.

**Impacto**: Adicionar campos `DataEntrega`, `DataAbertura`, `DataClique`, `AcaoExecutada` na tabela Notificacoes. Implementar endpoints de webhook `/api/webhooks/twilio` e `/api/webhooks/sendgrid` para receber callbacks. Frontend exibe métricas em dashboard com gráficos.

### RN-NOT-066-10: Notificações Obrigatórias (Compliance)

**Descrição**: Alguns tipos de notificação são obrigatórios por questões de compliance regulatório ou segurança e não podem ser desabilitados pelo usuário nas preferências. Tipos obrigatórios incluem: Alteração de Senha (segurança), Acesso de IP Novo (segurança), Tentativas de Login Falhadas (segurança), Comunicações Legais (compliance), Manutenção Programada Crítica (operacional). Usuário pode escolher canais para receber notificações obrigatórias mas não pode desabilitá-las completamente (pelo menos 1 canal deve estar habilitado). Sistema valida ao salvar preferências e exibe mensagem clara: "Esta notificação é obrigatória e não pode ser desabilitada".

**Motivação**: Garantir conformidade com requisitos regulatórios e de segurança, assegurar que usuários sejam informados de eventos críticos mesmo se tentarem desabilitar todas as notificações.

**Impacto**: Adicionar flag `Obrigatoria` em tipo de notificação. Lógica de validação de preferências deve verificar que tipos obrigatórios têm pelo menos 1 canal habilitado. Frontend desabilita checkbox "Desabilitar todas" para tipos obrigatórios.

### RN-NOT-066-11: Digest Diário Opcional

**Descrição**: Usuários podem optar por receber resumo diário consolidado (digest) ao invés de notificações imediatas para tipos específicos. Digest é enviado diariamente às 18h via e-mail contendo todas as notificações do dia agrupadas por tipo. Usuário configura quais tipos deseja incluir no digest nas preferências (ex: incluir "Novas Solicitações" no digest mas receber "Aprovações Pendentes" imediatamente). Notificações com prioridade Alta/Urgente/Crítica nunca aguardam digest e são sempre enviadas imediatamente. Job Hangfire recorrente executa diariamente às 18h, consulta usuários com digest habilitado, renderiza template de e-mail consolidado e envia.

**Motivação**: Reduzir interrupções para usuários que preferem processar notificações em batch ao final do dia ao invés de receber alertas constantes, mantendo caixa de entrada organizada.

**Impacto**: Adicionar flag `DigestDiario` e `HorarioDigest` (padrão 18h) em preferências. Job diário consulta notificações pendentes de usuários com digest habilitado, agrupa por tipo, renderiza template HTML consolidado, envia e marca individuais como "Enviada via digest".

### RN-NOT-066-12: Ações Rápidas em Notificações

**Descrição**: Notificações podem conter botões de ação rápida que permitem ao usuário executar operações diretamente na notificação sem navegar para tela específica. Ações suportadas: Aprovar (aprovar solicitação/aprovação), Rejeitar (rejeitar solicitação/aprovação), Ver Detalhes (navegar para tela da entidade), Responder (abrir modal de resposta), Arquivar (arquivar notificação), Adiar (adiar notificação para notificar novamente em X horas). Cada tipo de notificação define quais ações são aplicáveis. Ao clicar em ação, sistema executa operação via API (ex: chama endpoint de aprovação), exibe confirmação, marca notificação como "Ação Executada" e remove da lista de pendentes.

**Motivação**: Aumentar produtividade permitindo que usuários executem ações comuns (aprovar, rejeitar) diretamente da central de notificações sem precisar abrir múltiplas telas, reduzindo cliques e tempo de resposta.

**Impacto**: Adicionar campo `AcoesDisponiveis` (array de strings) em notificação. Frontend renderiza botões dinamicamente conforme ações definidas. Backend expõe endpoints de ação (ex: `POST /api/notificacoes/{id}/executar-acao`).

### RN-NOT-066-13: Expiração Automática de Notificações Antigas

**Descrição**: Notificações são automaticamente arquivadas (movidas para tabela de arquivo frio ou marcadas com flag `Arquivada = true`) baseado em regras de retenção: Notificações lidas são arquivadas após 30 dias da data de leitura, Notificações não lidas são arquivadas após 90 dias da data de criação. Job Hangfire recorrente semanal (domingos às 2h) identifica notificações elegíveis para arquivamento e move para arquivo. Notificações arquivadas não aparecem em consultas padrão da central de notificações mas podem ser acessadas em tela "Notificações Arquivadas" se necessário. Arquivamento melhora performance de queries mantendo tabela ativa enxuta.

**Motivação**: Manter performance de consultas alta com tabela de notificações ativas pequena, preservar histórico completo em arquivo frio para auditoria, organizar central de notificações removendo itens muito antigos automaticamente.

**Impacto**: Job semanal executa queries de arquivamento: `UPDATE Notificacoes SET Arquivada = true WHERE Lida = true AND DataLeitura < DateTime.UtcNow.AddDays(-30)` e `UPDATE Notificacoes SET Arquivada = true WHERE Lida = false AND DataCriacao < DateTime.UtcNow.AddDays(-90)`. Consultas padrão incluem filtro `WHERE Arquivada = false`.

### RN-NOT-066-14: Rate Limiting Anti-Spam

**Descrição**: Sistema aplica rate limiting para prevenir spam e sobrecarga de notificações: Máximo de 50 notificações por usuário por período de 24 horas (configurável via parâmetro do sistema). Quando limite é atingido, notificações de prioridade Baixa e Normal são descartadas e não enviadas. Notificações de prioridade Alta, Urgente ou Crítica ignoram rate limiting e são sempre enviadas (não contam para limite). Ao atingir limite, sistema envia alerta único para administradores: "Usuário X atingiu limite de 50 notificações em 24h". Contador é resetado após 24h da primeira notificação do período. Administradores podem ajustar limite por usuário individualmente se necessário.

**Motivação**: Proteger usuários contra spam causado por bugs, loops infinitos de eventos ou importações em lote mal configuradas, evitar sobrecarga de provedores de SMS/e-mail (custos), manter qualidade de serviço.

**Impacto**: Antes de enviar notificação, consultar contador de notificações nas últimas 24h: `SELECT COUNT(*) FROM Notificacoes WHERE UsuarioId = @userId AND DataCriacao > DateTime.UtcNow.AddHours(-24) AND Prioridade IN (Baixa, Normal)`. Se >= 50, descartar envio e logar evento de rate limiting.

### RN-NOT-066-15: Integração WhatsApp Business API

**Descrição**: Sistema deve integrar com WhatsApp Business API para envio de notificações transacionais via WhatsApp. Requisitos da API: Mensagens devem utilizar templates pré-aprovados pelo WhatsApp (processo de aprovação leva 24-48h), Número de telefone destinatário deve estar no formato internacional (+5511999999999), Suporte a placeholders dinâmicos em templates (ex: {1} = nome do usuário, {2} = número da solicitação), Webhooks de status (enviado, entregue, lido, falha) devem ser processados para rastreamento. Limitações: Custo por mensagem (0,05-0,10 BRL/msg dependendo do país), Janela de 24h para respostas (notificações transacionais podem ser enviadas a qualquer momento, mas conversas só podem continuar por 24h após última interação do usuário).

**Motivação**: Oferecer canal de alta taxa de abertura (98% de mensagens WhatsApp são abertas vs 20% de e-mails) especialmente em contexto mobile, alcançar usuários que preferem WhatsApp como canal primário de comunicação.

**Impacto**: Integrar SDK oficial da WhatsApp Business API, gerenciar templates aprovados, implementar webhooks de status, adicionar validação de formato de telefone internacional, monitorar custos de envio por relatório mensal.

---

**Nota**: Documento RF066 v2.0 contém apenas primeiras 3 seções (Visão Geral, Funcionalidades, Regras de Negócio) em formato de linguagem natural sem código. Seções 4-11 (Integrações Obrigatórias, Permissões RBAC, API Endpoints, Modelo de Dados, Dependências, KPIs, Alertas, Central de Funcionalidades) podem ser expandidas posteriormente se necessário.

---

**FIM DO DOCUMENTO RF066 v2.0 (Preview - Seções 1-3)**
