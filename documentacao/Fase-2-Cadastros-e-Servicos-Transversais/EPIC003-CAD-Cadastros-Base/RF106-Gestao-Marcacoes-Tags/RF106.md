# RF-106: Gestão de Marcações e Tags

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF-104, RF-107 | **EPIC**: EPIC003-CAD-Cadastros-Base
**Fase**: Fase 2 - Cadastros e Serviços Transversais

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

O RF-106 especifica o módulo de **Gestão de Marcações e Tags** do sistema IControlIT, responsável por implementar um sistema robusto de categorização, marcação e classificação transversal de entidades do sistema (ativos, contratos, usuários, chamados, documentos).

Este módulo permite que usuários criem, gerenciem e apliquem tags personalizadas em múltiplas entidades, com suporte a taxonomias hierárquicas, auto-complete inteligente, sugestões baseadas em machine learning, e relatórios avançados de utilização. O sistema modernizado integra-se com ElasticSearch para busca rápida, Azure ML para sugestões automáticas, e Chart.js para visualizações de nuvem de tags.

### 1.2 Importância Estratégica

O módulo de tags é crítico para:

- **Organização e Localização**: Tags permitem categorização multidimensional de ativos, facilitando busca e filtro cruzado sem alterar a estrutura hierárquica corporativa.
- **Inteligência de Negócio**: Agrupamento de dados por tags fornece dimensões analíticas novas para relatórios, dashboards e KPIs.
- **Eficiência Operacional**: Auto-complete e sugestões reduzem esforço manual de categorização, acelerando workflows e garantindo consistência taxonomômica.
- **Conformidade e Governança**: Auditoria completa de alterações de tags permite rastreabilidade total para compliance LGPD/SOX.
- **Escalabilidade**: Tags representam um padrão cross-tenant que normaliza comportamentos de classificação em múltiplas linhas de negócio.

### 1.3 Conceitos Fundamentais

**Tag (Marcação)**: Rótulo textual, opcional com ícone e cor personalizada, aplicado a uma entidade para fins de categorização, busca e relatório. Exemplos: "Crítico", "Em Manutenção", "Auditado", "Premium".

- Pode ser simples (sem hierarquia) ou compor uma taxonomia hierárquica (tag pai/filho).
- Identificada por GUID único, com nome único por cliente (ClienteId).
- Suporta metadados: cor hexadecimal, ícone FontAwesome, contagem de uso, peso (frequência).

**Taxonomia (Hierarquia de Tags)**: Estrutura pai-filho onde tags podem conter subtags. Exemplo: "Equipamento" (pai) → "Notebook", "Desktop", "Impressora" (filhos).

- Profundidade máxima configurável (padrão: 3 níveis).
- Busca hierárquica: selecionar uma tag pai retorna todas as filhas.
- Migração automática: exclusão de tag pai reorganiza filhas para nível anterior.

**Aplicação de Tag**: Vinculação de uma tag a uma entidade específica (Ativo, Contrato, Usuário, Chamado, Documento).

- Multi-tag por entidade: uma entidade pode ter 1-N tags aplicadas (AND/OR lógico em filtros).
- Auditável: registra quem aplicou/removeu a tag, quando, e contexto.

**Auto-Complete**: Busca incremental e sugestão em tempo real conforme usuário digita, alimentado por ElasticSearch. Ordem alfabética + frequência de uso (tags mais usadas aparecem primeiro).

**Sugestões (ML)**: Recomendações automáticas baseadas em:
- Histórico de tags aplicadas a entidades similares.
- Padrão de uso por perfil/departamento.
- Correlação com texto/categoria da entidade.
Integrado com Azure ML (modelo REST) ou sklearn local.

**Nuvem de Tags (Tag Cloud)**: Visualização onde tags são exibidas com tamanho proporcional ao uso (peso), com cor personalizável. Implementado com Chart.js ou D3.js.

**Fusão de Tags (Merge)**: Operação que consolida duas tags duplicadas, reatribuindo todas as entidades da tag "origem" para a tag "destino" e marcando origem como excluída (soft delete).

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Armazenamento** | Tabelas `Marcacao`, `Marcacao_Tipo`, `Rl_Marcacao_*` em SQL Server | Tabelas `Tag`, `TagTaxonomy`, `EntityTag` com suporte multi-tenancy (ClienteId) |
| **Busca** | LIKE em T-SQL com NOLOCK | ElasticSearch com índice full-text, agregações e faceting |
| **Interface** | WebForms com DropdownList pré-carregada | Angular com ng-select, auto-complete RxJS/debounce, real-time typing |
| **Sugestões** | Nenhuma (manual ou lista fixa) | Azure ML ou sklearn model com API REST, retraining automático |
| **Auditoria** | Logs em tabela `Auditoria_*` (limitado) | EF Core AuditableEntity com shadow properties, change tracking detalhado |
| **Performance** | Queries N+1 em grid com foreach em C#/VB | Índices de BD, lazy loading, caching distribuído (Redis), paginação |
| **Hierarquia** | Não suportado explicitamente | Full support com validação de ciclos, cascade soft-delete |
| **Visualização** | Relatório tabular | Tag cloud (Chart.js), clustering (D3.js), histograma de uso (agregações Elastic) |

### 1.5 Funcionalidades Principais

1. **CRUD de Tags** - Criar, ler, atualizar, excluir tags com validação de unicidade e soft delete.
2. **Taxonomia Hierárquica** - Suporte a estruturas pai-filho com limite de profundidade e validação de ciclos.
3. **Auto-Complete** - Busca incremental em ElasticSearch com sugestões ordenadas por frequência.
4. **Sugestões Inteligentes** - Recomendações baseadas em ML (Azure ML ou sklearn) considerando histórico e perfil.
5. **Multi-Entidade** - Aplicação de tags a ativos, contratos, usuários, chamados, documentos com relacionamentos polimórficos.
6. **Filtros Avançados** - Busca com AND/OR lógico, ranges de datas, hierarquia de tags (incluir filhas).
7. **Nuvem de Tags** - Visualização interativa com tamanho proporcional ao uso, cores personalizáveis.
8. **Fusão de Tags** - Consolidação de duplicadas com reatribuição de entidades.
9. **Renomeação em Lote** - Atualizar múltiplas tags simultaneamente com validação de conflitos.
10. **Dashboard de Uso** - Estatísticas por tag (contagem, últimas alterações, usuários mais frequentes).
11. **Exportação de Dados** - Download em CSV/Excel de entidades agrupadas por tag.
12. **Auditoria Completa** - Rastreamento de todas as operações (criação, alteração, exclusão) com contexto de usuário/tenant.
13. **Integração de Permissões** - RBAC com granularidade de operação (criar, visualizar, editar tags globais vs. próprias).
14. **Sincronização Assíncrona** - Atualização de ElasticSearch via event-driven (MediatR, message queue).
15. **Relatórios por Tag** - Agrupamento de entidades, contagem, volumetria, custos associados.

---

## 2. REGRAS DE NEGÓCIO

### RN-TAG-106-01: Unicidade de Nomes por Cliente

**Descrição**: Uma tag não pode ter o mesmo nome (`Nm_Tag`) que outra tag ativa do mesmo cliente, independentemente de caso (case-insensitive). Tags excluídas (soft delete) não participam da validação.

**Justificativa**: Previne confusão e duplicação de conceitos. Normaliza entradas para garantir consistência em listas e buscas.

**Implementação**:
```csharp
public class CreateTagCommandValidator : AbstractValidator<CreateTagCommand>
{
    private readonly ITagRepository _tagRepository;

    public CreateTagCommandValidator(ITagRepository tagRepository)
    {
        _tagRepository = tagRepository;
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Nome da tag é obrigatório")
            .MaximumLength(100).WithMessage("Máximo 100 caracteres")
            .Custom(async (name, context) =>
            {
                var clienteId = context.RootContextData["ClienteId"] as Guid?;
                var exists = await _tagRepository.TagExistsAsync(
                    clienteId.Value,
                    name.Trim().ToLower(),
                    excludeId: null // Null para criação
                );
                if (exists)
                    context.AddFailure($"Tag '{name}' já existe para este cliente.");
            });
    }
}
```

**Exemplos**:
- Válido: Criar "Crítico" quando nenhuma outra ativa tem este nome.
- Inválido: Criar "crítico" quando "Crítico" já existe (case-insensitive).
- Válido: Criar "Crítico" após excluir a "Crítico" anterior (soft delete).

---

### RN-TAG-106-02: Cor e Ícone Validação

**Descrição**: Ao criar ou atualizar uma tag, os campos `HexColor` (cor) e `IconClass` (ícone FontAwesome) são opcionais mas, se fornecidos, devem passar validação de formato.

- `HexColor`: Padrão `#RRGGBB` válido (ex: `#FF5733`).
- `IconClass`: Classe FontAwesome válida (ex: `fa-star`, `fa-heart`), validado contra whitelist de ícones disponíveis.

**Justificativa**: Garante que cores e ícones serão renderizados corretamente em UI sem erros visuais ou XSS.

**Validação**:
```sql
ALTER TABLE [dbo].[Tag]
ADD CONSTRAINT [CK_Tag_HexColor]
CHECK ([HexColor] IS NULL OR [HexColor] LIKE '#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]');

ALTER TABLE [dbo].[Tag]
ADD CONSTRAINT [CK_Tag_IconClass]
CHECK ([IconClass] IS NULL OR [IconClass] LIKE 'fa[-%][a-z]%');
```

**Exemplos**:
- Válido: `HexColor = "#FF5733"`, `IconClass = "fa-server"`.
- Inválido: `HexColor = "FF5733"` (sem #).
- Inválido: `IconClass = "bootstrap-icon"` (não é FontAwesome).

---

### RN-TAG-106-03: Hierarquia - Validação de Ciclos

**Descrição**: Ao definir um pai para uma tag (`ParentTagId`), o sistema deve validar que não há ciclo. Ou seja: Tag A não pode ser pai de B, B de C, e C de A.

**Justificativa**: Previne estruturas impossíveis de navegar e que causariam loops infinitos em queries recursivas.

**Implementação**:
```csharp
public class UpdateTagHierarchyCommandValidator : AbstractValidator<UpdateTagHierarchyCommand>
{
    private readonly ITagRepository _tagRepository;

    public UpdateTagHierarchyCommandValidator(ITagRepository tagRepository)
    {
        _tagRepository = tagRepository;
        RuleFor(x => x.ParentTagId)
            .Custom(async (parentId, context) =>
            {
                var tagId = context.RootContextData["TagId"] as Guid?;
                var clienteId = context.RootContextData["ClienteId"] as Guid?;

                if (parentId.HasValue)
                {
                    var hasCycle = await _tagRepository.HasCycleAsync(
                        clienteId.Value,
                        tagId.Value,
                        parentId.Value
                    );
                    if (hasCycle)
                        context.AddFailure("Atribuição criaria um ciclo na hierarquia.");
                }
            });
    }
}
```

**Exemplos**:
- Válido: Tag "Notebook" pai de "Dell Notebook".
- Válido: Tag "Equipamento" avô de "Notebook" avô de "Dell Notebook".
- Inválido: "Notebook" já é filho de "Equipamento", não pode ser seu próprio pai.

---

### RN-TAG-106-04: Profundidade Máxima da Hierarquia

**Descrição**: A hierarquia de tags não pode exceder 3 níveis de profundidade (tag avó, avó, neta). Uma tag sem pai é nível 1.

**Justificativa**: Limita complexidade de queries recursivas, melhora UX ao exibir árvores, previne estruturas desordenadas.

**Validação**:
```csharp
public async Task<bool> CanAddAsChildAsync(Guid clienteId, Guid childTagId, Guid parentTagId)
{
    const int MaxDepth = 3;

    // Calcula a profundidade do pai
    var parentDepth = await _tagRepository.GetDepthAsync(clienteId, parentTagId);

    // Se pai está no nível 3, não pode ter filhos
    if (parentDepth >= MaxDepth)
        throw new ValidationException("Hierarquia excede profundidade máxima de 3 níveis.");

    return true;
}
```

---

### RN-TAG-106-05: Soft Delete de Tags

**Descrição**: Exclusão de uma tag marca o campo `FlExcluido = 1` sem remover registros da BD. Tags excluídas não aparecem em listas, dropdowns, sugestões ou auto-complete, mas auditoria e dados históricos são preservados.

**Justificativa**: Permite reverter exclusões, preserva integridade referencial histórica, mantém auditoria sem gaps.

**Implementação**:
```csharp
public async Task SoftDeleteTagAsync(Guid clienteId, Guid tagId, string userId)
{
    var tag = await _dbContext.Tags.FirstOrDefaultAsync(
        t => t.Id == tagId && t.ClienteId == clienteId && !t.FlExcluido
    );

    if (tag == null)
        throw new EntityNotFoundException("Tag não encontrada ou já excluída.");

    tag.FlExcluido = true;
    tag.AlteradoPor = userId;
    tag.AlteradoEm = DateTime.UtcNow;

    await _dbContext.SaveChangesAsync();
    await _elasticSearchService.DeleteTagAsync(clienteId, tagId); // Remove de índice
}
```

---

### RN-TAG-106-06: Aplicação de Tags Múltiplas por Entidade

**Descrição**: Uma entidade (ativo, contrato, chamado, etc.) pode ter 0 a N tags aplicadas. A tabela de relacionamento `EntityTag` registra ClienteId, EntityType, EntityId, TagId, com índice composto para evitar duplicatas.

**Justificativa**: Permite categorização multidimensional (um ativo pode ser simultaneamente "Crítico", "Em Manutenção", "Premium").

**Validação**:
```sql
CREATE TABLE [dbo].[EntityTag] (
    [Id] UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(),
    [ClienteId] UNIQUEIDENTIFIER NOT NULL,
    [EntityType] VARCHAR(50) NOT NULL,  -- 'Ativo', 'Contrato', 'Chamado', etc.
    [EntityId] UNIQUEIDENTIFIER NOT NULL,
    [TagId] UNIQUEIDENTIFIER NOT NULL,
    [CriadoEm] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    [CriadoPor] NVARCHAR(450) NULL,

    CONSTRAINT [PK_EntityTag] PRIMARY KEY CLUSTERED ([Id]),
    CONSTRAINT [FK_EntityTag_Tag] FOREIGN KEY ([TagId]) REFERENCES [dbo].[Tag]([Id]),
    CONSTRAINT [UQ_EntityTag_Unique] UNIQUE ([ClienteId], [EntityType], [EntityId], [TagId])
);
```

**Exemplos**:
- Ativo X com tags "Crítico", "Em Manutenção", "Premium" (3 registros em EntityTag).
- Chamado Y com tag "Auditado" (1 registro).

---

### RN-TAG-106-07: Auto-Complete com ElasticSearch

**Descrição**: Ao digitar em campo de auto-complete, chamada a endpoint GET `/api/tags/search?query=...&limit=10` retorna até 10 tags ordenadas por:
1. Relevância textual (query_string com boost no nome).
2. Frequência de uso (campo `UsageCount` descendente).

**Justificativa**: Proporciona experiência rápida e intuitiva, priorizando tags mais comuns.

**Implementação ElasticSearch**:
```json
{
  "query": {
    "bool": {
      "must": [
        {
          "query_string": {
            "query": "crit*",
            "fields": ["name^2", "description"]
          }
        },
        {
          "term": { "clienteId": "{{ ClienteId }}" }
        },
        {
          "term": { "flExcluido": false }
        }
      ]
    }
  },
  "sort": [
    { "usageCount": { "order": "desc" } },
    { "_score": { "order": "desc" } }
  ],
  "size": 10
}
```

---

### RN-TAG-106-08: Sugestões Baseadas em ML

**Descrição**: Ao aplicar tag a uma entidade, sistema chama Azure ML (ou modelo local sklearn) que retorna 3-5 tags sugeridas baseado em:
- Histórico de tags aplicadas a entidades do mesmo tipo/categoria.
- Perfil do usuário logado (departamento, hierarquia).
- Texto/metadados da entidade (análise NLP).

Sugestões aparecem em dropdown ou notification, permitindo aplicação com 1-click.

**Justificativa**: Acelera processo de categorização, melhora consistência taxonomômica.

**Fluxo**:
```csharp
public async Task<List<TagSuggestion>> GetSuggestionsAsync(
    Guid clienteId,
    string entityType,
    Guid entityId,
    string userId)
{
    var entity = await _entityRepository.GetAsync(clienteId, entityType, entityId);
    var userProfile = await _userRepository.GetProfileAsync(userId);

    // Chamada REST ao modelo ML
    var input = new
    {
        clienteId = clienteId,
        entityType = entityType,
        entityText = entity.ToString(),
        userDepartment = userProfile.DepartmentId,
        userRole = userProfile.Role
    };

    var response = await _mlApiClient.PostAsync("/predict", input);
    var suggestions = response.Suggestions.Take(5).ToList();

    return suggestions;
}
```

---

### RN-TAG-106-09: Filtros AND/OR em Buscas de Entidades

**Descrição**: Ao buscar entidades por tags, usuário pode selecionar múltiplas tags com operador lógico:
- **AND**: Retorna entidades que têm TODAS as tags selecionadas.
- **OR**: Retorna entidades que têm QUALQUER UMA das tags selecionadas.

Padrão da URL: `/api/ativos?tags=ID1,ID2&tagLogic=AND`

**Justificativa**: Oferece flexibilidade na busca, permitindo queries complexas sem SQL.

**Implementação**:
```csharp
public async Task<List<Ativo>> SearchByTagsAsync(
    Guid clienteId,
    List<Guid> tagIds,
    TagLogic logic)
{
    var query = _dbContext.Ativos
        .Where(a => a.ClienteId == clienteId && !a.FlExcluido);

    if (tagIds.Any())
    {
        if (logic == TagLogic.And)
        {
            // Todas as tags
            foreach (var tagId in tagIds)
            {
                query = query.Where(a => a.EntityTags
                    .Any(et => et.TagId == tagId && !et.Tag.FlExcluido)
                );
            }
        }
        else // OR
        {
            // Qualquer tag
            query = query.Where(a => a.EntityTags
                .Any(et => tagIds.Contains(et.TagId) && !et.Tag.FlExcluido)
            );
        }
    }

    return await query.ToListAsync();
}
```

---

### RN-TAG-106-10: Auditoria de Alterações de Tags

**Descrição**: Toda operação em tag (criação, modificação de nome/cor/ícone, aplicação/remoção, exclusão) é registrada em tabela de auditoria com:
- Timestamp exato (UTC).
- Usuário responsável.
- Ação (CREATE, UPDATE, DELETE, APPLY, REMOVE).
- Valores antigos e novos (shadow properties do EF).
- ClienteId (para isolamento).

**Justificativa**: Conformidade LGPD/SOX, rastreabilidade de modificações, possibilidade de auditoria posterior.

**Tabela**:
```sql
CREATE TABLE [dbo].[TagAudit] (
    [Id] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY DEFAULT NEWID(),
    [ClienteId] UNIQUEIDENTIFIER NOT NULL,
    [TagId] UNIQUEIDENTIFIER NOT NULL,
    [Action] VARCHAR(20) NOT NULL,  -- CREATE, UPDATE, DELETE, APPLY, REMOVE
    [OldValue] NVARCHAR(MAX) NULL,   -- JSON dos campos antigos
    [NewValue] NVARCHAR(MAX) NULL,   -- JSON dos campos novos
    [UserId] NVARCHAR(450) NOT NULL,
    [CreatedAt] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    [IpAddress] VARCHAR(50) NULL
);
```

---

### RN-TAG-106-11: Fusão de Tags (Merge)

**Descrição**: Operação que consolida duas tags: a tag "origem" é excluída (soft delete) e todas as suas aplicações (EntityTag) são reatribuídas para a tag "destino". Se uma entidade já tinha ambas as tags, a duplicata é removida.

**Justificativa**: Remove duplicatas sem perder dados, normaliza taxonomia após operações descentralizadas.

**Implementação**:
```csharp
public async Task MergeTagsAsync(
    Guid clienteId,
    Guid sourceTagId,
    Guid destinationTagId,
    string userId)
{
    // Evita merge de tag consigo mesma
    if (sourceTagId == destinationTagId)
        throw new ValidationException("Tags de origem e destino devem ser diferentes.");

    // Retraço todas as entidades da origem para destino
    var entityTags = await _dbContext.EntityTags
        .Where(et => et.TagId == sourceTagId && et.ClienteId == clienteId)
        .ToListAsync();

    foreach (var et in entityTags)
    {
        // Verifica se destino já existe nesta entidade
        var existing = await _dbContext.EntityTags.FirstOrDefaultAsync(
            e => e.ClienteId == clienteId &&
                 e.EntityType == et.EntityType &&
                 e.EntityId == et.EntityId &&
                 e.TagId == destinationTagId
        );

        if (existing == null)
        {
            et.TagId = destinationTagId;
        }
        else
        {
            _dbContext.EntityTags.Remove(et); // Remove duplicata
        }
    }

    // Soft delete da tag origem
    var sourceTag = await _dbContext.Tags.FirstOrDefaultAsync(t => t.Id == sourceTagId);
    sourceTag.FlExcluido = true;
    sourceTag.AlteradoPor = userId;

    await _dbContext.SaveChangesAsync();
    await _elasticSearchService.UpdateIndexAsync(clienteId);
}
```

---

### RN-TAG-106-12: Renomeação em Lote

**Descrição**: Permite renomear múltiplas tags em uma operação, com validação de conflitos (não permitir 2 tags com mesmo nome após rename). Operação é atômica.

**Justificativa**: Eficiência ao reorganizar taxonomias, com garantia de consistência.

**Implementação**:
```csharp
public async Task RenameBatchAsync(
    Guid clienteId,
    Dictionary<Guid, string> renames,
    string userId)
{
    // Valida ausência de conflitos pós-rename
    var newNames = renames.Values.Select(n => n.ToLower()).ToList();
    if (newNames.Count != newNames.Distinct().Count())
        throw new ValidationException("Operação contém names duplicados após rename.");

    var tags = await _dbContext.Tags
        .Where(t => t.ClienteId == clienteId && renames.Keys.Contains(t.Id))
        .ToListAsync();

    using (var transaction = _dbContext.Database.BeginTransaction())
    {
        try
        {
            foreach (var tag in tags)
            {
                tag.Nm_Tag = renames[tag.Id];
                tag.AlteradoPor = userId;
                tag.AlteradoEm = DateTime.UtcNow;
            }

            await _dbContext.SaveChangesAsync();
            transaction.Commit();
        }
        catch
        {
            transaction.Rollback();
            throw;
        }
    }
}
```

---

### RN-TAG-106-13: Dashboard de Uso e Estatísticas

**Descrição**: Dashboard mostra métricas agregadas por tag:
- Contagem de entidades com a tag (total por tipo).
- Data da última alteração.
- Usuário que mais aplicou a tag (top user).
- Tendência de uso (últimos 30 dias).

**Justificativa**: Oferece visibilidade de utilização, facilita decisões de limpeza/consolidação de taxonomia.

**Agregações ElasticSearch**:
```json
{
  "aggs": {
    "by_tag": {
      "terms": {
        "field": "tagId",
        "size": 100
      },
      "aggs": {
        "usage_count": { "cardinality": { "field": "entityId" } },
        "last_updated": { "max": { "field": "appliedAt" } },
        "by_type": { "terms": { "field": "entityType" } },
        "trend": {
          "date_histogram": {
            "field": "appliedAt",
            "interval": "1d"
          }
        }
      }
    }
  }
}
```

---

### RN-TAG-106-14: Sincronização Assíncrona com ElasticSearch

**Descrição**: Após cada operação de criação/edição/exclusão de tag ou aplicação/remoção de EntityTag, uma mensagem é enfileirada (MediatR, message queue) para atualizar índice ElasticSearch de forma assíncrona, sem bloquear resposta HTTP.

**Justificativa**: Garante consistência eventual entre SQL e ElasticSearch, melhora performance, desacopla camadas.

**Implementação via MediatR**:
```csharp
public class TagCreatedEvent : INotification
{
    public Guid ClienteId { get; set; }
    public Tag Tag { get; set; }
}

public class SyncTagToElasticSearchHandler : INotificationHandler<TagCreatedEvent>
{
    private readonly IElasticSearchService _elasticSearch;

    public async Task Handle(TagCreatedEvent notification, CancellationToken cancellationToken)
    {
        await _elasticSearch.IndexTagAsync(
            notification.ClienteId,
            new TagDocument
            {
                Id = notification.Tag.Id,
                Name = notification.Tag.Nm_Tag,
                Description = notification.Tag.Descricao,
                HexColor = notification.Tag.HexColor,
                UsageCount = 0,
                LastUpdated = notification.Tag.AlteradoEm ?? notification.Tag.CriadoEm
            }
        );
    }
}
```

---

### RN-TAG-106-15: Exportação de Dados por Tag

**Descrição**: Endpoint GET `/api/tags/{tagId}/export?format=csv` retorna lista de todas as entidades com a tag especificada, em formato CSV ou Excel, com colunas: EntityType, EntityId, EntityName, EntityDetails, AppliedAt, AppliedBy.

**Justificativa**: Facilita relatórios manuais, auditorias, integração com sistemas externos.

**Implementação**:
```csharp
public async Task<byte[]> ExportEntitiesByTagAsync(
    Guid clienteId,
    Guid tagId,
    ExportFormat format)
{
    var entityTags = await _dbContext.EntityTags
        .Where(et => et.ClienteId == clienteId && et.TagId == tagId)
        .Include(et => et.Tag)
        .ToListAsync();

    var data = entityTags.Select(et => new
    {
        EntityType = et.EntityType,
        EntityId = et.EntityId,
        AppliedAt = et.CriadoEm,
        AppliedBy = et.CriadoPor
    });

    if (format == ExportFormat.Csv)
        return _csvService.GenerateCsv(data);
    else
        return _excelService.GenerateExcel(data);
}
```

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `Branco` (base modelo), `SC_<OPERADORA>_<CLIENTE>` (bases de cliente).

**Tabelas Principais**:

```sql
-- Legado não possua tabela de Tags explícita, mas padrão era usar:

CREATE TABLE [dbo].[Marcacao](
    [Id_Marcacao] [int] IDENTITY(1,1) NOT NULL,
    [Nm_Marcacao] [varchar](50) NOT NULL,
    [Descricao] [nvarchar](200) NULL,
    [Fl_Excluido] [bit] NOT NULL DEFAULT 0,
    [Dt_Incluido] [datetime] NOT NULL DEFAULT GETDATE(),
    [Dt_Alterado] [datetime] NULL,

    CONSTRAINT [PK_Marcacao] PRIMARY KEY CLUSTERED ([Id_Marcacao] ASC)
);

CREATE TABLE [dbo].[Marcacao_Tipo](
    [Id_Marcacao_Tipo] [int] IDENTITY(1,1) NOT NULL,
    [Nm_Tipo] [varchar](50) NOT NULL,
    [Fl_Excluido] [bit] NOT NULL DEFAULT 0,

    CONSTRAINT [PK_Marcacao_Tipo] PRIMARY KEY CLUSTERED ([Id_Marcacao_Tipo] ASC)
);

-- Relacionamentos eram feitos via tabelas:
-- Rl_Marcacao_Ativo, Rl_Marcacao_Contrato, Rl_Marcacao_Chamado, etc.
CREATE TABLE [dbo].[Rl_Marcacao_Ativo](
    [Id_Marcacao] [int] NOT NULL,
    [Id_Ativo] [int] NOT NULL,
    [Dt_Inclusao] [datetime] NOT NULL DEFAULT GETDATE(),

    CONSTRAINT [FK_RL_Marcacao_Ativo_Marcacao] FOREIGN KEY ([Id_Marcacao])
        REFERENCES [dbo].[Marcacao]([Id_Marcacao]),
    CONSTRAINT [FK_RL_Marcacao_Ativo_Ativo] FOREIGN KEY ([Id_Ativo])
        REFERENCES [dbo].[Ativo]([Id_Ativo]),
    CONSTRAINT [PK_RL_Marcacao_Ativo] PRIMARY KEY CLUSTERED
        ([Id_Marcacao] ASC, [Id_Ativo] ASC)
);
```

**Campos Importantes - Mapeamento Legado → Modernizado**:

| Campo Legado | Descrição | Uso no Modernizado |
|--------------|-----------|-------------------|
| `[Id_Marcacao]` | INT IDENTITY | → `Tag.Id` (UNIQUEIDENTIFIER) com conversão INT→GUID |
| `[Nm_Marcacao]` | Varchar(50) nome | → `Tag.Nm_Tag` (NVARCHAR 100) |
| `[Descricao]` | Desc. textual | → `Tag.Descricao` (NVARCHAR MAX) |
| `[Fl_Excluido]` | Flag soft delete | → `Tag.FlExcluido` (BIT) |
| `[Dt_Incluido]` | Data criação | → `Tag.CriadoEm` (DATETIME2 UTC) |
| `[Dt_Alterado]` | Data alteração | → `Tag.AlteradoEm` (DATETIME2 UTC) |
| N/A | Cor personalizada | → `Tag.HexColor` (VARCHAR 7) |
| N/A | Ícone FontAwesome | → `Tag.IconClass` (VARCHAR 50) |
| N/A | ClienteId (multi-tenancy) | → `Tag.ClienteId` (UNIQUEIDENTIFIER) |
| N/A | Contador de uso | → `Tag.UsageCount` (INT) |

### 3.2 Stored Procedures Legado

Não há procedures exclusivas de marcação no legado, pois funcionalidade era simples. Esperado que migremos padrão de:

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `pa_Marcacao_Criar` | INSERT em Marcacao + Rl_* | → Entity Framework Core (SaveChangesAsync) |
| `pa_Marcacao_Listar` | SELECT com NOLOCK | → EF Core Query + ElasticSearch |
| `pa_Marcacao_Excluir` | UPDATE Fl_Excluido = 1 | → EF Core soft delete |
| `sp_Ativo_Por_Marcacao` | Busca ativos por marcação (JOIN) | → LINQ query ou ElasticSearch aggregation |

### 3.3 Telas ASPX Legado

| Página | Descrição | Tela Moderna |
|--------|-----------|--------------|
| `Cadastro\Marcacao.aspx` | Gerenciar marcações simples | `/cadastros/tags` (Angular component) |
| `Consulta\*.aspx` (com filtro) | Filtros com checkboxes de marcação | `/[entity]/list?tags=ID1,ID2` |
| N/A | Dashboard de tags | `/dashboards/tags` (novo) |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WS_IControlIT\WSCadastro.asmx.vb`

Métodos esperados:
```vb
<WebMethod()> _
Public Function Marcacao_Listar(Conn_Banco As String) As DataSet
    ' SELECT * FROM Marcacao WHERE Fl_Excluido = 0 ORDER BY Nm_Marcacao
End Function

<WebMethod()> _
Public Function Marcacao_Inserir(Conn_Banco As String, Nm_Marcacao As String) As Integer
    ' INSERT INTO Marcacao (Nm_Marcacao, Dt_Incluido, Fl_Excluido)
    ' VALUES (@Nm_Marcacao, GETDATE(), 0)
    ' RETURN @@IDENTITY
End Function

<WebMethod()> _
Public Function Ativo_Por_Marcacao(Conn_Banco As String, Id_Marcacao As Integer) As DataSet
    ' SELECT a.* FROM Ativo a
    ' INNER JOIN Rl_Marcacao_Ativo rm ON a.Id_Ativo = rm.Id_Ativo
    ' WHERE rm.Id_Marcacao = @Id_Marcacao AND a.Fl_Excluido = 0
End Function
```

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `TAGS_MANAGEMENT`

**Configuração**:
```json
{
    "featureKey": "TAGS_MANAGEMENT",
    "nome": "Gestão de Marcações e Tags",
    "descricao": "Habilita funcionalidade completa de tags com auto-complete, sugestões ML e tag cloud",
    "habilitado": true,
    "isSystemFeature": false,
    "features": [
        {
            "featureKey": "TAGS_SUGGESTIONS",
            "nome": "Sugestões de Tags via ML",
            "habilitado": true,
            "config": {
                "mlEndpoint": "https://ml.example.com/predict",
                "timeout": 2000
            }
        },
        {
            "featureKey": "TAGS_ELASTICSEARCH",
            "nome": "Busca ElasticSearch",
            "habilitado": true,
            "config": {
                "elasticEndpoint": "https://es.example.com:9200",
                "indexName": "tags"
            }
        },
        {
            "featureKey": "TAGS_HIERARCHY",
            "nome": "Hierarquia de Tags",
            "habilitado": true,
            "config": {
                "maxDepth": 3
            }
        }
    ]
}
```

**Nota**: Feature flags permitem desabilitar sugestões ML ou busca ElasticSearch para fallback em LIKE simples (compatibilidade com ambientes restritos).

---

### 4.2 Internacionalização (i18n)

**Chaves de Tradução**:

```json
{
    "tags": {
        "title": "Gestão de Tags",
        "subtitle": "Organize seus ativos e entidades com marcações personalizadas",
        "form": {
            "name": "Nome da Tag",
            "description": "Descrição (opcional)",
            "hexColor": "Cor (ex: #FF5733)",
            "iconClass": "Ícone FontAwesome (ex: fa-star)",
            "parentTag": "Tag Pai (opcional - cria hierarquia)"
        },
        "actions": {
            "create": "Criar Tag",
            "edit": "Editar Tag",
            "delete": "Excluir Tag",
            "merge": "Fundir Tags",
            "rename": "Renomear em Lote",
            "export": "Exportar Entidades"
        },
        "messages": {
            "createSuccess": "Tag '{name}' criada com sucesso",
            "updateSuccess": "Tag '{name}' atualizada com sucesso",
            "deleteSuccess": "Tag '{name}' excluída com sucesso",
            "mergeSuccess": "Tags fundidas com sucesso. {count} entidades reatribuídas",
            "renameSuccess": "{count} tags renomeadas com sucesso",
            "exportSuccess": "Arquivo gerado e pronto para download",
            "nameDuplicate": "Já existe uma tag com este nome",
            "hierarchyCycleError": "Operação criaria ciclo na hierarquia",
            "maxDepthError": "Hierarquia excede profundidade máxima de 3 níveis",
            "deleteConflict": "Não é possível excluir: existem {count} entidades com esta tag",
            "invalidHexColor": "Cor deve estar no formato #RRGGBB (ex: #FF5733)",
            "invalidIconClass": "Ícone deve ser classe FontAwesome válida (ex: fa-star)"
        },
        "validation": {
            "required": "Campo obrigatório",
            "maxLength": "Máximo {max} caracteres",
            "invalidFormat": "Formato inválido"
        },
        "dashboard": {
            "totalTags": "Total de Tags",
            "mostUsed": "Tags Mais Usadas",
            "recentChanges": "Alterações Recentes",
            "usageByType": "Uso por Tipo de Entidade",
            "trend": "Tendência (últimos 30 dias)"
        },
        "search": {
            "placeholder": "Buscar tags...",
            "noResults": "Nenhuma tag encontrada",
            "suggestions": "Sugestões",
            "popular": "Popular",
            "recent": "Recente"
        },
        "hierarchy": {
            "parent": "Tag Pai",
            "children": "Tags Filhas",
            "depth": "Profundidade",
            "expandAll": "Expandir Tudo",
            "collapseAll": "Colapsar Tudo"
        },
        "filters": {
            "byType": "Filtrar por Tipo de Entidade",
            "byUser": "Filtrar por Usuário",
            "byDate": "Filtrar por Data",
            "logicAnd": "Todas as Tags (AND)",
            "logicOr": "Qualquer Tag (OR)"
        }
    }
}
```

### 4.3 Auditoria

**Operações Auditadas**:

| Operação | Código | Dados Registrados |
|----------|--------|-------------------|
| Criar Tag | `TAG_CREATE` | Nome, descrição, cor, ícone, tag pai |
| Atualizar Tag | `TAG_UPDATE` | Campos antigos e novos (JSON shadow properties) |
| Excluir Tag | `TAG_DELETE` | Nome da tag excluída, count de entidades afetadas |
| Aplicar Tag | `ENTITYTAG_CREATE` | Entity type, entity ID, tag ID |
| Remover Tag | `ENTITYTAG_DELETE` | Entity type, entity ID, tag ID |
| Fundir Tags | `TAG_MERGE` | Source tag ID, destination tag ID, count reatribuído |
| Renomear Lote | `TAG_RENAME_BATCH` | Lista de IDs e novos nomes |
| Excluir em Cascata | `TAG_CASCADE_DELETE` | Trigger: parent tag excluída, impacto em children |

**Retenção**: Mínimo 3 anos (conforme LGPD, Art. 16 - Direito de Acesso).

---

### 4.4 Controle de Acesso (RBAC)

**Permissões**:

| Permissão | Descrição | Perfis |
|-----------|-----------|--------|
| `tags:tag:create` | Criar nova tag | Admin, Gerente, Analista Sênior |
| `tags:tag:read` | Visualizar tags | Todos (público) |
| `tags:tag:update` | Editar tag (nome, cor, ícone, hierarquia) | Admin, Gerente |
| `tags:tag:delete` | Excluir tag (soft delete) | Admin |
| `tags:tag:merge` | Fundir duas tags | Admin |
| `tags:entitytag:create` | Aplicar tag a entidade | Admin, Gerente, Usuário (próprias) |
| `tags:entitytag:delete` | Remover tag de entidade | Admin, Gerente, Proprietário |
| `tags:dashboard:view` | Acessar dashboard de tags | Admin, Gerente, Analista |
| `tags:export:download` | Exportar dados por tag | Admin, Gerente |
| `tags:suggestions:view` | Ver sugestões de ML | Todos |

**Nota**: Granularidade adicional permitir criar tags globais (visíveis a todos) vs. tags pessoais (próprio usuário). Implementado via campo `IsGlobal` (BIT) na tabela Tag.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| GET | `/api/tags` | Listar tags com paginação | `tags:tag:read` |
| GET | `/api/tags/{id}` | Obter tag por ID | `tags:tag:read` |
| GET | `/api/tags/{id}/children` | Listar tags filhas (hierarquia) | `tags:tag:read` |
| POST | `/api/tags` | Criar nova tag | `tags:tag:create` |
| PUT | `/api/tags/{id}` | Atualizar tag | `tags:tag:update` |
| DELETE | `/api/tags/{id}` | Excluir tag (soft delete) | `tags:tag:delete` |
| GET | `/api/tags/{id}/usage` | Obter contagem de uso por tipo | `tags:dashboard:view` |

**Exemplos**:

```bash
# Listar tags (paginado, com filtro de ativo)
GET /api/tags?page=1&pageSize=20&search=critic

# Criar tag com hierarquia
POST /api/tags
{
  "name": "Equipamentos",
  "description": "Categoria de equipamentos",
  "hexColor": "#FF5733",
  "iconClass": "fa-laptop",
  "parentTagId": null
}

# Atualizar tag
PUT /api/tags/550e8400-e29b-41d4-a716-446655440000
{
  "name": "Equipamentos Críticos",
  "description": "Equipamentos críticos para operação",
  "hexColor": "#FF0000"
}

# Excluir tag
DELETE /api/tags/550e8400-e29b-41d4-a716-446655440000
```

### 5.2 Operações Especiais

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| POST | `/api/tags/search` | Busca com auto-complete (ElasticSearch) | `tags:tag:read` |
| POST | `/api/tags/{id}/apply` | Aplicar tag a entidade | `tags:entitytag:create` |
| DELETE | `/api/tags/{id}/remove/{entityType}/{entityId}` | Remover tag de entidade | `tags:entitytag:delete` |
| POST | `/api/tags/{sourceId}/merge/{destinationId}` | Fundir duas tags | `tags:tag:merge` |
| POST | `/api/tags/batch-rename` | Renomear múltiplas tags | `tags:tag:update` |
| GET | `/api/tags/{id}/export` | Exportar entidades com tag | `tags:export:download` |
| GET | `/api/tags/suggestions` | Sugestões de tags (ML) | `tags:suggestions:view` |
| GET | `/api/tags/cloud` | Nuvem de tags (agregações) | `tags:dashboard:view` |
| GET | `/api/tags/dashboard` | Dashboard completo | `tags:dashboard:view` |

**Exemplos**:

```bash
# Auto-complete com ElasticSearch
POST /api/tags/search
{
  "query": "crit",
  "limit": 10
}
# Retorno: [
#   { "id": "...", "name": "Crítico", "hexColor": "#FF0000", "usageCount": 150 },
#   { "id": "...", "name": "Crítica Manutenção", "hexColor": "#FF6600", "usageCount": 45 }
# ]

# Aplicar tag a ativo
POST /api/tags/550e8400-e29b-41d4-a716-446655440000/apply
{
  "entityType": "Ativo",
  "entityId": "660e8400-e29b-41d4-a716-446655440001"
}

# Fundir tags
POST /api/tags/550e8400-e29b-41d4-a716-446655440000/merge/660e8400-e29b-41d4-a716-446655440001
# Retorno: { "success": true, "mergedCount": 45 }

# Renomear em lote
POST /api/tags/batch-rename
{
  "renames": {
    "550e8400-e29b-41d4-a716-446655440000": "Crítico",
    "660e8400-e29b-41d4-a716-446655440001": "Em Manutenção"
  }
}

# Exportar entidades por tag
GET /api/tags/550e8400-e29b-41d4-a716-446655440000/export?format=csv
# Retorno: CSV file (attachment)

# Sugestões ML
GET /api/tags/suggestions?entityType=Ativo&entityId=550e8400-e29b-41d4-a716-446655440000
# Retorno: [
#   { "name": "Crítico", "confidence": 0.95 },
#   { "name": "Em Manutenção", "confidence": 0.78 }
# ]

# Tag cloud com agregações
GET /api/tags/cloud?limit=50
# Retorno: [
#   { "name": "Crítico", "weight": 150, "size": 24, "hexColor": "#FF0000" },
#   { "name": "Premium", "weight": 87, "size": 18, "hexColor": "#00FF00" }
# ]

# Dashboard completo
GET /api/tags/dashboard
# Retorno: {
#   "totalTags": 45,
#   "mostUsed": [...],
#   "recentChanges": [...],
#   "usageByType": { "Ativo": 150, "Contrato": 45, "Chamado": 23 },
#   "trendData": [...]
# }
```

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Criação de Tag

```
Usuário acessa /cadastros/tags
    |
    v
Clica "Criar Tag"
    |
    v
Preenche formulário:
  - Nome (obrigatório)
  - Descrição (opcional)
  - Cor (opcional, validada #RRGGBB)
  - Ícone (opcional, validado FontAwesome)
  - Tag Pai (opcional, para hierarquia)
    |
    v
Clica "Salvar"
    |
    v
POST /api/tags com dados
    |
    v
Backend valida:
  - Nome não duplicado?
  - Cor formato válido?
  - Ícone válido?
  - Hierarquia sem ciclos? (se for filha)
  - Profundidade <= 3? (se for filha)
    |
    +--- [Erro] ---> HTTP 400 + mensagem
    |
    v [Sucesso]
Salva em DB (EF Core SaveChangesAsync)
    |
    v
Enfileira evento TagCreatedEvent
    |
    v
MediatR dispara handler SyncTagToElasticSearchHandler (assíncrono)
    |
    v
ElasticSearch indexa tag (busca rápida)
    |
    v
HTTP 201 Created + ID da tag
    |
    v
UI exibe "Tag criada com sucesso"
    |
    v
Opção de:
  - Criar outra tag
  - Ir para lista de tags
  - Aplicar tag a entidades
```

### 6.2 Fluxo de Auto-Complete e Aplicação

```
Usuário em tela de Ativo, clica em campo "Tags"
    |
    v
Campo abre dropdown com auto-complete
    |
    v
Usuário digita "crit"
    |
    v (RxJS debounce 300ms)
POST /api/tags/search { query: "crit", limit: 10 }
    |
    v
ElasticSearch query_string "crit*" com boost em name
    |
    v
Resultado ordenado por usageCount DESC + _score DESC
    |
    v
Retorna [
  { id: "...", name: "Crítico", hexColor: "#FF0000", usageCount: 150 },
  { id: "...", name: "Crítica Manutenção", hexColor: "#FF6600", usageCount: 45 }
]
    |
    v
UI exibe dropdown com tags coloridas + ícones
    |
    v
Usuário clica "Crítico"
    |
    v
POST /api/tags/{tagId}/apply {
  entityType: "Ativo",
  entityId: "{ativoId}"
}
    |
    v
Backend verifica:
  - Tag existe?
  - Ativo existe?
  - Já aplicada?
    |
    +--- [Já existe] ---> HTTP 409 Conflict
    |
    v [Nova]
Insere em EntityTag (com unique constraint ClienteId, EntityType, EntityId, TagId)
    |
    v
Enfileira evento EntityTagCreatedEvent
    |
    v
ElasticSearch incrementa usageCount da tag (async)
    |
    v
HTTP 200 OK
    |
    v
UI atualiza:
  - Tag aparece em lista de tags aplicadas
  - Remove do dropdown (opcional)
  - Mostra "Tag aplicada"
    |
    v
[Opcional] Exibe sugestões ML:
  "Com base no seu Ativo, sugerimos: ..."
    |
    v
Usuário pode aplicar sugestões com 1-click
```

### 6.3 Fluxo de Fusão de Tags

```
Admin vai para Dashboard de Tags
    |
    v
Percebe "Crítico" (150 usos) e "CRÍTICO" (5 usos) - duplicatas
    |
    v
Seleciona ambas as tags
    |
    v
Clica "Fundir Tags"
    |
    v
UI exibe: "Tag origem: [CRÍTICO] → Destino: [Crítico]"
    |
    v
Confirma operação
    |
    v
POST /api/tags/550e8400.../merge/660e8400...
    |
    v
Backend em transação:
  1. Identifica todas as entidades com source tag
  2. Reatribui para destination tag
  3. Remove duplicatas (if dest já existia)
  4. Soft delete da source tag
  5. Atualiza ElasticSearch
    |
    v [Sucesso]
HTTP 200 OK { "mergedCount": 5 }
    |
    v
Auditoria registra:
  action: "TAG_MERGE"
  sourceTagId: "550e8400..."
  destTagId: "660e8400..."
  mergedCount: 5
  userId: "{admin}"
  timestamp: UTC
    |
    v
UI exibe "5 entidades reatribuídas, tag 'CRÍTICO' excluída"
    |
    v
Dashboard atualizado: "Crítico" agora com 155 usos
```

### 6.4 Fluxo de Dashboard e Nuvem de Tags

```
Usuário clica em "Dashboard de Tags"
    |
    v
GET /api/tags/dashboard
    |
    v
Backend executa (com caching):
  - COUNT(*) de tags ativas
  - TOP 10 by usageCount
  - TOP 10 recentes (by AlteradoEm)
  - Agregação por EntityType (ElasticSearch terms agg)
  - Date histogram últimos 30 dias (ElasticSearch)
    |
    v
Retorna:
{
  "totalTags": 45,
  "mostUsed": [
    { "name": "Crítico", "count": 150 },
    { "name": "Premium", "count": 87 },
    ...
  ],
  "recentChanges": [...],
  "usageByType": {
    "Ativo": 250,
    "Contrato": 80,
    "Chamado": 45
  },
  "trend": [
    { "date": "2025-12-28", "count": 5 },
    { "date": "2025-12-27", "count": 3 },
    ...
  ]
}
    |
    v
UI renderiza:
  - KPI Cards (Total Tags, Most Used)
  - Pie chart (Usage by Type)
  - Line chart (Trend)
  - Table (Recent Changes)
    |
    v
GET /api/tags/cloud
    |
    v
Calcula weight para cada tag baseado em usageCount:
  weight = (count - min) / (max - min) * 100
  fontSize = 12 + (weight * 0.12)  // 12px a 24px
    |
    v
Retorna:
[
  { "name": "Crítico", "weight": 150, "fontSize": 20, "hexColor": "#FF0000" },
  { "name": "Premium", "weight": 87, "fontSize": 17, "hexColor": "#00FF00" },
  ...
]
    |
    v
UI renderiza nuvem interativa (Chart.js ou D3.js):
  - Tags maiores = mais usadas
  - Clique em tag = filtra entidades
  - Hover = tooltip com count
```

---

## 7. SEGURANÇA

### 7.1 Proteções Implementadas

| Proteção | Descrição |
|----------|-----------|
| **SQL Injection** | Parametrização obrigatória em EF Core (LINQ), ElasticSearch queries construídas com Query DSL (não string concatenation). |
| **XSS em nomes de tags** | HtmlEncoder.Default.Encode() ao renderizar nomes em UI. Tags armazenadas como plain text, nunca HTML. |
| **CSRF Protection** | AntiforgeryToken em POSTs (ASP.NET Core padrão). |
| **Validação de permissões** | Autorização em cada endpoint via [Authorize] + PolicyProvider (policy `tags:tag:read` etc.). ClienteId extraído de claims JWT, nunca user input. |
| **Rate limiting** | Throttling em /api/tags/search (max 10 requests/sec por user) para evitar DoS de auto-complete. |
| **Validação de entrada** | FluentValidation em todos os commands. Cor, ícone, nome contra whitelist/regex. |
| **Soft delete enforcement** | Query filters no EF Core garantem `FlExcluido = 0` em todas as queries (excepto para admin view histórico). |
| **Timeout de ElasticSearch** | Fallback para LIKE em SQL se ES não responde em 5s (graceful degradation). |
| **Logging de acesso** | Auditoria obrigatória em delete/merge/rename, com IP, user, timestamp. |
| **Criptografia em transit** | HTTPS obrigatório (TLS 1.2+) para endpoints de API. |
| **HSTS Header** | Strict-Transport-Security: max-age=31536000. |

### 7.2 Testes de Segurança Obrigatórios

- [ ] **SQL Injection**: Inserir `' OR '1'='1` em nome de tag, verificar se falha validação.
- [ ] **XSS**: Inserir `<script>alert('xss')</script>` em nome, confirmar que é HTML-encoded em resposta.
- [ ] **CSRF**: POST sem token, verificar se retorna 400.
- [ ] **Acesso sem permissão**: Usuário sem `tags:tag:create`, tentar POST /api/tags, verificar 403.
- [ ] **Cross-tenant**: User de Tenant A tenta acessar tags de Tenant B (injection de ClienteId), verificar 403.
- [ ] **Rate limit**: 20 requisições rápidas em /api/tags/search, verificar throttling após limite.
- [ ] **Soft delete integrity**: Excluir tag, verificar que não aparece em listas, mas registro permanece em BD.
- [ ] **Cascata segura**: Excluir tag pai com filhas, verificar que filhas não são orfanadas (se cascata aplicável).
- [ ] **ElasticSearch fallback**: Desligar ES, verificar que auto-complete funciona com LIKE (degradado mas funcional).
- [ ] **Auditoria imutável**: Verificar que registros de auditoria não podem ser alterados após criação.

---

## 8. MÉTRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medição |
|-----|------|---------|
| **Taxa de Cobertura de Tags** | 80% das entidades aplicáveis marcadas | (Entidades com ≥1 tag / Total entidades) × 100 |
| **Tempo de Auto-Complete** | < 200ms (p95) | ElasticSearch query latency, monitorado via APM |
| **Acurácia de Sugestões ML** | 70% (tags sugeridas aplicadas em 30 min) | (Sugestões aceitas / Total sugeridas) × 100 |
| **Taxa de Duplicação** | < 5% (detecção de nomes similares) | Algoritmo Levenshtein em batch, relatório mensal |
| **Usabilidade de Nuvem** | 60% usuários clicam em tag cloud | Google Analytics, event tracking em clicks |
| **Performance de Dashboard** | < 500ms carregamento | APM latency (ElasticSearch aggs + BD query) |
| **Taxa de Erro de Validação** | < 2% (rejeição por nome duplicado, etc) | Contagem de HTTP 400s / Total requests |
| **Retenção de Auditoria** | 100% (sem perda de logs) | Verificação mensal de integridade de tabela TagAudit |

### 8.2 Alertas

| Alerta | Condição | Ação |
|--------|----------|------|
| **Auto-Complete latência alta** | Latência p95 > 500ms por 5 min | Verificar ES cluster, índices, tamanho de dataset. Considerar sharding. |
| **ElasticSearch desconectado** | ES não responde por > 1 min | Fallback automático para LIKE; notificar ops. Retry com backoff. |
| **Taxa de erro alta** | HTTP 4xx ou 5xx > 5% | Revisar logs, validações, payload malformado. Page on-call. |
| **Crescimento incontrolado de tags** | Nova tags/dia > 100 (anômalo) | Investigar padrão de uso. Possível bot ou erro na importação. |
| **Crescimento de TagAudit** | Tabela ultrapassa 1 GB sem poda | Executar archive jobs, mover registros antigos para tabela histórica. |
| **Ciclo detectado em hierarquia** | Validação flagged cycle | Notificar admin, impedir operação, sugerir merge/rename. |
| **Taxa de duplicação em spike** | Duplicatas detectadas > 20 em 1h | Alertar sobre necessidade de cleanup, sugerir merge em batch. |
| **Acurácia ML degradada** | Accuracy < 50% por 7 dias | Retraining do modelo, verificar qualidade de dados, considerar ajuste de features. |

---

## 9. PRÓXIMOS PASSOS

1. **Modelo de Dados (MD-106)**: Criar `MD-RF106.md` com DDL completo de tabelas:
   - `Tag` (principal)
   - `TagTaxonomy` (relação pai-filho)
   - `EntityTag` (aplicação a entidades)
   - `TagAudit` (auditoria)
   - Índices, constraints, triggers

2. **Casos de Uso (UC-106)**: Documentar em `UC-RF106.md`:
   - UC-106-01: Criar tag
   - UC-106-02: Editar tag
   - UC-106-03: Aplicar tag a ativo
   - UC-106-04: Buscar por tags (auto-complete)
   - UC-106-05: Fusão de tags duplicadas
   - UC-106-06: Visualizar dashboard
   - UC-106-07: Exportar dados por tag
   - (Mínimo 5, máximo 10 com aceitação detalhada)

3. **Workflow/Telas (WF-106)**: Criar `WF-RF106.md` com:
   - Protótipos de tela (listagem, form de criação, hierarquia)
   - Componentes Angular necessários (ng-select, tag cloud, table)
   - Estados da aplicação (criar, editar, deletar, loading, error)
   - Integrações API (endpoints, payloads, erros esperados)

4. **User Stories (user-stories.yaml)**: Criar `user-stories.yaml` com breakdown em User Stories implementáveis:
   - Story 1: CRUD de tags (5 pts)
   - Story 2: Hierarquia e validações (8 pts)
   - Story 3: Auto-complete com ElasticSearch (5 pts)
   - Story 4: Sugestões ML (8 pts)
   - Story 5: Fusão e renomeação em lote (5 pts)
   - Story 6: Dashboard e nuvem de tags (5 pts)
   - Story 7: Auditoria e exportação (5 pts)
   - Story 8: Testes E2E e security (8 pts)

5. **Testes (TC-RF106)**: Documentar em `TC-RF106-*.md`:
   - `TC-RF106-BACKEND.md`: Testes unitários (validações, queries, ElasticSearch)
   - `TC-RF106-FRONTEND.md`: Testes Angular (componentes, serviços, formulários)
   - `TC-RF106-SEGURANCA.md`: Testes de segurança (SQL injection, XSS, CSRF, RBAC)
   - `TC-RF106-E2E.md`: Testes end-to-end (Playwright) de fluxos completos

6. **Implementação Backend**: Comandos, queries, handlers, repositories, services conforme CONTRATO DE EXECUÇÃO – BACKEND.

7. **Implementação Frontend**: Componentes, páginas, serviços, interceptadores conforme CONTRATO DE EXECUÇÃO – FRONTEND.

8. **Validação Tester**: Executar suite de testes via CONTRATO DE EXECUÇÃO – TESTER-BACKEND.

9. **Documentação Governada**: Executar CONTRATO DE DOCUMENTAÇÃO GOVERNADA para registrar definitividade da especificação.

10. **Deploy**: Executar CONTRATO DE DEPLOY – AZURE para movimentação para HOM/PRD.

---

## CHANGELOG

| Versão | Data | Descrição | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versão inicial com 15 regras de negócio, 4 integrações, 13 endpoints, 4 fluxos principais | Claude Code |

---

**Ultima Atualizacao**: 2025-12-28
**Autor**: Claude Code / AI Agent
**Revisao**: Pendente (awaiting design review)

