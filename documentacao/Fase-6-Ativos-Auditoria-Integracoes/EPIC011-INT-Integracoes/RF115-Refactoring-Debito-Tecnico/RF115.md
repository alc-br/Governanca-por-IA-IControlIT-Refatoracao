# RF-115: Refactoring e Gestão de Débito Técnico

**Versao**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF-024, RF-112, RF-115 | **EPIC**: EPIC011-INT-Integracoes
**Fase**: Fase 6 - Ativos, Auditoria e Integrações

---

## 1. RESUMO EXECUTIVO

### 1.1 Descricao Geral

Este requisito especifica o módulo de **Gestão de Débito Técnico e Refactoring** do sistema IControlIT, responsável pela identificação, priorização, acompanhamento e resolução sistemática de débitos técnicos acumulados no código-fonte. O módulo integra-se com ferramentas de análise estática (SonarQube, NDepend), gestão de qualidade de código (cobertura de testes, complexidade ciclomática) e Azure DevOps para rastreamento contínuo de métricas de qualidade.

Este RF implementa um **framework governado de refactoring** que garante que todas as melhorias de código sejam rastreáveis, prorizáveis e auditáveis. Débitos técnicos são entidades gerenciáveis no sistema, com ciclo de vida completo: identificação → priorização → aprovação → implementação → validação → fechamento.

O módulo opera sob governança rigorosa, garantindo que refactorings mantêm 100% de compatibilidade com frontends existentes e passam por validação de regressão completa antes de merge em `dev`.

### 1.2 Importancia Estrategica

O módulo de gestão de débito técnico é crítico para:

- **Sustentabilidade Arquitetural**: Mantém a qualidade do código em níveis aceitáveis, evitando acúmulo que compromete futuras evoluções
- **Conformidade Técnica**: Garante que padrões de Clean Code, SOLID e arquitetura são respeitados continuamente
- **Previsibilidade de Escopo**: Quantifica técnicamente o "custo oculto" de débito, permitindo estimativas mais precisas em PRs
- **Continuidade do Conhecimento**: Documentação de refactorings serve como histórico de decisões técnicas
- **Redução de Bugs**: Code smells frequentemente correspondem a vulnerabilidades; tratá-los preventivamente reduz production incidents
- **Performance Organizacional**: Facilita onboarding de novos desenvolvedores ao eliminar "código legado complexo"
- **Compliance LGPD/Segurança**: Auditoria contínua de refactorings garante rastreabilidade de mudanças sensíveis

### 1.3 Conceitos Fundamentais

**Débito Técnico**: Acúmulo de trabalho técnico necessário para manter o código sustentável. Diferencia-se de bugs (que quebram funcionalidade) - débito é código que funciona, mas viola padrões arquiteturais ou de qualidade.

**Code Smell**: Indicador superficial de que pode haver problema mais profundo no código. Exemplos: método muito longo, classe com muitas responsabilidades, duplicação de código, complexidade ciclomática alta.

**Complexidade Ciclomática**: Métrica que quantifica o número de caminhos de execução independentes em uma função. Valores altos indicam código difícil de testar e manter.

**Duplicação de Código**: Segmentos de código idênticos ou muito similares em múltiplas localizações. Aumenta manutenibilidade e risco de bugs inconsistentes.

**Cobertura de Testes**: Percentual de linhas/branches de código executadas durante testes automatizados. Meta: mínimo 80% linha, 70% branch.

**Quality Gate**: Conjunto de métricas que um código DEVE cumprir para ser aprovado. Se falha, automaticamente bloqueia merge de PR.

**Code Review Técnico**: Análise realizada por ferramenta automatizada (SonarQube) que identifica violações sem revisão manual.

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET) | Modernizado (.NET 10 + Angular) |
|---------|-----------------|--------------------------------|
| **Análise de Qualidade** | Manual, ad-hoc, sem rastreamento | SonarQube automatizado, métricas históricas |
| **Gestão de Débito** | Desorganizada, priorização informal | Entidades gerenciáveis, matriz de risco-esforço |
| **Bloqueio de PR** | Código ruim mergeava sem validação | Quality Gate obrigatório bloqueia merge |
| **Rastreabilidade** | Sem histórico de refactorings | Auditoria completa de todas as mudanças |
| **Integração DevOps** | Manual em Excel | Integrada com Azure DevOps work items |
| **Relatórios de Qualidade** | Gerados manualmente em PowerPoint | Dashboards em tempo real, Power BI |
| **Regressão em Refactoring** | Testes manuais incompletos | Testes E2E obrigatórios antes de merge |

### 1.5 Funcionalidades Principais

1. **Análise Contínua de Código** - Integração com SonarQube para detecção automática de code smells, complexidade, duplicação em cada PR
2. **Gestão de Débitos** - CRUD completo: criar débito, priorizar, vincular a PR, resolver, validar
3. **Priorização Inteligente** - Matriz de risco vs. esforço, score de impacto, impacto em performance
4. **Rastreamento de Métricas** - Dashboard mostrando tendências: cobertura de testes, complexidade média, linhas duplicadas
5. **Integração Azure DevOps** - Criação automática de work items, vinculação bidirecional com PRs
6. **Auditoria de Refactorings** - Log completo: quem, quando, por que, impacto em métricas
7. **Relatórios Executivos** - Visualizações de qualidade para stakeholders (Progress vs. Target)
8. **Análise de Impacto** - Simulação: se refatorar este método, quanto melhorar a cobertura?
9. **Agendamento de Análises** - Hangfire para executar SonarQube diariamente fora do horário de pico
10. **Compliance com Governança** - Feature flags, i18n, RBAC, LGPD, multi-tenancy

---

## 2. REGRAS DE NEGOCIO

### RN-REF-115-01: Code Smell Crítico Bloqueia PR Automaticamente (Quality Gate)

**Descricao**: Qualquer PR que introduza ou contenha code smell marcado como CRÍTICO pelo SonarQube será automaticamente rejeitada pelo Quality Gate. Merge será bloqueado até que o smell seja resolvido.

**Justificativa**: Code smells críticos frequentemente correlacionam com vulnerabilidades de segurança ou erros em lógica de negócio. Bloquear automaticamente força resolve-los no contexto do PR, não deixando para depois.

**Implementacao**:
```csharp
public class QualityGateValidator
{
    private readonly ISonarQubeClient _sonarClient;
    private readonly ILogger<QualityGateValidator> _logger;

    public async Task<QualityGateResult> ValidateAsync(string projectKey, string branchName)
    {
        var issues = await _sonarClient.GetIssuesAsync(projectKey, branchName,
            severity: "CRITICAL");

        if (issues.Count > 0)
        {
            _logger.LogWarning("Quality Gate FAILED: {Count} critical issues found",
                issues.Count);

            return QualityGateResult.Failed(
                "Merge blocked: Critical code smells detected. Fix issues and push again.",
                issues
            );
        }

        return QualityGateResult.Passed();
    }
}
```

**Exemplos**:
- ✓ PR com apenas 1 code smell MENOR (Info): Merge permitido
- ✗ PR com 1 code smell CRÍTICO (SQL Injection risk): Merge bloqueado, developer deve corrigir
- ✗ PR com 2 code smells CRÍTICOS: Merge bloqueado

---

### RN-REF-115-02: Complexidade Ciclomática Máxima é 10 por Método

**Descricao**: Nenhum método pode ter complexidade ciclomática superior a 10. Se um método atinge esse limite durante desenvolvimento, deve ser refatorado antes de merge.

**Justificativa**: Complexidade > 10 torna código difícil de testar (mais de 1024 possíveis caminhos), aumenta risco de bugs. Estudos empíricos mostram aumento dramático de bugs em CC > 10.

**Implementacao**:
```csharp
public class ComplexityAnalyzer
{
    private const int MaxCyclomaticComplexity = 10;

    public ComplexityCheckResult ValidateMethod(MethodInfo method, int actualComplexity)
    {
        if (actualComplexity > MaxCyclomaticComplexity)
        {
            return ComplexityCheckResult.Failed(
                $"Method '{method.Name}' has CC={actualComplexity}, max allowed is {MaxCyclomaticComplexity}",
                suggestion: "Break method into smaller functions using Extract Method refactoring"
            );
        }

        return ComplexityCheckResult.Passed();
    }

    // NDepend integration
    public async Task<Dictionary<string, int>> AnalyzeAssemblyAsync(string assemblyPath)
    {
        var violations = new Dictionary<string, int>();
        // NDepend analyzer integration
        return violations;
    }
}
```

**Exemplos**:
- ✓ Método com 8 if-statements encadeados: CC=9, aprovado
- ✗ Método com 12 if-statements aninhados: CC=13, bloqueado, deve ser refatorado
- ✓ Refatoração: quebrar em 2 métodos com CC=5 e CC=6: aprovado

---

### RN-REF-115-03: Duplicação de Código Máxima é 3% do Total de Linhas

**Descricao**: Não mais que 3% do código-fonte pode ser duplicado (mesmos segmentos repetidos). Código duplicado além deste limite deve ter refactoring registrado como débito técnico.

**Justificativa**: Duplicação aumenta exponencialmente o custo de manutenção. Se alterar lógica em um lugar, precisa alterar em 10+ outros. 3% é limite realista para código legado em transição.

**Implementacao**:
```csharp
public class DuplicationAnalyzer
{
    private const decimal MaxDuplicationPercentage = 0.03m;

    public DuplicationReport AnalyzeDuplications(SonarQubeMetrics metrics)
    {
        var totalLines = metrics.TotalLines;
        var duplicatedLines = metrics.DuplicatedLines;
        var duplicationRatio = (decimal)duplicatedLines / totalLines;

        var report = new DuplicationReport
        {
            TotalLines = totalLines,
            DuplicatedLines = duplicatedLines,
            DuplicationPercentage = duplicationRatio * 100,
            IsCompliant = duplicationRatio <= MaxDuplicationPercentage,
            Violations = ExtractDuplicatedBlocks(metrics)
        };

        if (!report.IsCompliant)
        {
            report.Recommendation =
                $"Duplication at {report.DuplicationPercentage:F2}% exceeds {MaxDuplicationPercentage * 100}% limit. " +
                $"Extract {report.Violations.Count} duplicated blocks into shared methods.";
        }

        return report;
    }

    private List<CodeBlock> ExtractDuplicatedBlocks(SonarQubeMetrics metrics)
    {
        // Integração com SonarQube API para extrair blocos duplicados
        return metrics.Issues
            .Where(i => i.Type == "DUPLICATION")
            .Select(i => CodeBlock.FromIssue(i))
            .ToList();
    }
}
```

**Exemplos**:
- Codebase de 50.000 linhas com 1.200 linhas duplicadas = 2.4% ✓ Compliant
- Codebase de 50.000 linhas com 1.800 linhas duplicadas = 3.6% ✗ Violação
- Ação: Identificar blocos duplicados, criar débito técnico para extract method refactoring

---

### RN-REF-115-04: Cobertura de Testes Mínima é 80% Linha, 70% Branch

**Descricao**: Todo código novo deve ter cobertura mínima de 80% em nível de linha (linhas executadas em testes) e 70% em nível de branch (condicionais testadas ambos os caminhos). PRs que reduzem cobertura serão rejeitadas.

**Justificativa**: 80% linha é padrão industry para código em produção. 70% branch garante que condicionais são testadas de verdade, não apenas cobertas.

**Implementacao**:
```csharp
public class CoverageValidator
{
    private const decimal MinLineCodeCoverage = 0.80m;
    private const decimal MinBranchCodeCoverage = 0.70m;

    public CoverageCheckResult ValidateCoverage(CoverletReport report)
    {
        var lineCoverage = report.LineCodeCoverage;
        var branchCoverage = report.BranchCodeCoverage;

        var violations = new List<string>();

        if (lineCoverage < MinLineCodeCoverage)
        {
            violations.Add(
                $"Line coverage {lineCoverage:P} is below minimum {MinLineCodeCoverage:P}. " +
                $"Add {Math.Ceil((MinLineCodeCoverage - lineCoverage) * 1000)} lines of test coverage."
            );
        }

        if (branchCoverage < MinBranchCodeCoverage)
        {
            violations.Add(
                $"Branch coverage {branchCoverage:P} is below minimum {MinBranchCodeCoverage:P}. " +
                $"Add tests for uncovered branches in conditional statements."
            );
        }

        if (violations.Count > 0)
        {
            return CoverageCheckResult.Failed(violations);
        }

        return CoverageCheckResult.Passed();
    }

    public CoverageReport GenerateDetailedReport(CoverletData data)
    {
        var report = new CoverageReport
        {
            LineCodeCoverage = CalculateLineCoverage(data),
            BranchCodeCoverage = CalculateBranchCoverage(data),
            MethodsCovered = data.Methods.Count(m => m.IsFullyCovered),
            MethodsNotCovered = data.Methods.Count(m => !m.IsFullyCovered),
            GeneratedAt = DateTime.UtcNow
        };

        return report;
    }
}
```

**Exemplos**:
- PR com 82% linha, 75% branch: ✓ Aprovado
- PR com 78% linha, 72% branch: ✗ Rejeitado (ambos abaixo do mínimo)
- PR que reduz cobertura global de 85% para 79%: ✗ Rejeitado (regressão)

---

### RN-REF-115-05: Débito Técnico Deve Ter Classificação (Crítico, Alto, Médio, Baixo)

**Descricao**: Todo débito técnico registrado no sistema deve ser classificado em 4 níveis: CRÍTICO (bloqueia produção), ALTO (afeta performance/segurança), MÉDIO (reduz manutenibilidade), BAIXO (nice-to-have).

**Justificativa**: Priorização sistemática permite que equipe foque no que importa. Sem classificação, débitos críticos podem ser ignorados por tarefas triviais.

**Implementacao**:
```csharp
public enum TechnicalDebtSeverity
{
    /// <summary>Bloqueia produção, vulnerabilidade crítica, outage iminente</summary>
    Critical = 0,

    /// <summary>Afeta performance significativa, risco de segurança, difícil de manter</summary>
    High = 1,

    /// <summary>Reduz manutenibilidade, aumenta tempo de PR review, code smell</summary>
    Medium = 2,

    /// <summary>Nice-to-have, melhoria de estilo de código</summary>
    Low = 3
}

public class TechnicalDebtEntity
{
    public Guid Id { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public TechnicalDebtSeverity Severity { get; set; }
    public Guid TenantId { get; set; } // Multi-tenancy
    public DateTime CreatedAt { get; set; }
    public DateTime? ResolvedAt { get; set; }
    public string CreatedByUserId { get; set; }
    public string ResolvedByUserId { get; set; }
    public string AffectedComponentPath { get; set; }
    public int EstimatedHours { get; set; }
    public decimal ImpactScore { get; set; } // 0-100
    public string LinkedPullRequestUrl { get; set; }
    public string AuditLog { get; set; } // JSON serializado de mudanças
}

public class CreateTechnicalDebtCommand : IRequest<TechnicalDebtDto>
{
    public string Title { get; set; }
    public string Description { get; set; }
    public TechnicalDebtSeverity Severity { get; set; }
    public string AffectedComponentPath { get; set; }
    public int EstimatedHours { get; set; }
    public decimal ImpactScore { get; set; }
}
```

**Exemplos**:
- ✓ CRÍTICO: SQL Injection vulnerability em stored procedure de pagamento
- ✓ ALTO: O(n²) algorithm em relatório que demora 30 minutos com 100k registros
- ✓ MÉDIO: Duplicação de 5 linhas de código de validação em 3 métodos
- ✓ BAIXO: Namespace import não utilizado em 10 arquivos

---

### RN-REF-115-06: Débitos Críticos Devem Ser Resolvidos em 30 Dias

**Descricao**: Qualquer débito marcado como CRÍTICO deve ter plano de resolução iniciado dentro de 7 dias e estar 100% resolvido em 30 dias. Passado esse prazo, escalação automática para CTO.

**Justificativa**: Débitos críticos podem evoluir para falhas em produção. Prazo impõe disciplina. Escalação garante visibilidade executiva.

**Implementacao**:
```csharp
public class CriticalDebtEnforcer : BackgroundService
{
    private readonly IDebtRepository _debtRepository;
    private readonly INotificationService _notificationService;
    private readonly ILogger<CriticalDebtEnforcer> _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var criticalDebts = await _debtRepository.GetAllAsync(
                severity: TechnicalDebtSeverity.Critical,
                unresolvedOnly: true
            );

            foreach (var debt in criticalDebts)
            {
                var ageInDays = (DateTime.UtcNow - debt.CreatedAt).TotalDays;

                if (ageInDays >= 30)
                {
                    // 30+ days: escalate to CTO
                    await _notificationService.NotifyAsync(
                        recipientRole: "CTO",
                        subject: "ESCALATION: Critical Technical Debt Unresolved",
                        body: $"Debt '{debt.Title}' created {ageInDays:F0} days ago still unresolved. " +
                              $"SLA breach: 30-day limit exceeded. Immediate action required.",
                        debtId: debt.Id
                    );

                    debt.MarkEscalatedAt(DateTime.UtcNow);
                    await _debtRepository.UpdateAsync(debt);
                }
                else if (ageInDays >= 7 && debt.ResolutionPlanStartedAt == null)
                {
                    // 7+ days: warning if no plan started
                    await _notificationService.NotifyAsync(
                        recipientRole: "TechLead",
                        subject: "ACTION REQUIRED: Critical Technical Debt",
                        body: $"Debt '{debt.Title}' is 7+ days old without a resolution plan. " +
                              $"Deadline for resolution: {debt.CreatedAt.AddDays(30):yyyy-MM-dd}",
                        debtId: debt.Id
                    );
                }
            }

            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}
```

**Exemplos**:
- Débito crítico criado em 01/01:
  - Dia 08: Notificação "7 dias sem plano"
  - Dia 31: Escalação automática para CTO
- Débito criado, plano iniciado em dia 5: Ambos dentro do SLA, sem escalação

---

### RN-REF-115-07: SonarQube Deve Executar em Todos os PRs

**Descricao**: Antes de qualquer PR ser aprovada, análise SonarQube DEVE rodar automaticamente no branch. Resultados bloqueiam ou permitem merge conforme Quality Gate.

**Justificativa**: Análise manual é impossível de escalar. Automação garante consistência 100%.

**Implementacao**:
```csharp
// Azure Pipeline YAML
trigger:
  - dev

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  sonarProjectKey: 'icontrolit-backend'
  sonarOrganization: 'icontrolit'

stages:
  - stage: SonarAnalysis
    displayName: 'SonarQube Code Quality Gate'
    jobs:
      - job: AnalyzeCode
        displayName: 'Run SonarQube Scanner'
        steps:
          - task: UseDotNet@2
            inputs:
              packageType: 'sdk'
              version: '10.x'

          - task: DotNetCoreCLI@2
            inputs:
              command: 'build'
              arguments: '--configuration $(buildConfiguration)'

          - task: SonarCloudPrepare@1
            inputs:
              SonarCloud: 'SonarCloudConnection'
              organization: '$(sonarOrganization)'
              scannerMode: 'MSBuild'
              projectKey: '$(sonarProjectKey)'

          - task: DotNetCoreCLI@2
            inputs:
              command: 'test'
              arguments: '--configuration $(buildConfiguration) --logger trx'

          - task: SonarCloudAnalyze@1
            inputs:
              javaToolsVersion: 'LATEST'

          - task: SonarCloudPublish@1
            inputs:
              pollingTimeoutSec: '300'
```

**Exemplos**:
- PR abre: Pipeline dispara automaticamente
- SonarQube analisa: encontra 2 code smells MÉDIOS
- Quality Gate: AMARELO, merge permitido com aviso
- Se encontrasse 1 CRÍTICO: Quality Gate VERMELHO, merge bloqueado

---

### RN-REF-115-08: Métricas de Qualidade Atualizadas Diariamente

**Descricao**: Dashboard de métricas (cobertura, complexidade, duplicação, débitos abertos) atualiza automaticamente a cada 24 horas ou sob demanda. Histórico de 12 meses permite visualizar trends.

**Justificativa**: Trends são mais importantes que valores absolutos. Redução gradual de cobertura é problema; aumento gradual é sucesso.

**Implementacao**:
```csharp
public class DailyMetricsRefreshSchedule
{
    private readonly ISonarQubeClient _sonarClient;
    private readonly IMetricsRepository _metricsRepository;
    private readonly ILogger<DailyMetricsRefreshSchedule> _logger;

    [Hangfire.RecurringJob("daily-metrics-refresh")]
    public async Task RefreshDailyMetricsAsync()
    {
        _logger.LogInformation("Starting daily metrics refresh at {Timestamp}",
            DateTime.UtcNow);

        var projects = await _metricsRepository.GetAllProjectsAsync();

        foreach (var project in projects)
        {
            try
            {
                var metrics = await _sonarClient.GetProjectMetricsAsync(project.SonarKey);

                var snapshot = new MetricsSnapshot
                {
                    ProjectId = project.Id,
                    TenantId = project.TenantId,
                    SnapshotDate = DateTime.UtcNow.Date,
                    LineCodeCoverage = metrics.Coverage,
                    BranchCodeCoverage = metrics.BranchCoverage,
                    CyclomaticComplexity = metrics.Complexity,
                    DuplicatedLinesPercentage = metrics.DuplicatedLines,
                    SecurityHotspots = metrics.SecurityHotspots,
                    CriticalIssues = metrics.Issues.Count(i => i.Severity == "CRITICAL"),
                    TechnicalDebtDays = (int)metrics.TechnicalDebt.TotalDays,
                    LineCount = metrics.Lines,
                    CachedAt = DateTime.UtcNow
                };

                await _metricsRepository.SaveSnapshotAsync(snapshot);
                _logger.LogInformation("Metrics refreshed for project {ProjectKey}",
                    project.SonarKey);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error refreshing metrics for project {ProjectKey}",
                    project.SonarKey);
                // Não re-lança; continua com próximo projeto
            }
        }

        _logger.LogInformation("Daily metrics refresh completed");
    }
}

public class MetricsSnapshot
{
    public Guid ProjectId { get; set; }
    public Guid TenantId { get; set; }
    public DateTime SnapshotDate { get; set; }
    public decimal LineCodeCoverage { get; set; }
    public decimal BranchCodeCoverage { get; set; }
    public int CyclomaticComplexity { get; set; }
    public decimal DuplicatedLinesPercentage { get; set; }
    public int SecurityHotspots { get; set; }
    public int CriticalIssues { get; set; }
    public int TechnicalDebtDays { get; set; }
    public long LineCount { get; set; }
    public DateTime CachedAt { get; set; }
}
```

**Exemplos**:
- Dashboard mostra gráfico: cobertura em 70% há 6 meses, agora 85% - Trend positivo
- Duplicação flutuou 2-3% últimos 3 meses, subiu para 4% hoje - Alerta investigar
- Débitos não-resolvidos: 15 há 30 dias, 8 há 15 dias, 2 críticos - Status vermelho

---

### RN-REF-115-09: Refactoring Deve Ter Testes de Regressão Obrigatórios

**Descricao**: Qualquer refactoring (muda estrutura de código sem mudar comportamento) DEVE ter suite de testes de regressão E2E que prova que funcionalidade anterior mantém 100% de compatibilidade. Sem testes verdes, refactoring não pode ser mergeado.

**Justificativa**: Refactoring por definição não deve mudar comportamento, apenas estrutura. Testes de regressão provam isso. Sem eles, "refactoring" é na verdade "implementação de nova feature escondida" - muito arriscado.

**Implementacao**:
```csharp
[Collection("Refactoring Regression Tests")]
public class RefactoringRegressionTests : IAsyncLifetime
{
    private readonly PlaywrightFixture _fixture;
    private readonly IPage _page;

    public RefactoringRegressionTests(PlaywrightFixture fixture)
    {
        _fixture = fixture;
    }

    public async Task InitializeAsync()
    {
        var browser = await _fixture.GetBrowserAsync();
        _page = await browser.NewPageAsync();
    }

    public async Task DisposeAsync()
    {
        await _page.CloseAsync();
    }

    // Testes de regressão para refactoring de "ExtractComplexValidationMethod"

    [Fact(DisplayName = "Refactoring: Complex Validation - Valid Input")]
    public async Task TestComplexValidationWithValidInput()
    {
        // Arrange
        var testData = new { cnpj = "11222333000181", name = "Acme Corp" };

        // Act
        await _page.GotoAsync("https://localhost:5001/cadastros/clientes");
        await _page.FillAsync("[name='cnpj']", testData.cnpj);
        await _page.FillAsync("[name='name']", testData.name);
        await _page.ClickAsync("button:has-text('Salvar')");

        // Assert - Deve aceitar entrada válida (comportamento igual a antes)
        var successMessage = await _page.WaitForSelectorAsync(".alert-success");
        Assert.NotNull(successMessage);
        var text = await successMessage.TextContentAsync();
        Assert.Contains("salvo com sucesso", text);
    }

    [Fact(DisplayName = "Refactoring: Complex Validation - Invalid CNPJ")]
    public async Task TestComplexValidationWithInvalidCnpj()
    {
        // Arrange
        var testData = new { cnpj = "00000000000000", name = "Acme Corp" };

        // Act
        await _page.GotoAsync("https://localhost:5001/cadastros/clientes");
        await _page.FillAsync("[name='cnpj']", testData.cnpj);
        await _page.FillAsync("[name='name']", testData.name);
        await _page.ClickAsync("button:has-text('Salvar')");

        // Assert - Deve rejeitar CNPJ inválido (comportamento igual a antes)
        var errorMessage = await _page.WaitForSelectorAsync(".alert-danger");
        Assert.NotNull(errorMessage);
        var text = await errorMessage.TextContentAsync();
        Assert.Contains("CNPJ inválido", text);
    }

    [Fact(DisplayName = "Refactoring: Complex Validation - Audit Trail Maintained")]
    public async Task TestComplexValidationMaintainsAuditTrail()
    {
        // Arrange
        var client = new HttpClient { BaseAddress = new Uri("https://localhost:5001") };
        var cnpj = "11222333000181";

        // Act: Cria cliente
        var response = await client.PostAsJsonAsync("/api/clientes",
            new { cnpj, name = "Acme Corp" });
        Assert.True(response.IsSuccessStatusCode);

        var location = response.Headers.Location.ToString();
        var clientId = Guid.Parse(location.Split('/').Last());

        // Act: Valida auditoria foi registrada
        var auditResponse = await client.GetAsync($"/api/auditoria?entityId={clientId}");
        var auditData = await auditResponse.Content.ReadAsAsync<List<AuditLogEntry>>();

        // Assert
        Assert.NotEmpty(auditData);
        var createEntry = auditData.First();
        Assert.Equal("CLIENTE_CREATE", createEntry.OperationCode);
        Assert.Contains("CNPJ inválido", createEntry.Details);
    }
}
```

**Exemplos**:
- Refactoring "ExtractComplexValidationMethod" de CustomerRepository:
  - PR abre com novo método privado `ValidateCNPJ()`
  - Testes de regressão rodados: 450 testes ✓ PASS
  - Comportamento idêntico ao código original: Confirmado
  - Merge aprovado, débito "validação espalhada" resolvido

- Refactoring falharia se: PR remove lógica silenciosamente, testes E2E falham

---

### RN-REF-115-10: Auditoria de Todos os Refactorings Realizados

**Descricao**: Toda resolução de débito técnico (refactoring, melhoria) registra auditoria completa: quem fez, quando, qual débito foi resolvido, qual commit, qual PR, antes/depois métricas.

**Justificativa**: Auditoria garante rastreabilidade LGPD. Histórico de refactorings é valioso para entender evolução da arquitetura.

**Implementacao**:
```csharp
public class RefactoringAuditLog
{
    public Guid Id { get; set; }
    public Guid TenantId { get; set; }
    public Guid TechnicalDebtId { get; set; }
    public string ResolvedByUserId { get; set; }
    public DateTime ResolvedAt { get; set; }

    public string RefactoringType { get; set; } // "ExtractMethod", "RemoveDuplication", etc
    public string AffectedFiles { get; set; } // JSON array de arquivos modificados
    public int LinesAdded { get; set; }
    public int LinesRemoved { get; set; }
    public int LinesModified { get; set; }

    public string GitCommitHash { get; set; }
    public string GitCommitMessage { get; set; }
    public string PullRequestUrl { get; set; }
    public string PullRequestReviewer { get; set; }
    public DateTime PullRequestMergedAt { get; set; }

    public decimal MetricsBeforeComplexity { get; set; }
    public decimal MetricsAfterComplexity { get; set; }
    public decimal MetricsBeforeDuplication { get; set; }
    public decimal MetricsAfterDuplication { get; set; }
    public decimal MetricsBeforeCoverage { get; set; }
    public decimal MetricsAfterCoverage { get; set; }

    public string RegressionTestsRunUrl { get; set; }
    public bool RegressionTestsPassed { get; set; }
    public int RegressionTestCount { get; set; }

    public string ApprovalNotes { get; set; }
    public string ImpactAssessment { get; set; }

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

public class ResolveTechnicalDebtHandler : IRequestHandler<ResolveTechnicalDebtCommand, RefactoringAuditLogDto>
{
    private readonly IDebtRepository _debtRepository;
    private readonly IAuditService _auditService;
    private readonly IGitHubClient _gitClient;
    private readonly ISonarQubeClient _sonarClient;

    public async Task<RefactoringAuditLogDto> Handle(
        ResolveTechnicalDebtCommand request,
        CancellationToken cancellationToken)
    {
        var debt = await _debtRepository.GetByIdAsync(request.DebtId);

        // Fetch git/PR info
        var pr = await _gitClient.GetPullRequestAsync(request.PullRequestNumber);
        var commit = await _gitClient.GetCommitAsync(request.CommitHash);

        // Fetch before/after metrics
        var baseMetrics = await _sonarClient.GetMetricsAsync(pr.BaseBranch);
        var headMetrics = await _sonarClient.GetMetricsAsync(pr.HeadBranch);

        var auditLog = new RefactoringAuditLog
        {
            Id = Guid.NewGuid(),
            TenantId = request.TenantId,
            TechnicalDebtId = debt.Id,
            ResolvedByUserId = request.UserId,
            ResolvedAt = DateTime.UtcNow,

            RefactoringType = request.RefactoringType,
            AffectedFiles = JsonConvert.SerializeObject(pr.Files.Select(f => f.Name)),
            LinesAdded = pr.Files.Sum(f => f.Additions),
            LinesRemoved = pr.Files.Sum(f => f.Deletions),
            LinesModified = pr.Files.Count,

            GitCommitHash = commit.Sha,
            GitCommitMessage = commit.Message,
            PullRequestUrl = pr.HtmlUrl,
            PullRequestReviewer = pr.RequestedReviewers.FirstOrDefault()?.Login ?? "N/A",
            PullRequestMergedAt = pr.MergedAt ?? DateTime.UtcNow,

            MetricsBeforeComplexity = baseMetrics.Complexity,
            MetricsAfterComplexity = headMetrics.Complexity,
            MetricsBeforeDuplication = baseMetrics.DuplicatedLines,
            MetricsAfterDuplication = headMetrics.DuplicatedLines,
            MetricsBeforeCoverage = baseMetrics.Coverage,
            MetricsAfterCoverage = headMetrics.Coverage,

            RegressionTestsRunUrl = request.RegressionTestsRunUrl,
            RegressionTestsPassed = request.RegressionTestsPassed,
            RegressionTestCount = request.RegressionTestCount,

            ApprovalNotes = request.ApprovalNotes,
            ImpactAssessment = GenerateImpactAssessment(baseMetrics, headMetrics)
        };

        await _auditService.LogRefactoringAsync(auditLog);

        // Marcar débito como resolvido
        debt.MarkAsResolved(auditLog.Id, DateTime.UtcNow, request.UserId);
        await _debtRepository.UpdateAsync(debt);

        return MapToDto(auditLog);
    }

    private string GenerateImpactAssessment(
        SonarQubeMetrics before,
        SonarQubeMetrics after)
    {
        var complexityDelta = before.Complexity - after.Complexity;
        var duplicationDelta = before.DuplicatedLines - after.DuplicatedLines;
        var coverageDelta = after.Coverage - before.Coverage;

        var assessment = new StringBuilder();
        assessment.AppendLine("## Impact Assessment");
        assessment.AppendLine($"- Cyclomatic Complexity: {before.Complexity:F2} → {after.Complexity:F2} " +
            $"({(complexityDelta > 0 ? "↓" : "↑")} {Math.Abs(complexityDelta):F2})");
        assessment.AppendLine($"- Code Duplication: {before.DuplicatedLines:P} → {after.DuplicatedLines:P} " +
            $"({(duplicationDelta > 0 ? "↓" : "↑")} {Math.Abs(duplicationDelta):P})");
        assessment.AppendLine($"- Test Coverage: {before.Coverage:P} → {after.Coverage:P} " +
            $"({(coverageDelta > 0 ? "↑" : "↓")} {Math.Abs(coverageDelta):P})");

        return assessment.ToString();
    }
}
```

**Exemplos**:
- Débito resolvido: "Remove duplicated validation" - PR #1245
  - Audit log registra: 3 arquivos modificados, 45 linhas removidas, 12 adicionadas
  - Complexidade de 8.5 → 6.2, duplication 3.2% → 2.1%
  - Testes passaram 450/450
  - Reviewer: João Silva
  - Impacto: Método mais simples de entender, menos bugs potenciais

---

## 3. REFERENCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `IC1`

**Tabelas Relacionadas**: Sistema legado não possuía tabelas específicas para gestão de débito técnico. Essa é nova funcionalidade, nascida na modernização.

**Stored Procedures Legado Relevantes**:
- Não aplicável - débito técnico é conceito novo

**Telas ASPX Legado**:
- Não existem - módulo novo

**WebServices Legado**:
- Não existem - módulo novo

**Observação**: RF115 é **totalmente novo** na modernização. Não existe equivalente em VB.NET. Funcionalidade foi inspirada em melhores práticas de ferramentas como GitHub, GitLab e Azure DevOps, adaptadas para governança de refactoring.

### 3.2 Code Smells e Débitos Conhecidos no Legado (Inventário Inicial)

| Componente | Tipo de Débito | Severidade | Estimado (dias) |
|-----------|----------------|------------|-----------------|
| `CustomerValidator` | Complexidade CC=14, método muito longo | ALTO | 3 |
| `PaymentProcessor` | Duplicação de lógica em 4 métodos | MÉDIO | 2 |
| `ReportGenerator` | Sem testes unitários, CC=16 | CRÍTICO | 5 |
| `AuditLogger` | Uso de SQL dinâmico, risco SQL Injection | CRÍTICO | 2 |
| `InventoryService` | Code duplication com BillingService | MÉDIO | 3 |

---

## 4. INTEGRACOES OBRIGATORIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `REF_TECH_DEBT_MANAGEMENT`

**Configuracao**:
```json
{
    "featureKey": "REF_TECH_DEBT_MANAGEMENT",
    "nome": "Gestão de Débito Técnico",
    "descricao": "Permite criar, priorizar e rastrear débitos técnicos com integração SonarQube",
    "habilitado": true,
    "isSystemFeature": false,
    "metadata": {
        "sonarIntegrationEnabled": true,
        "qualityGateEnforced": true,
        "autoAnalysisDaily": true,
        "requireRegressionTests": true
    }
}
```

**Feature Flags Adicionais**:

```json
{
    "featureKey": "REF_SONARQUBE_QUALITY_GATE",
    "nome": "SonarQube Quality Gate Enforcement",
    "descricao": "Bloqueia merge se Quality Gate falha",
    "habilitado": true
},
{
    "featureKey": "REF_DAILY_METRICS_DASHBOARD",
    "nome": "Dashboard de Métricas Diário",
    "descricao": "Atualiza dashboard com métricas de SonarQube a cada 24h",
    "habilitado": true
},
{
    "featureKey": "REF_CRITICAL_DEBT_ESCALATION",
    "nome": "Escalação Automática de Débito Crítico",
    "descricao": "Notifica CTO se débito crítico não resolvido em 30 dias",
    "habilitado": true
}
```

---

### 4.2 Internacionalizacao (i18n)

**Chaves de Traducao**:

```json
{
    "refactoring": {
        "menu": {
            "technicalDebt": "Débito Técnico",
            "qualityMetrics": "Métricas de Qualidade",
            "analysisReports": "Relatórios de Análise"
        },
        "debt": {
            "list": {
                "title": "Gestão de Débito Técnico",
                "createNew": "Novo Débito",
                "searchPlaceholder": "Buscar débito por título ou componente...",
                "filters": {
                    "severity": "Severidade",
                    "status": "Status",
                    "dueDate": "Data de Vencimento"
                }
            },
            "form": {
                "title": "Título",
                "description": "Descrição",
                "severity": "Severidade",
                "affectedComponent": "Componente Afetado",
                "estimatedHours": "Horas Estimadas",
                "impactScore": "Score de Impacto",
                "linkedPR": "PR Vinculada"
            },
            "severity": {
                "critical": "Crítico",
                "high": "Alto",
                "medium": "Médio",
                "low": "Baixo"
            },
            "status": {
                "open": "Aberto",
                "inProgress": "Em Progresso",
                "resolved": "Resolvido",
                "closed": "Fechado"
            },
            "messages": {
                "createSuccess": "Débito técnico criado com sucesso",
                "updateSuccess": "Débito atualizado com sucesso",
                "deleteSuccess": "Débito removido com sucesso",
                "resolveSuccess": "Débito marcado como resolvido",
                "errorCreate": "Erro ao criar débito",
                "errorUpdate": "Erro ao atualizar débito",
                "errorDelete": "Erro ao remover débito"
            }
        },
        "metrics": {
            "dashboard": {
                "title": "Dashboard de Qualidade de Código",
                "lastUpdate": "Última atualização",
                "lineCodeCoverage": "Cobertura Linha",
                "branchCodeCoverage": "Cobertura Branch",
                "cyclomaticComplexity": "Complexidade Ciclomática",
                "duplicatedLines": "Linhas Duplicadas",
                "criticalIssues": "Problemas Críticos",
                "technicalDebtDays": "Débito Técnico (dias)"
            },
            "trend": {
                "improving": "Melhorando",
                "stable": "Estável",
                "degrading": "Piorando"
            }
        },
        "qualityGate": {
            "passed": "Quality Gate PASSOU",
            "failed": "Quality Gate FALHOU",
            "warning": "Quality Gate COM AVISOS",
            "details": "Detalhes do Quality Gate",
            "blockedMerge": "Merge bloqueado: Quality Gate falhou"
        },
        "sonarqube": {
            "analysis": "Análise SonarQube",
            "runningAnalysis": "Executando análise...",
            "codeSmells": "Code Smells",
            "vulnerabilities": "Vulnerabilidades",
            "bugs": "Bugs",
            "securityHotspots": "Security Hotspots"
        }
    }
}
```

---

### 4.3 Auditoria

**Operacoes Auditadas**:

| Operacao | Codigo | Dados Registrados |
|----------|--------|-------------------|
| Criar Débito Técnico | `REF_DEBT_CREATE` | ID, Título, Severidade, Componente, Criador |
| Atualizar Débito | `REF_DEBT_UPDATE` | Mudanças de campos (before/after), Atualizador |
| Resolver Débito | `REF_DEBT_RESOLVE` | ID Débito, PR vinculada, Commit, Testes passaram, Resolvido por |
| Priorizar Débito | `REF_DEBT_PRIORITIZE` | ID, Prioridade anterior/nova, Justificativa |
| Executar Análise SonarQube | `REF_SONAR_ANALYZE` | Projeto, Data, Métricas (antes/depois) |
| Gerar Relatório | `REF_REPORT_GENERATE` | Tipo, Data Início/Fim, Usuário |
| Escalar Débito | `REF_DEBT_ESCALATE` | ID Débito, Escalado para, Motivo (SLA) |

**Retencao**: 5 anos (conforme LGPD - Lei Geral de Proteção de Dados)

---

### 4.4 Controle de Acesso (RBAC)

**Permissoes**:

| Permissao | Descricao | Perfis |
|-----------|-----------|--------|
| `refactoring:debt:create` | Criar débito técnico | Developer, TechLead, CTO |
| `refactoring:debt:read` | Visualizar débitos | Todos (leitura pública em dev) |
| `refactoring:debt:update` | Editar débito | Developer (próprio), TechLead, CTO |
| `refactoring:debt:delete` | Excluir débito | TechLead, CTO |
| `refactoring:debt:resolve` | Marcar débito como resolvido | Developer, TechLead |
| `refactoring:debt:prioritize` | Alterar priorização | TechLead, CTO |
| `refactoring:metrics:read` | Visualizar métricas | Todos |
| `refactoring:metrics:export` | Exportar métricas para Excel/PDF | TechLead, Manager |
| `refactoring:sonar:execute` | Executar análise SonarQube | DevOps, CTO |
| `refactoring:sonar:configure` | Configurar regras SonarQube | DevOps |
| `refactoring:reports:read` | Visualizar relatórios | Todos |
| `refactoring:reports:generate` | Gerar novos relatórios | TechLead, Manager |

**Nota**: Débitos podem ser visualizados por todos, mas apenas TechLead/CTO podem priorizar ou excluir. Implementa transparência (todos sabem do débito) com governance (não qualquer um altera prioridade).

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal - Débitos Técnicos

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/v1/refactoring/debts` | Listar débitos técnicos com filtros/paginação | `refactoring:debt:read` |
| GET | `/api/v1/refactoring/debts/{debtId}` | Obter débito específico | `refactoring:debt:read` |
| POST | `/api/v1/refactoring/debts` | Criar novo débito técnico | `refactoring:debt:create` |
| PUT | `/api/v1/refactoring/debts/{debtId}` | Atualizar débito | `refactoring:debt:update` |
| DELETE | `/api/v1/refactoring/debts/{debtId}` | Excluir débito | `refactoring:debt:delete` |

### 5.2 Operacoes Especiais - Débitos

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| POST | `/api/v1/refactoring/debts/{debtId}/resolve` | Marcar débito como resolvido com PR info | `refactoring:debt:resolve` |
| POST | `/api/v1/refactoring/debts/{debtId}/prioritize` | Alterar priorização e justificar | `refactoring:debt:prioritize` |
| POST | `/api/v1/refactoring/debts/{debtId}/link-pr` | Vincular ou desvincular PR ao débito | `refactoring:debt:update` |
| GET | `/api/v1/refactoring/debts/{debtId}/audit-log` | Visualizar histórico de auditoria do débito | `refactoring:debt:read` |
| GET | `/api/v1/refactoring/debts/bulk-export` | Exportar débitos em Excel | `refactoring:metrics:export` |

### 5.3 CRUD - Métricas e Qualidade

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/v1/refactoring/metrics/dashboard` | Dashboard com métricas atuais | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/metrics/history` | Histórico de métricas (12 meses) | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/metrics/snapshot/{date}` | Snapshot de métricas em data específica | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/quality-gate/status` | Status atual do Quality Gate | `refactoring:metrics:read` |
| POST | `/api/v1/refactoring/metrics/export` | Exportar métricas para relatório | `refactoring:metrics:export` |

### 5.4 Endpoints SonarQube Wrapper

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| POST | `/api/v1/refactoring/analysis/execute` | Executar análise SonarQube manual | `refactoring:sonar:execute` |
| GET | `/api/v1/refactoring/analysis/code-smells` | Listar code smells detectados | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/analysis/duplications` | Listar blocos duplicados | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/analysis/complexity` | Complexidade ciclomática por componente | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/analysis/coverage` | Cobertura de testes por módulo | `refactoring:metrics:read` |
| GET | `/api/v1/refactoring/analysis/security` | Security hotspots e vulnerabilidades | `refactoring:metrics:read` |

### 5.5 Relatórios e Análises

| Metodo | Endpoint | Descricao | Permissao |
|--------|----------|-----------|-----------|
| GET | `/api/v1/refactoring/reports/quality` | Relatório executivo de qualidade | `refactoring:reports:read` |
| GET | `/api/v1/refactoring/reports/refactoring-history` | Histórico de refactorings realizados | `refactoring:reports:read` |
| POST | `/api/v1/refactoring/reports/generate` | Gerar novo relatório customizado | `refactoring:reports:generate` |
| GET | `/api/v1/refactoring/reports/{reportId}/download` | Download de relatório em PDF/Excel | `refactoring:reports:read` |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Criação e Resolução de Débito Técnico

```
Developer detecta Code Smell em PR
    |
    v
Abre issue: "Refactor CustomerValidator - CC=14"
    |
    v
Cria Débito Técnico via API/UI
    - Título: "Reduzir complexidade de CustomerValidator"
    - Severidade: ALTO
    - Estimado: 3 horas
    - Componente: Services/CustomerValidator.cs
    |
    v
Sistema registra auditoria
    |
    v
TechLead analisa backlog de débitos
    |
    +--- Prioriza débitos por Impact vs Effort
    |
    v
Débito entra em sprint como "Refactoring Task"
    |
    v
Developer cria branch: feature/RF115-refactor-customer-validator
    |
    v
Executa refactoring:
    - Quebra método longo em 3 métodos menores
    - Reduz CC de 14 para 6
    - Mantém 100% de comportamento
    |
    v
Escreve testes de regressão E2E
    |
    v
Push para PR
    |
    v
Azure Pipeline executa:
    1. Compile (✓)
    2. Unit Tests: 450/450 pass (✓)
    3. SonarQube Analysis (✓)
       - Code Smells: 0 novos
       - Complexidade: 14 → 6 (✓)
       - Coverage: 82% (✓)
    4. E2E Regression Tests: 50/50 pass (✓)
    5. Quality Gate: VERDE (✓)
    |
    v
Code Review passa
    |
    v
PR mergeada para dev
    |
    v
Developer marca débito como RESOLVED via API
    - PR: https://github.com/.../pulls/1245
    - Commit: abc123def456
    - Testes: 450 passed
    - Impacto: CC 14→6, duplicação reduzida, +2% coverage
    |
    v
Sistema registra RefactoringAuditLog completo
    |
    v
Dashboard atualizado:
    - Débitos abertos: 12 → 11
    - CC médio do projeto: 8.2 → 7.9
    |
    v
Notificação enviada a stakeholders:
    "Débito técnico resolvido: CustomerValidator"
```

### 6.2 Fluxo de Gestão de Débito Crítico não Resolvido

```
Débito crítico criado em 2025-12-01
    |
    v (Dia 1-7)
Sistema monitora: sem plano de resolução
    |
    v (Dia 8)
Notificação para TechLead:
    "Débito crítico aberto há 7 dias sem plano. Deadline: 30 dias"
    |
    v (Dia 1-30)
Pode estar em resolução (PR aberto, testes verdes, aguardando merge)
    OU
    Abandono (nenhuma ação)
    |
    +--- (Se em resolução) → Merge para dev antes do dia 31 → Resolvido
    |
    v (Se sem ação até dia 31)
Dia 31: Escalação automática
    - Email para CTO
    - Card no board marcado ESCALADO
    - Prioridade elevada para CRÍTICO+
    |
    v
CTO toma ação (força priorização ou aprova adiamento)
    |
    v
Se adiamento aprovado:
    - Registra justificativa em auditoria
    - Estende prazo por 14 dias com aprovação explícita
    |
    v
Se força resolução:
    - Pull request com hotfix é aberto
    - Mergeado no mesmo dia ou próximo
```

### 6.3 Fluxo de Análise Automática Diária

```
00:00 UTC - Hangfire dispara "DailyMetricsRefreshSchedule"
    |
    v
Para cada projeto registrado no sistema:
    |
    v
Executa: sonar-scanner-cli
    - Analisa código da branch dev
    - Executa SonarQube checks
    |
    v
Coleta métricas:
    - Line coverage: 82%
    - Branch coverage: 71%
    - Cyclomatic complexity: 7.9
    - Duplicated lines: 2.3%
    - Critical issues: 2
    - Technical debt: 5 dias
    |
    v
Calcula deltas vs dia anterior:
    - Coverage: ↑ 1% (positivo)
    - Complexity: → (estável)
    - Issues: → (estável)
    |
    v
Salva MetricsSnapshot no BD
    |
    v
Valida contra Quality Gate:
    - Se alguma métrica falha: notifica
    |
    v
Atualiza Dashboard em tempo real
    |
    v
Gera gráficos de trend (12 meses)
    |
    v
Fim (próxima execução: 24h depois)
```

---

## 7. SEGURANCA

### 7.1 Protecoes Implementadas

| Protecao | Descricao |
|----------|-----------|
| **RBAC Granular** | Apenas TechLead/CTO podem priorizar débitos; desenvolvedores podem criar mas não alterar prioridade |
| **Auditoria Completa** | Todas as mudanças em débitos/métricas registradas com user/timestamp/justificativa |
| **LGPD Compliance** | Dados de débito/auditoria retidos por 5 anos conforme lei, com direito de exclusão após resolução |
| **Quality Gate Blocker** | Code malicioso que passa testes AINDA é bloqueado se violar Quality Gate (e.g., complexidade > 10) |
| **Integração Read-Only SonarQube** | Backend nunca altera SonarQube; apenas lê métricas e status |
| **PR Validation Obrigatória** | Refactoring SEM PR aberta não pode marcar débito como resolvido |
| **Regressão Automática** | Refactorings SEM testes E2E verdes não podem ser mergeados |
| **Segredos Protegidos** | SonarQube token, GitHub token, DevOps token salvos em Azure Key Vault, nunca em código |

### 7.2 Testes de Seguranca Obrigatorios

- [ ] SQL Injection em filtros de débito (e.g., `?search='; DROP TABLE debts--`)
- [ ] XSS em nome/descrição de débito (e.g., `<script>alert('xss')</script>`)
- [ ] CSRF Protection em POST/PUT/DELETE débitos
- [ ] Validacao de permissoes: User A não pode editar débito de User B sem TechLead
- [ ] Validacao de tenant: User de tenant A não consegue ver/editar débitos de tenant B
- [ ] Validacao de limite de requisições (rate limiting) em análises SonarQube
- [ ] Timeout em análises que travam (máximo 1 hora)
- [ ] Validação de URL de PR (não aceitar URL malformada ou apontando para malware)
- [ ] Encriptação de dados sensíveis em auditoria (senhas, tokens não são salvos)

---

## 8. METRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medicao | Frequencia |
|-----|------|---------|-----------|
| **Code Coverage** | 80% linha, 70% branch | Coverlet report | Diariamente |
| **Cyclomatic Complexity Médio** | ≤ 8 | SonarQube | Diariamente |
| **Code Duplication** | ≤ 3% | SonarQube | Diariamente |
| **Critical Technical Debts Resolved** | 100% dentro de 30 dias | Manual audit | Mensalmente |
| **PRs Blocked by Quality Gate** | 0 em dev (todos devem passar) | Azure Pipelines | Por PR |
| **Code Smell Resolution Time** | Médio < 7 dias | Jira + SonarQube | Mensalmente |
| **Security Hotspots** | 0 críticos | SonarQube | Diariamente |
| **Test Case Regression Rate** | 0% (se refactoring passa E2E, não deve quebrar) | Playwright | Por merge |

### 8.2 Alertas

| Alerta | Condicao | Acao |
|--------|----------|------|
| **Quality Gate Failure** | PR introduz code smell CRÍTICO | Merge bloqueado automaticamente |
| **Coverage Regression** | Coverage cai > 2% | Email para TechLead, PR review obrigatório |
| **Complexity Spike** | Novo método com CC > 10 | Reject merge até refactoring |
| **Critical Debt SLA Breach** | Débito crítico não resolvido em 30 dias | Escalate to CTO, board flag vermelho |
| **Sonar Analysis Timeout** | Análise leva > 1 hora | Kill job, alert DevOps, retry em 1h |
| **High Duplication** | Duplication atinge 4% | Notify TechLead, create refactoring debt |
| **Zero-Day Vulnerability** | CVE afeta dependencies | Alert CTO, block dev branch merge |

---

## 9. PROXIMOS PASSOS

1. **Casos de Uso**: Criar [UC-115](./UC-RF115-Refactoring-Debito-Tecnico.md)
2. **Modelo de Dados**: Criar [MD-115](./MD-RF115-Refactoring-Debito-Tecnico.md) com DDL completo
3. **Fluxos**: Criar [WF-115](./WF-RF115-Refactoring-Debito-Tecnico.md) com telas/wireframes
4. **Histórias de Usuário**: Criar [user-stories.yaml](./user-stories.yaml) com stories implementáveis
5. **Testes**: Criar [TC-RF115-BACKEND.md](./TC-RF115-BACKEND.md), [TC-RF115-FRONTEND.md](./TC-RF115-FRONTEND.md), [TC-RF115-E2E.md](./TC-RF115-E2E.md)
6. **Implementação Backend**: Commands/Queries, DDD, CQRS, MediatR
7. **Implementação Frontend**: Componentes Angular, integração com API
8. **Integração SonarQube**: Setup de projeto no SonarCloud, quality gates
9. **CI/CD Pipeline**: Azure DevOps pipeline com SonarQube gate
10. **Relatórios Power BI**: Dashboards de qualidade e trend análises

---

## CHANGELOG

| Versao | Data | Descricao | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versao inicial completa com 10 regras de negócio, 13 endpoints, integrações obrigatórias, fluxos, segurança | Claude Code |

---

**Ultima Atualizacao**: 2025-12-28
**Autor**: Claude Code / IControlIT Governance
**Revisao**: Pendente de aprovação técnica

---

## APENDICE: Exemplos de Implementação (Pseudocodigo)

### A.1 Validator de Quality Gate

```csharp
// Services/QualityGateService.cs
[Service]
public class QualityGateService
{
    private readonly ISonarQubeClient _sonarClient;
    private readonly ILogger<QualityGateService> _logger;

    public async Task<bool> IsQualityGatePassedAsync(string projectKey, string branchName)
    {
        var projectStatus = await _sonarClient.GetProjectStatusAsync(projectKey, branchName);

        return projectStatus.QualityGateStatus == "OK";
    }

    public async Task<QualityGateDetails> GetQualityGateDetailsAsync(
        string projectKey,
        string branchName)
    {
        var status = await _sonarClient.GetProjectStatusAsync(projectKey, branchName);

        return new QualityGateDetails
        {
            IsPassed = status.QualityGateStatus == "OK",
            CriticalIssuesCount = status.Issues.Count(i => i.Severity == "CRITICAL"),
            MajorIssuesCount = status.Issues.Count(i => i.Severity == "MAJOR"),
            CoveragePercentage = status.Coverage,
            ComplexityScore = status.Complexity,
            DuplicatedLinesPercentage = status.DuplicatedLines,
            Issues = status.Issues
        };
    }
}
```

### A.2 Débito Técnico Repository

```csharp
// Repositories/TechnicalDebtRepository.cs
[Repository]
public class TechnicalDebtRepository : IAsyncRepository<TechnicalDebt>
{
    private readonly IContext _context;

    public async Task<List<TechnicalDebt>> GetBySeverityAsync(
        Guid tenantId,
        TechnicalDebtSeverity severity)
    {
        return await _context.TechnicalDebts
            .Where(d => d.TenantId == tenantId && d.Severity == severity && d.ResolvedAt == null)
            .OrderByDescending(d => d.ImpactScore)
            .ToListAsync();
    }

    public async Task<List<TechnicalDebt>> GetUnresolvedOlderThanAsync(
        Guid tenantId,
        TimeSpan age)
    {
        var cutoffDate = DateTime.UtcNow.Subtract(age);

        return await _context.TechnicalDebts
            .Where(d => d.TenantId == tenantId &&
                        d.ResolvedAt == null &&
                        d.CreatedAt <= cutoffDate)
            .ToListAsync();
    }
}
```

---

**Fim do Documento**
