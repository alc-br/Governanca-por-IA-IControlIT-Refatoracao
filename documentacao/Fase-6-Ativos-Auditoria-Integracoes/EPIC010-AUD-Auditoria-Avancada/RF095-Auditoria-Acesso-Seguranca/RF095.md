# RF-095: Auditoria de Acesso e Segurança

**Versão**: 1.0 | **Data**: 2025-12-28
**RF Relacionado**: RF-094, RF-098 | **EPIC**: EPIC010-AUD-Auditoria-Avancada
**Fase**: Fase 6 - Ativos, Auditoria e Integrações

---

## 1. RESUMO EXECUTIVO

### 1.1 Descrição Geral

Este requisito especifica o módulo de **Auditoria de Acesso e Segurança** do sistema IControlIT, responsável pelo rastreamento, análise e detecção de comportamentos relacionados ao acesso de usuários e integridade de segurança da plataforma.

O RF095 implementa um sistema completo de logging de acessos, detecção de anomalias, certificação de permissões e correlação de eventos para conformidade com ISO 27001, LGPD Artigo 46, SOX 404 e PCI-DSS.

O módulo captura tentativas de login (sucesso/falha), ações de usuários (CRUD, exportações, mudanças críticas), detecta comportamentos suspeitos, valida segregação de funções (SOD) e fornece relatórios forenses para investigação de incidentes de segurança.

### 1.2 Importância Estratégica

O módulo de Auditoria de Acesso e Segurança é crítico para:

- **Conformidade Legal**: Cumprimento obrigatório de LGPD (Artigo 46 - Direito de acesso), ISO 27001 (A.12.4 Logging), SOX 404 (Controles de TI) e PCI-DSS (Requisitos 10.1-10.10)
- **Prevenção de Fraudes**: Detecção de comportamentos anômalos (UEBA), acessos privilegiados não autorizados, multiplicidade de login falho, IPs suspeitos
- **Investigação Forense**: Reconstrução completa de ações, correlação de eventos, exportação estruturada para análise forense, retenção de 10 anos
- **Integridade de Dados**: Validação de mudanças críticas, rastreamento de quem alterou o quê e quando, detecção de modificações não autorizadas
- **Governança**: Revisão periódica de acessos (certificação trimestral), segregação de funções, remoção de acessos obsoletos
- **Segurança Operacional**: Dashboard de segurança em tempo real, alertas automáticos de incidentes, integração com SIEM (Azure Sentinel, Splunk)

### 1.3 Conceitos Fundamentais

**Auditoria de Acesso**: Registro completo de cada tentativa de acesso ao sistema, incluindo timestamp, usuário, IP, dispositivo, resultado (sucesso/falha) e motivo da falha.
- Diferencia acessos legítimos de tentativas maliciosas
- Identifica padrões de força bruta (múltiplas falhas)

**Logging de Ações**: Rastreamento de todas as operações executadas por usuários dentro do sistema (CRUD, exportações, mudanças críticas, acessos a dados sensíveis).
- Registra antes/depois para auditoria de mudanças
- Inclui contexto: usuário, timestamp, IP, modificações específicas

**Detecção de Anomalias (UEBA)**: Análise comportamental de usuários e entidades utilizando machine learning para identificar desvios de padrão normal.
- Acessos em horários incomuns
- Volume excessivo de requisições
- Tentativas de acesso a dados fora do perfil
- Múltiplos acessos simultâneos de IPs diferentes

**Segregação de Funções (SOD)**: Garantia de que nenhum usuário acumule permissões conflitantes (ex: criar e aprovar mutuamente).
- Validação de conflitos: Aprovador não pode ser Criador
- Implementação de dual control em operações críticas

**Acessos Privilegiados**: Rastreamento especial de usuários com permissões elevadas (admin, root, superuser).
- Just-In-Time Privilege (JIT) - concessão temporária
- Monitoramento acentuado de ações privilegiadas
- Require aprovação explícita

**Certificação de Permissões**: Revisão periódica (trimestral) onde gerentes validam se seus subordinados ainda precisam das permissões atribuídas.
- Workflow de aprovação/rejeição
- Relatório de permissões obsoletas
- Remoção automática pós-rejeição

**Correlação de Eventos**: Linking automático entre logs para reconstruir sequência completa de ações relacionadas a um incidente.
- Timeline de eventos
- Rastreamento de causa-efeito
- Identificação de múltiplos atores em incidente

**Retenção de Logs**: Armazenamento garantido de logs por 10 anos (conforme LGPD, ISO 27001, SOX 404).
- Arquivamento em storage otimizado (cold storage)
- Acesso rápido para investigações recentes (últimos 90 dias em hot storage)
- Criptografia de dados armazenados

### 1.4 Legado vs Modernizado

| Aspecto | Legado (VB.NET + SQL 2008) | Modernizado (.NET 10 + Angular 19) |
|---------|---------------------------|-----------------------------------|
| **Logging de Acesso** | Arquivo de log simples em disco, sem estrutura, perda de dados | Banco de dados estruturado, replicado, retenção garantida 10 anos |
| **Detecção de Anomalias** | Manual, revisão periódica de logs | Automática via ML (Azure ML/Hangfire), alertas em tempo real |
| **Relatórios** | Crystal Reports estáticos, gerados manualmente | Dashboards interativos, filtros dinâmicos, exportação em múltiplos formatos |
| **Integração SIEM** | Não existente | Azure Sentinel nativo, correlação automática de eventos |
| **Retenção** | ~2 anos (limitação de espaço em disco) | 10 anos garantidos em Azure Storage, arquivamento automático |
| **Segregação de Funções** | Validação manual periódica | Automática no banco de dados, bloqueio em tempo real |
| **Certificação de Permissões** | Processo manual via email/planilha | Workflow digital integrado, rastreamento de aprovações |
| **Performance** | Queries lentas, sem índices otimizados | Índices planejados, particionamento temporal, caches distribuído |
| **Compliance** | Documentação manual, incompleta | Relatórios automáticos pré-formatados para auditor externo |

### 1.5 Funcionalidades Principais

1. **Logging de Tentativas de Acesso** - Registro de toda tentativa (sucesso/falha) com timestamp, usuário, IP, dispositivo, navegador, geolocalização
2. **Rastreamento de Ações de Usuário** - Log de CRUD, exportações, impressões, downloads, mudanças críticas, acessos a dados sensíveis
3. **Detecção de Comportamentos Anômalos** - Análise automática via UEBA (ML) de horários incomuns, volume excessivo, tentativas de força bruta
4. **Análise de Permissões** - Visualização de quem tem acesso a quê, histórico de mudanças, validação de SOD (Segregação de Funções)
5. **Certificação Trimestral de Acessos** - Workflow de revisão onde gerentes aprovam/rejeitam permissões de subordinados
6. **Detecção de Acessos Privilegiados** - Monitoramento especial de admin/root, JIT (Just-In-Time Privilege), aprovações em dual-control
7. **Dashboard de Segurança** - Visualização em tempo real: tentativas falhadas, acessos ativos, alertas de incidente, estatísticas de segurança
8. **Alertas Automáticos** - Disparos de notificações para: múltiplas falhas de login, IP suspeito, acesso a dado sensível não autorizado, mudança crítica
9. **Relatórios Forenses** - Investigação de incidentes: linha do tempo, correlação de eventos, exportação estruturada, análise de causa raiz
10. **Integração SIEM** - Envio automático de logs para Azure Sentinel/Splunk, correlação com outras fontes de segurança
11. **Integração com Política de Segurança** - Leitura de regras de bloqueio de IP, whitelist/blacklist, políticas de senha, MFA obrigatório
12. **Retenção Governada** - Arquivo automático pós-90 dias em cold storage, acesso rápido para investigações recentes, retenção 10 anos

---

## 2. REGRAS DE NEGÓCIO

### RN-SEC-095-01: Registro Obrigatório de Tentativa de Login

**Descrição**: Toda tentativa de acesso ao sistema, bem-sucedida ou falhada, deve ser registrada imediatamente em log estruturado com timestamp UTC, identificação do usuário (email ou login), endereço IP, dispositivo (tipo e identificador), navegador (tipo e versão), geolocalização (país, estado, cidade) e resultado (sucesso, falha - motivo da falha).

**Justificativa**: Conformidade LGPD Artigo 46 (direito de acesso), ISO 27001 A.12.4 (logging de atividades), detecção de força bruta e análise forense de incidentes.

**Implementação**:
```csharp
public class LoginAuditService
{
    private readonly IRepository<LogAcesso> _auditRepository;
    private readonly IGeolocationService _geoService;
    private readonly IDeviceDetectionService _deviceService;

    public async Task LogLoginAttemptAsync(string email, string ip, bool sucesso, string motivo = null)
    {
        var logAcesso = new LogAcesso
        {
            Email = email,
            DataHoraUTC = DateTime.UtcNow,
            EnderecoIP = ip,
            TipoDispositivo = _deviceService.DetectDevice().Type,
            IdentificadorDispositivo = _deviceService.DetectDevice().Id,
            TipoNavegador = _deviceService.DetectBrowser().Type,
            VersaoNavegador = _deviceService.DetectBrowser().Version,
            Pais = await _geoService.GetCountryAsync(ip),
            Estado = await _geoService.GetStateAsync(ip),
            Cidade = await _geoService.GetCityAsync(ip),
            Sucesso = sucesso,
            MotivoDaFalha = motivo,
            ClienteId = null // Preenchido após autenticação
        };

        await _auditRepository.AddAsync(logAcesso);
        await _auditRepository.SaveChangesAsync();

        // Enviar para SIEM se falha
        if (!sucesso)
            await SendToSiemAsync(logAcesso);
    }
}
```

**Exemplos**:
- ✓ Usuário joao@empresa.com tenta login às 10:30 UTC, IP 192.168.1.100, Windows 10, Chrome 120.0 → Registrado como sucesso
- ✗ Tentativa com senha incorreta → Registrada como falha, motivo "Senha incorreta"
- ✗ 5 tentativas falhadas do mesmo IP em 1 minuto → Registrados 5 logs + alerta de força bruta

---

### RN-SEC-095-02: Detecção de Força Bruta (Múltiplas Falhas de Login)

**Descrição**: Sistema deve detectar e alertar quando ocorrem 5 ou mais tentativas falhadas de login do mesmo IP nos últimos 15 minutos. Primeira detecção envia alerta para segurança. Ao 10º erro, IP é bloqueado automaticamente por 60 minutos. Bloqueio pode ser liberado manualmente ou aguardar expiração.

**Justificativa**: Prevenção de ataques de dicionário/força bruta, conformidade PCI-DSS 8.5.5 (bloqueio de conta após múltiplas tentativas).

**Implementação**:
```csharp
public class BruteForceDetectionService
{
    private const int FailureThreshold = 5;
    private const int LockoutThreshold = 10;
    private const int TimeWindowMinutes = 15;
    private const int LockoutDurationMinutes = 60;

    public async Task<(bool IsBlocked, string Reason)> CheckBruteForceAsync(string ip)
    {
        var failuresInWindow = await _auditRepository
            .Where(x => x.EnderecoIP == ip &&
                        !x.Sucesso &&
                        x.DataHoraUTC > DateTime.UtcNow.AddMinutes(-TimeWindowMinutes))
            .CountAsync();

        if (failuresInWindow >= LockoutThreshold)
            return (true, $"IP bloqueado por {LockoutDurationMinutes} minutos após {LockoutThreshold} tentativas falhadas");

        if (failuresInWindow == FailureThreshold)
        {
            await SendSecurityAlertAsync($"Alerta: {FailureThreshold} tentativas falhadas detectadas de IP {ip}");
        }

        return (false, null);
    }

    public async Task BlockIpAsync(string ip, int durationMinutes)
    {
        var bloqueio = new IpBloqueado
        {
            IP = ip,
            DataHoraInicio = DateTime.UtcNow,
            DataHoraFim = DateTime.UtcNow.AddMinutes(durationMinutes),
            Motivo = "Bloqueio automático por força bruta",
            Ativo = true
        };

        await _repository.AddAsync(bloqueio);
        await _repository.SaveChangesAsync();

        // Notificar SIEM
        await SendToSiemAsync($"IP {ip} bloqueado automaticamente");
    }
}
```

**Exemplos**:
- ✓ 3 falhas do IP 10.0.0.5 em 10 minutos → Registrados, sem alerta ainda
- ✗ 5ª falha do mesmo IP → Alerta enviado para segurança
- ✗ 10ª falha do mesmo IP → IP bloqueado por 60 minutos

---

### RN-SEC-095-03: Rastreamento de Ações de Usuário (CRUD + Operações Críticas)

**Descrição**: Todas as operações CRUD (Create, Read, Update, Delete) devem ser auditadas com registro de: usuário, timestamp UTC, entidade/tabela afetada, ação (CREATE/READ/UPDATE/DELETE), dados antes/depois (para UPDATE/DELETE), resultado (sucesso/erro), IP e ClienteId. Operações críticas (aprovações, mudanças de permissão, exclusão em lote) exigem registro adicional: motivo, aprovação (se necessária), dados de contexto.

**Justificativa**: Conformidade ISO 27001 A.12.4.1 (logging de atividades), SOX 404 (trilha de auditoria), LGPD Artigo 46 (reconstrução de ações).

**Implementação**:
```csharp
public class CrudAuditService
{
    private readonly IRepository<LogOperacao> _auditRepository;
    private readonly ICurrentUserService _currentUser;

    public async Task LogOperationAsync(
        string entidade,
        string acao, // CREATE, READ, UPDATE, DELETE
        object dadosAntes = null,
        object dadosDepois = null,
        bool sucesso = true,
        string motivo = null,
        string idEntidade = null)
    {
        var logOperacao = new LogOperacao
        {
            UsuarioId = _currentUser.UserId,
            Email = _currentUser.Email,
            DataHoraUTC = DateTime.UtcNow,
            Entidade = entidade,
            Acao = acao,
            DadosAntes = JsonConvert.SerializeObject(dadosAntes),
            DadosDepois = JsonConvert.SerializeObject(dadosDepois),
            Sucesso = sucesso,
            Motivo = motivo,
            EnderecoIP = _currentUser.IpAddress,
            ClienteId = _currentUser.ClienteId,
            IdEntidade = idEntidade
        };

        await _auditRepository.AddAsync(logOperacao);
        await _auditRepository.SaveChangesAsync();

        // Se operação crítica, enviar para SIEM
        if (IsOperacaoCritica(acao))
            await SendToSiemAsync(logOperacao);
    }

    private bool IsOperacaoCritica(string acao)
        => acao is "DELETE" or "APPROVE" or "UPDATE_PERMISSION";
}
```

**Exemplos**:
- ✓ Usuário joao@empresa.com cria Contrato com ID CT-2025-001 → Registrado: CREATE, dados da entidade, IP, timestamp
- ✗ Usuário tenta deletar 500 contatos em lote → Registrado: DELETE, ID dos contatos, IP, razão da operação
- ✗ Aprovação de despesa por maria@empresa.com → Registrado: APPROVE, valor antes/depois, motivo, timestamp

---

### RN-SEC-095-04: Validação Obrigatória de Segregação de Funções (SOD)

**Descrição**: Sistema deve validar em tempo real que nenhum usuário possua permissões conflitantes (ex: Criador e Aprovador da mesma entidade, Administrador de Sistema e Auditoria Interna). Conflitos devem ser automaticamente identificados no banco de dados (constraint) e impedidos na aplicação. Relatório mensal deve listar todas as violações de SOD pendentes de correção.

**Justificativa**: Conformidade ISO 27001 A.6.1.3 (segregação de funções), SOX 404 (controle interno), prevenção de fraudes, dual-control em operações críticas.

**Implementação**:
```csharp
public class SegregacaoFuncoesService
{
    private readonly IRepository<Permissao> _permissaoRepository;

    // Conflitos definidos por política de segurança
    private static readonly Dictionary<string, List<string>> ConflitosSOD = new()
    {
        { "audit:approval:create", new() { "audit:approval:approve" } },
        { "fin:invoice:create", new() { "fin:invoice:approve" } },
        { "sys:user:manage", new() { "audit:access:review" } }
    };

    public async Task<List<PermissaoConflitante>> ValidarSODAsync(string usuarioId, string permissaoNova)
    {
        var permissoesExistentes = await _permissaoRepository
            .Where(x => x.UsuarioId == usuarioId && x.Ativo)
            .Select(x => x.Codigo)
            .ToListAsync();

        var conflitos = new List<PermissaoConflitante>();

        if (ConflitosSOD.TryGetValue(permissaoNova, out var permissoesConflitantes))
        {
            var conflitosEncontrados = permissoesExistentes.Intersect(permissoesConflitantes).ToList();
            if (conflitosEncontrados.Any())
            {
                foreach (var conflito in conflitosEncontrados)
                {
                    conflitos.Add(new PermissaoConflitante
                    {
                        PermissaoNova = permissaoNova,
                        PermissaoExistente = conflito,
                        Motivo = "Violação de SOD detectada"
                    });
                }
            }
        }

        return conflitos;
    }

    public async Task<bool> AtribuirPermissaoComValidacaoAsync(string usuarioId, string permissao)
    {
        var conflitos = await ValidarSODAsync(usuarioId, permissao);
        if (conflitos.Any())
        {
            throw new InvalidOperationException(
                $"Não é permitido atribuir {permissao} devido a conflito de SOD: {string.Join(", ", conflitos.Select(c => c.PermissaoExistente))}");
        }

        // Prosseguir com atribuição
        await _permissaoRepository.AddAsync(new Permissao { UsuarioId = usuarioId, Codigo = permissao });
        await _permissaoRepository.SaveChangesAsync();

        return true;
    }
}
```

**Exemplos**:
- ✗ Tentar atribuir "audit:approval:approve" a usuário que já tem "audit:approval:create" → Bloqueado com erro SOD
- ✓ Atribuir "view:reports" a usuário com "edit:reports" → Permitido (não há conflito)
- ✗ Relatório mensal identifica 3 usuários com violações → Alerta gerado para remediação

---

### RN-SEC-095-05: Acessos Privilegiados com Just-In-Time (JIT)

**Descrição**: Usuários com permissões elevadas (admin, root, superuser) devem utilizar JIT: concessão temporária de privilégios por período limitado (máximo 4 horas). Cada elevação requer aprovação explícita de outro admin. Sistema registra: quem solicitou, quem aprovou, duração, timestamp início/fim, e todas as ações executadas com privilégio elevado. Automaticamente revoga privilégio ao expirar tempo.

**Justificativa**: Conformidade LGPD (princípio de minimização), ISO 27001 A.9.2.1 (acesso privilegiado), SOX 404 (rastreamento de ações críticas), PCI-DSS 8.2.4 (revogação de acesso).

**Implementação**:
```csharp
public class JitPrivilegeService
{
    private const int MaxDurationHours = 4;

    public async Task<ElevacaoPrivilegio> RequestElevationAsync(
        string usuarioId,
        string justificativa,
        int durationMinutes = 30)
    {
        if (durationMinutes > MaxDurationHours * 60)
            throw new ArgumentException($"Duração máxima é {MaxDurationHours} horas");

        var solicitacao = new ElevacaoPrivilegio
        {
            UsuarioIdSolicitante = usuarioId,
            DataHoraRequisicao = DateTime.UtcNow,
            Justificativa = justificativa,
            DuracaoMinutos = durationMinutes,
            Status = "Pendente",
            DataHoraAprovacao = null,
            UsuarioIdAprovador = null
        };

        await _repository.AddAsync(solicitacao);
        await _repository.SaveChangesAsync();

        // Notificar outros admins para aprovação
        await NotifyOtherAdminsAsync(solicitacao);

        return solicitacao;
    }

    public async Task<bool> ApproveElevationAsync(string solicitacaoId, string usuarioIdAprovador)
    {
        var solicitacao = await _repository.FindAsync(solicitacaoId);

        if (usuarioIdAprovador == solicitacao.UsuarioIdSolicitante)
            throw new InvalidOperationException("Não pode autoaprovar elevação de privilégio");

        solicitacao.DataHoraAprovacao = DateTime.UtcNow;
        solicitacao.UsuarioIdAprovador = usuarioIdAprovador;
        solicitacao.Status = "Aprovado";
        solicitacao.DataHoraExpiracao = DateTime.UtcNow.AddMinutes(solicitacao.DuracaoMinutos);

        await _repository.SaveChangesAsync();

        // Registrar em auditoria e SIEM
        await LogPrivilegeElevationAsync(solicitacao);

        return true;
    }

    public async Task RevokeExpiredElevationsAsync()
    {
        var elevacoes = await _repository
            .Where(x => x.Status == "Aprovado" && x.DataHoraExpiracao < DateTime.UtcNow)
            .ToListAsync();

        foreach (var elevacao in elevacoes)
        {
            elevacao.Status = "Expirado";
            await _repository.SaveChangesAsync();

            // Log de revogação
            await LogPrivilegeRevocationAsync(elevacao);
        }
    }
}
```

**Exemplos**:
- ✓ Admin solicita elevação por 30 minutos para "corrigir bug crítico" → Aguardando aprovação de outro admin
- ✓ Admin B aprova em 2 minutos → Privilégio elevado até 30 min depois
- ✗ Tempo expira → Privilégio revogado automaticamente, todas as ações registradas em auditoria

---

### RN-SEC-095-06: Certificação Trimestral de Acessos

**Descrição**: A cada trimestre, sistema gera workflow automático onde gerentes revisam e certificam as permissões de seus subordinados. Para cada subordinado, gerente vê lista de permissões, pode aprovar (confirma acesso necessário), rejeitar (marcado para remoção) ou solicitar dados adicionais. Dados rejeitados são automaticamente revogados em 72 horas. Relatório de não-resposta gera alert para escalação. Histórico de certificação é mantido para auditoria.

**Justificativa**: Conformidade ISO 27001 A.6.2.1 (revisão de acesso), LGPD Artigo 6 (legitimidade), SOX 404 (avaliação de controle).

**Implementação**:
```csharp
public class CertificacaoAccessoService
{
    public async Task<CertificacaoTrimestral> IniciarCertificacaoTrimestraAsync()
    {
        var trimestre = GetCurrentTrimeestre();
        var ano = DateTime.Now.Year;

        var certificacao = new CertificacaoTrimestral
        {
            Trimestre = trimestre,
            Ano = ano,
            DataInicio = DateTime.UtcNow,
            DataLimite = DateTime.UtcNow.AddDays(30), // 30 dias para concluir
            Status = "Iniciada"
        };

        await _repository.AddAsync(certificacao);

        // Gerar tarefas de revisão para cada gerente
        var gerentes = await _userRepository
            .Where(x => x.Perfil == "Gerente" && x.Ativo)
            .ToListAsync();

        foreach (var gerente in gerentes)
        {
            var subordinados = await _userRepository
                .Where(x => x.GerentiId == gerente.Id && x.Ativo)
                .ToListAsync();

            foreach (var subordinado in subordinados)
            {
                var tarefa = new TarefaCertificacao
                {
                    CertificacaoId = certificacao.Id,
                    GerentiId = gerente.Id,
                    SubordinadoId = subordinado.Id,
                    Status = "Pendente",
                    DataCriacao = DateTime.UtcNow
                };

                await _repository.AddAsync(tarefa);
            }
        }

        await _repository.SaveChangesAsync();
        return certificacao;
    }

    public async Task<bool> CertificarPermissoesAsync(
        string tarefaCertificacaoId,
        List<(string PermissaoId, string Decisao, string Motivo)> decisoes)
    {
        var tarefa = await _repository.FindAsync(tarefaCertificacaoId);
        var permissoes = await _permissaoRepository
            .Where(x => x.UsuarioId == tarefa.SubordinadoId)
            .ToListAsync();

        foreach (var (permId, decisao, motivo) in decisoes)
        {
            var permissao = permissoes.FirstOrDefault(x => x.Id == permId);
            if (permissao == null) continue;

            var certificacao = new RegistroCertificacao
            {
                PermissaoId = permId,
                TarefaCertificacaoId = tarefaCertificacaoId,
                Decisao = decisao, // "Aprovado" ou "Rejeitado"
                Motivo = motivo,
                DataDecisao = DateTime.UtcNow
            };

            await _repository.AddAsync(certificacao);

            if (decisao == "Rejeitado")
            {
                // Agendar revogação em 72 horas
                permissao.DataRevogacaoAgendada = DateTime.UtcNow.AddHours(72);
                permissao.MotivoDaRevogacao = $"Rejeitado em certificação trimestral: {motivo}";
            }
        }

        tarefa.Status = "Certificado";
        tarefa.DataCertificacao = DateTime.UtcNow;

        await _repository.SaveChangesAsync();
        return true;
    }
}
```

**Exemplos**:
- ✓ Gerente João revisa 12 permissões de subordinado → Aprova 10, rejeita 2
- ✗ 2 permissões rejeitadas marcadas para revogação em 72 horas
- ✗ Gerente não responde até data limite → Alerta escalado para seu gestor e área de segurança

---

### RN-SEC-095-07: Detecção de Comportamentos Anômalos (UEBA)

**Descrição**: Sistema implementa User and Entity Behavior Analytics via Hangfire (processamento batch diário) e Azure ML (modelo preditivo). Analisa padrões normais: hora do dia, dias da semana, volume de requisições, tipos de acesso, localizações geográficas frequentes. Detecta desvios: acesso fora do horário comercial, volume 10x acima da média, acesso de país diferente em <1h, tentativas de acesso a dados fora do perfil. Anomalias geram alertas para SOC (Security Operations Center) com score de confiança.

**Justificativa**: Prevenção de comprometimento de conta, detecção de insider threats, conformidade PCI-DSS 12.3.10 (anomalia behavior).

**Implementação**:
```csharp
public class UebaAnalysisService
{
    private readonly IAzureMLService _mlService;
    private readonly IRepository<LogOperacao> _auditRepository;

    public async Task<AnomaliaDeteccao> AnalysarComportamentoAsync(string usuarioId)
    {
        // Coletar dados históricos (últimos 90 dias)
        var historico = await _auditRepository
            .Where(x => x.UsuarioId == usuarioId &&
                        x.DataHoraUTC > DateTime.UtcNow.AddDays(-90))
            .ToListAsync();

        if (historico.Count < 10)
            return null; // Dados insuficientes para análise

        // Calcular padrão normal
        var padraoNormal = CalcularPadraoNormal(historico);

        // Comportamentos recentes (últimas 24h)
        var comportamentosRecentes = historico
            .Where(x => x.DataHoraUTC > DateTime.UtcNow.AddHours(-24))
            .ToList();

        var anomalias = new List<Anomalia>();

        foreach (var comportamento in comportamentosRecentes)
        {
            // Verificar desvios
            if (!EstaNoHorarioNormal(comportamento, padraoNormal))
            {
                anomalias.Add(new Anomalia
                {
                    Tipo = "Horário incomum",
                    Score = 0.6f,
                    Detalhes = $"Acesso às {comportamento.DataHoraUTC.Hour}h (normal: {padraoNormal.HorarioPico}h)"
                });
            }

            if (!EstaGeolocalizacaoEsperada(comportamento, padraoNormal))
            {
                anomalias.Add(new Anomalia
                {
                    Tipo = "Geolocalização suspeita",
                    Score = 0.8f,
                    Detalhes = $"Acesso de {comportamento.Pais} (normal: {padraoNormal.PaisFrequente})"
                });
            }

            if (IsVolumeExcessivo(comportamento, padraoNormal))
            {
                anomalias.Add(new Anomalia
                {
                    Tipo = "Volume de requisições excessivo",
                    Score = 0.7f,
                    Detalhes = $"{comportamento.QuantidadeOperacoes} ops (normal: {padraoNormal.MediaOperacoesPorHora})"
                });
            }
        }

        // Usar ML para refinamento
        if (anomalias.Any())
        {
            var scoreML = await _mlService.PredictAnomalyAsync(usuarioId, anomalias);
            return new AnomaliaDeteccao
            {
                UsuarioId = usuarioId,
                Anomalias = anomalias,
                ScoreConfianca = scoreML,
                DataDeteccao = DateTime.UtcNow,
                Status = scoreML > 0.8f ? "Alto Risco" : "Médio Risco"
            };
        }

        return null;
    }
}
```

**Exemplos**:
- ✓ Padrão normal: João acessa de São Paulo, 09:00-18:00, ~50 operações/dia
- ✗ Anomalia detectada: acesso de Hong Kong às 02:00, 500 operações em 30 minutos → Score 0.95 → Alerta crítico enviado ao SOC
- ✗ Comportamento anômalo: Maria tenta acessar dados de RH (fora de seu perfil como Dev) → Score 0.75 → Alerta investigado

---

### RN-SEC-095-08: Integração com Política de Segurança

**Descrição**: Sistema lê automaticamente da tabela de Política de Segurança: bloqueio de IPs (whitelist/blacklist), requisitos de senha (min. 12 caracteres, complexidade, expiração a cada 90 dias), MFA obrigatório para determinados perfis, restrição de horário de acesso (ex: admin só durante comercial), restrição de localização geográfica. Sistema aplica políticas em tempo real de login e levanta exceções quando violações ocorrem.

**Justificativa**: Centralização de regras de segurança, conformidade PCI-DSS (requisitos de senha), ISO 27001 A.9.4.2 (acesso baseado em política).

**Implementação**:
```csharp
public class PoliticaSegurancaService
{
    private readonly IRepository<PoliticaSeguranca> _politicaRepository;
    private readonly ICache _cache;

    public async Task<(bool Permitido, string Motivo)> ValidarLoginComtraPoliticaAsync(
        string email,
        string ip,
        string pais,
        string hora)
    {
        var politica = await _cache.GetOrSetAsync(
            "politica_seguranca",
            async () => await _politicaRepository.FirstOrDefaultAsync(),
            TimeSpan.FromHours(1)
        );

        if (politica == null)
            throw new InvalidOperationException("Política de segurança não configurada");

        // Verificar IP bloqueado
        if (politica.IpsBloqueados.Contains(ip))
            return (false, $"IP {ip} está na lista negra de segurança");

        // Verificar MFA obrigatório
        var usuario = await _userRepository.FirstOrDefaultAsync(x => x.Email == email);
        if (politica.MFAObrigatorios.Contains(usuario.Perfil) && !usuario.MfaHabilitado)
            return (false, "MFA é obrigatório para seu perfil. Habilite em configurações.");

        // Verificar restrição de horário
        if (usuario.Perfil == "Admin" && !EstaEmHorarioComercial(hora))
            return (false, "Admins podem acessar apenas em horário comercial (09:00-18:00)");

        // Verificar restrição geográfica
        if (politica.PaisesPermitidos != null && !politica.PaisesPermitidos.Contains(pais))
            return (false, $"Acesso de {pais} não permitido por política de segurança");

        return (true, null);
    }

    public async Task<bool> AplicarRequisitoDeSenhaAsync(string usuarioId, string novaSenha)
    {
        var politica = await _cache.GetOrSetAsync("politica_seguranca", /* ... */);

        if (novaSenha.Length < politica.MinimaSenhaLength)
            throw new ValidationException($"Senha deve ter no mínimo {politica.MinimaSenhaLength} caracteres");

        if (politica.RequerNumeros && !novaSenha.Any(char.IsDigit))
            throw new ValidationException("Senha deve conter pelo menos um número");

        if (politica.RequerEspeciais && !novaSenha.Any(c => "!@#$%^&*".Contains(c)))
            throw new ValidationException("Senha deve conter caracteres especiais");

        return true;
    }
}
```

**Exemplos**:
- ✓ IP 203.0.113.42 na whitelist → Login permitido
- ✗ IP 192.0.2.100 na blacklist → Bloqueado com mensagem
- ✗ Perfil Admin tentando acessar às 22:00 → Bloqueado ("Acesso fora do horário comercial")

---

### RN-SEC-095-09: Correlação de Eventos para Investigação Forense

**Descrição**: Cada log possui ID de correlação (CorrelationId) que agrupa eventos relacionados (ex: login → acesso a dados → export → mudança de permissão). Sistema permite ao investigador traçar timeline completa de um incidente. Endpoints de investigação retornam: sequência de eventos, timestamps, IPs, usuários, dados alterados, e decisões tomadas. Exportação forense gera arquivo CSV estruturado para análise em ferramentas externas (Splunk, ELK).

**Justificativa**: Conformidade LGPD Artigo 46 (reconstrução de ações), ISO 27001 A.12.4.3 (registros detalhados), SOX 404 (trilha de auditoria).

**Implementação**:
```csharp
public class InvestigacaoForenseService
{
    private readonly IRepository<LogAcesso> _logAccessoRepository;
    private readonly IRepository<LogOperacao> _logOperacaoRepository;

    public async Task<RelatorioForense> InvestigarIncidenteAsync(
        string incidenteId,
        DateTime dataInicio,
        DateTime dataFim)
    {
        // Buscar todos os eventos no período
        var logs = new List<LogBase>();

        var logAcessos = await _logAccessoRepository
            .Where(x => x.DataHoraUTC >= dataInicio && x.DataHoraUTC <= dataFim)
            .OrderBy(x => x.DataHoraUTC)
            .ToListAsync();

        var logOperacoes = await _logOperacaoRepository
            .Where(x => x.DataHoraUTC >= dataInicio && x.DataHoraUTC <= dataFim)
            .OrderBy(x => x.DataHoraUTC)
            .ToListAsync();

        logs.AddRange(logAcessos);
        logs.AddRange(logOperacoes);

        // Correlacionar eventos
        var timeline = new List<EventoTimeline>();
        var usuariosEnvolvidos = new HashSet<string>();
        var ipsEnvolvidos = new HashSet<string>();

        foreach (var log in logs.OrderBy(x => x.DataHoraUTC))
        {
            timeline.Add(new EventoTimeline
            {
                DataHora = log.DataHoraUTC,
                Tipo = log.GetType().Name,
                Usuario = log is LogAcesso la ? la.Email : (log as LogOperacao).Email,
                Acao = log is LogOperacao lo ? lo.Acao : "LOGIN",
                Detalhes = log.ToString(),
                ResultadoSucesso = (log as dynamic).Sucesso ?? true
            });

            if (log is LogAcesso la2)
            {
                usuariosEnvolvidos.Add(la2.Email);
                ipsEnvolvidos.Add(la2.EnderecoIP);
            }
            else if (log is LogOperacao lo2)
            {
                usuariosEnvolvidos.Add(lo2.Email);
                ipsEnvolvidos.Add(lo2.EnderecoIP);
            }
        }

        var relatorio = new RelatorioForense
        {
            IncidenteId = incidenteId,
            DataInicio = dataInicio,
            DataFim = dataFim,
            Timeline = timeline,
            UsuariosEnvolvidos = usuariosEnvolvidos.ToList(),
            IpsEnvolvidos = ipsEnvolvidos.ToList(),
            TotalEventos = timeline.Count,
            DataRelatorio = DateTime.UtcNow
        };

        return relatorio;
    }

    public async Task<Stream> ExportarRelatorioForenseAsync(RelatorioForense relatorio)
    {
        using (var memoryStream = new MemoryStream())
        using (var writer = new StreamWriter(memoryStream))
        using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
        {
            csv.WriteField("DataHora");
            csv.WriteField("Tipo");
            csv.WriteField("Usuario");
            csv.WriteField("Acao");
            csv.WriteField("Resultado");
            csv.WriteField("Detalhes");
            csv.NextRecord();

            foreach (var evento in relatorio.Timeline)
            {
                csv.WriteField(evento.DataHora);
                csv.WriteField(evento.Tipo);
                csv.WriteField(evento.Usuario);
                csv.WriteField(evento.Acao);
                csv.WriteField(evento.ResultadoSucesso ? "Sucesso" : "Falha");
                csv.WriteField(evento.Detalhes);
                csv.NextRecord();
            }

            writer.Flush();
            memoryStream.Position = 0;
            return memoryStream;
        }
    }
}
```

**Exemplos**:
- ✓ Investigar período 2025-01-10 10:00 a 2025-01-10 15:00 → Timeline com 42 eventos: login, 8 acessos, 3 mudanças de dados, 1 export
- ✓ Exportar relatório forense → Arquivo CSV com todos os eventos para análise em Splunk
- ✗ Correlação identifica: João fez login → Acessou 50 registros de RH → Exportou dados → Tudo em 45 minutos

---

### RN-SEC-095-10: Alertas Automáticos em Tempo Real

**Descrição**: Sistema gera alertas automáticos e envia notificações instantâneas para Security Operations Center (SOC) quando eventos críticos são detectados: múltiplas falhas de login (≥5 em 15 min), IP suspeito (novo IP, país diferente), acesso a dado sensível não autorizado, alteração de permissão de usuário, exclusão em lote, acessos privilegiados fora do horário, comportamento anômalo (UEBA score > 0.8). Cada alerta inclui: timestamp, usuário, entidade afetada, score de risco (1-10), recomendação de ação, link para investigação forense.

**Justificativa**: Detecção tempestiva de incidentes, conformidade PCI-DSS 10.6 (alertas de segurança), ISO 27001 A.12.4.5 (monitoramento de segurança).

**Implementação**:
```csharp
public class AlertaSegurancaService
{
    private readonly INotificationService _notificationService;
    private readonly IRepository<AlertaSeguranca> _alertaRepository;

    public async Task GerarAlertaAsync(string tipo, Dictionary<string, object> contexto, int scoreRisco)
    {
        var alerta = new AlertaSeguranca
        {
            Tipo = tipo,
            Contexto = JsonConvert.SerializeObject(contexto),
            ScoreRisco = scoreRisco,
            DataHora = DateTime.UtcNow,
            Status = "Novo",
            Acao = DeterminarAcaoRecomendada(tipo, scoreRisco)
        };

        await _alertaRepository.AddAsync(alerta);
        await _alertaRepository.SaveChangesAsync();

        // Notificar SOC
        var tipoNotificacao = scoreRisco >= 8 ? "Crítico" : scoreRisco >= 5 ? "Alto" : "Médio";
        await _notificationService.SendToSOCAsync(alerta, tipoNotificacao);

        // Enviar para SIEM
        await SendToSiemAsync(alerta);
    }

    public async Task ProcessarMultiplasFailurasAsync(string ip)
    {
        var falhasRecentes = await _logAccessoRepository
            .Where(x => x.EnderecoIP == ip &&
                        !x.Sucesso &&
                        x.DataHoraUTC > DateTime.UtcNow.AddMinutes(-15))
            .CountAsync();

        if (falhasRecentes >= 5)
        {
            await GerarAlertaAsync(
                "ForcaBruta",
                new() { { "IP", ip }, { "Falhas", falhasRecentes } },
                scoreRisco: 9
            );
        }
    }

    public async Task ProcessarAcessoDadoSensitelAsync(string usuarioId, string entidadeSensivel)
    {
        var usuario = await _userRepository.FindAsync(usuarioId);
        var temPermissao = await _permissaoRepository.AnyAsync(
            x => x.UsuarioId == usuarioId && x.Codigo.Contains(entidadeSensivel));

        if (!temPermissao)
        {
            await GerarAlertaAsync(
                "AcessoNaoAutorizado",
                new()
                {
                    { "Usuario", usuario.Email },
                    { "Entidade", entidadeSensivel },
                    { "Timestamp", DateTime.UtcNow }
                },
                scoreRisco: 10
            );
        }
    }
}
```

**Exemplos**:
- ✗ 7 falhas de login do IP 203.0.113.50 em 10 minutos → Alerta crítico (score 9) gerado, SOC notificado
- ✗ João (Dev) tenta acessar dados de Folha de Pagamento → Alerta crítico (score 10), bloqueio imediato
- ✗ Admin faz 300 operações DELETE em 5 minutos → Alerta alto (score 8), recomendação: validar integridade de dados

---

### RN-SEC-095-11: Retenção de Logs (10 Anos Conforme Compliance)

**Descrição**: Logs são armazenados em camadas conforme idade: logs dos últimos 90 dias em hot storage (Azure SQL Database, rápido acesso), logs de 90 dias a 1 ano em warm storage (Azure Blob, custo moderado), logs > 1 ano em cold storage (Archive, menor custo). Sistema mantém índices para busca rápida (últimos 90 dias). Retenção total é 10 anos (conforme LGPD, ISO 27001, SOX 404). Criptografia AES-256 em repouso. Backup diário, replicação geo-redundante.

**Justificativa**: Conformidade LGPD Artigo 16 (direito de apagamento após fim de utilidade, com exceção de conformidade legal), ISO 27001 A.12.3.1 (backup), SOX 404 (documentação auditável).

**Implementação**:
```csharp
public class RetencaoLogsService
{
    private const int HotStorageDays = 90;
    private const int WarmStorageDays = 365;
    private const int TotalRetentionYears = 10;

    public async Task ArchiveLogsAsync()
    {
        var dataLimiteHot = DateTime.UtcNow.AddDays(-HotStorageDays);
        var dataLimiteWarm = DateTime.UtcNow.AddDays(-WarmStorageDays);

        // Mover de hot para warm storage
        var logsParaWarm = await _logRepository
            .Where(x => x.DataHoraUTC <= dataLimiteHot &&
                        x.TipoArmazenamento == "Hot")
            .ToListAsync();

        foreach (var log in logsParaWarm)
        {
            await _blobService.UploadLogAsync(log, containerName: "logs-warm");
            log.TipoArmazenamento = "Warm";
            log.AzureBlobUri = _blobService.GetUri(log.Id);
        }

        await _logRepository.SaveChangesAsync();

        // Mover de warm para cold storage
        var logsParaCold = await _logRepository
            .Where(x => x.DataHoraUTC <= dataLimiteWarm &&
                        x.TipoArmazenamento == "Warm")
            .ToListAsync();

        foreach (var log in logsParaCold)
        {
            await _blobService.UploadLogAsync(log, containerName: "logs-cold", tier: "Archive");
            log.TipoArmazenamento = "Cold";
            log.AzureBlobUri = _blobService.GetUri(log.Id);
        }

        await _logRepository.SaveChangesAsync();
    }

    public async Task DeleteExpiredLogsAsync()
    {
        var dataLimiteDelecao = DateTime.UtcNow.AddYears(-TotalRetentionYears);

        var logsParaDeletar = await _logRepository
            .Where(x => x.DataHoraUTC <= dataLimiteDelecao)
            .ToListAsync();

        // Criar backup antes de deletar
        foreach (var log in logsParaDeletar)
        {
            await _blobService.UploadLogAsync(log, containerName: "logs-deleted-backup");
        }

        _logRepository.RemoveRange(logsParaDeletar);
        await _logRepository.SaveChangesAsync();

        // Registrar deleção em auditoria de conformidade
        await LogConformanceActionAsync($"Deletados {logsParaDeletar.Count} logs com >10 anos");
    }

    public async Task<Stream> RetrieveLogFromStorageAsync(string logId)
    {
        var log = await _logRepository.FindAsync(logId);
        if (log == null)
            throw new InvalidOperationException("Log não encontrado");

        if (log.TipoArmazenamento == "Hot")
            return await _logRepository.RetrieveRawAsync(logId);

        if (log.TipoArmazenamento == "Warm" || log.TipoArmazenamento == "Cold")
            return await _blobService.DownloadLogAsync(log.AzureBlobUri);

        throw new InvalidOperationException("Armazenamento desconhecido");
    }
}
```

**Exemplos**:
- ✓ Log de 2025-01-01 (91 dias atrás) movido de hot para warm storage automaticamente
- ✓ Log de 2024-01-01 (365+ dias atrás) movido de warm para cold storage
- ✗ Log anterior a 2015-12-28 elegível para deleção, mas backup preservado por 5 anos adicionais

---

### RN-SEC-095-12: Dashboard de Segurança em Tempo Real

**Descrição**: Dashboard exibe em tempo real: tentativas de login (sucesso/falha nas últimas 24h), usuários online agora, acessos a dados sensíveis hoje, alertas de segurança pendentes (críticos em topo), eventos de auditoria recentes, gráficos de atividade por hora/dia/semana. Filtros por usuário, IP, entidade, tipo de ação. Dados são atualizados a cada 5 minutos. Dashboard é acessível apenas para perfis de Segurança/Auditoria.

**Justificativa**: Visibilidade de segurança operacional, detecção rápida de incidentes.

**Implementação**:
```csharp
public class DashboardSegurancaService
{
    public async Task<DashboardSegurancaDto> GetDashboardAsync()
    {
        var agora = DateTime.UtcNow;
        var hoje = agora.Date;
        var ultimas24h = agora.AddHours(-24);

        var loginsSucesso = await _logAccessoRepository
            .Where(x => x.DataHoraUTC >= ultimas24h && x.Sucesso)
            .CountAsync();

        var loginsFailidos = await _logAccessoRepository
            .Where(x => x.DataHoraUTC >= ultimas24h && !x.Sucesso)
            .CountAsync();

        var usuariosOnline = await _logAccessoRepository
            .Where(x => x.DataHoraUTC >= agora.AddMinutes(-30) && x.Sucesso)
            .Select(x => x.Email)
            .Distinct()
            .CountAsync();

        var alertasEmAberto = await _alertaRepository
            .Where(x => x.Status != "Resolvido")
            .OrderByDescending(x => x.ScoreRisco)
            .Take(10)
            .ToListAsync();

        var eventosRecentes = await _logOperacaoRepository
            .Where(x => x.DataHoraUTC >= agora.AddMinutes(-60))
            .OrderByDescending(x => x.DataHoraUTC)
            .Take(20)
            .ToListAsync();

        return new DashboardSegurancaDto
        {
            LoginsSucesso = loginsSucesso,
            LoginsFailidos = loginsFailidos,
            UsuariosOnlineAgora = usuariosOnline,
            AlertasEmAberto = alertasEmAberto,
            EventosRecentes = eventosRecentes,
            TaxaFalha24h = (double)loginsFailidos / (loginsSucesso + loginsFailidos),
            DataAtualizacao = agora
        };
    }
}
```

**Exemplos**:
- ✓ Dashboard mostra: 450 logins bem-sucedidos, 12 falhados, 38 usuários online, 3 alertas críticos
- ✓ Filtrar por IP 203.0.113.50 → Mostra 15 tentativas falhadas, 1 alerta de força bruta
- ✓ Filtrar por entidade "Folha de Pagamento" → Mostra 3 acessos hoje (09:30, 14:15, 16:45)

---

## 3. REFERÊNCIAS AO LEGADO

### 3.1 Banco de Dados Legado

**Banco**: `ic1_legado` (SQL Server 2008 R2)

**Tabelas Principais**:

```sql
-- Tabela de auditoria de acesso (pode estar fragmentada)
CREATE TABLE [dbo].[TB_LOG_ACESSO](
    [ID_LOG] [int] IDENTITY(1,1) NOT NULL,
    [DT_ACESSO] [datetime] NOT NULL,
    [ID_USUARIO] [int] NOT NULL,
    [NM_USUARIO] [varchar](100) NOT NULL,
    [TP_ACESSO] [varchar](20) NOT NULL, -- 'LOGIN_SUCESSO', 'LOGIN_FALHA', 'LOGOUT'
    [TP_DISPOSITIVO] [varchar](50) NULL, -- 'DESKTOP', 'MOBILE', 'TABLET'
    [ENDERECO_IP] [varchar](15) NOT NULL,
    [MOTIVO_FALHA] [varchar](255) NULL,
    CONSTRAINT [PK_TB_LOG_ACESSO] PRIMARY KEY CLUSTERED ([ID_LOG] ASC)
);

-- Tabela de log de operações
CREATE TABLE [dbo].[TB_LOG_OPERACAO](
    [ID_LOG_OP] [int] IDENTITY(1,1) NOT NULL,
    [DT_OPERACAO] [datetime] NOT NULL,
    [ID_USUARIO] [int] NOT NULL,
    [TP_OPERACAO] [varchar](10) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    [NM_TABELA] [varchar](50) NOT NULL,
    [ID_ENTIDADE] [int] NOT NULL,
    [VALOR_ANTERIOR] [text] NULL,
    [VALOR_NOVO] [text] NULL,
    CONSTRAINT [PK_TB_LOG_OPERACAO] PRIMARY KEY CLUSTERED ([ID_LOG_OP] ASC)
);

-- Tabela de políticas de segurança (possível)
CREATE TABLE [dbo].[TB_POLITICA_SEGURANCA](
    [ID_POLITICA] [int] IDENTITY(1,1) NOT NULL,
    [DESCRICAO] [varchar](255) NOT NULL,
    [DT_CRIACAO] [datetime] NOT NULL,
    [FL_ATIVA] [bit] NOT NULL,
    CONSTRAINT [PK_TB_POLITICA_SEGURANCA] PRIMARY KEY CLUSTERED ([ID_POLITICA] ASC)
);

-- Tabela de permissões de usuário
CREATE TABLE [dbo].[TB_PERMISSAO_USUARIO](
    [ID_PERMISSAO] [int] IDENTITY(1,1) NOT NULL,
    [ID_USUARIO] [int] NOT NULL,
    [CD_PERMISSAO] [varchar](100) NOT NULL,
    [DT_ATRIBUICAO] [datetime] NOT NULL,
    [DT_VENCIMENTO] [datetime] NULL,
    CONSTRAINT [PK_TB_PERMISSAO_USUARIO] PRIMARY KEY CLUSTERED ([ID_PERMISSAO] ASC)
);
```

**Campos Importantes**:

| Campo Legado | Descrição | Uso no Modernizado |
|--------------|-----------|-------------------|
| `DT_ACESSO` / `DT_OPERACAO` | Timestamp do evento | Mapear para `DataHoraUTC` (ISO 8601) |
| `NM_USUARIO` | Nome do usuário | Mapear para `Email` (padrão moderno) |
| `ENDERECO_IP` | IP do cliente | Manter em `EnderecoIP`, adicionar geolocalização |
| `TP_ACESSO` / `TP_OPERACAO` | Tipo de ação | Padronizar nomenclatura (CREATE, READ, UPDATE, DELETE) |
| `VALOR_ANTERIOR` / `VALOR_NOVO` | Dados antes/depois | Estruturar como JSON em `DadosAntes` / `DadosDepois` |
| `FL_ATIVA` | Status booleano | Mapear para `Ativo` (bit → boolean) |

### 3.2 Stored Procedures Legado

| Procedure | Descrição | Migração |
|-----------|-----------|----------|
| `sp_GetLoginHistory` | Retorna histórico de login | Migrar para Entity Framework + LINQ queries |
| `sp_ValidarPermissao` | Valida se usuário tem permissão | Migrar para RBAC (Role-Based Access Control) moderno |
| `sp_GerarRelatorioAuditoria` | Gera relatório em Crystal Reports | Migrar para API REST + dashboard dinâmico Angular |
| `sp_LogarOperacao` | Insere log de operação | Migrar para service de auditoria automático (Aspect-Oriented Programming) |
| `sp_BloquearIP` | Bloqueia IP manualmente | Migrar para serviço automático de detecção e bloqueio |

### 3.3 Telas ASPX

| Página | Descrição | Tela Moderna |
|--------|-----------|--------------|
| `AuditoriaAcesso.aspx` | Visualização de logs de acesso | `/dashboard/security/access-logs` (Angular) |
| `RelatorioAuditoria.aspx` | Relatório de auditoria em Crystal | `/reports/audit` (dinâmico, filtrável) |
| `GestaoPermissoes.aspx` | Gestão de permissões de usuário | `/admin/security/permissions` (RBAC integrado) |
| `PoliticaSeguranca.aspx` | Configuração de políticas | `/admin/security/policies` |

### 3.4 WebServices Legado (VB.NET)

**Arquivo**: `D:\IC2\ic1_legado\WebService\WSAuditoria.asmx.vb`

| Método | Descrição | Endpoint Moderno |
|--------|-----------|-----------------|
| `GetLoginHistory(DataInicio, DataFim)` | Retorna logs de login | `GET /api/audit/access-logs?from=YYYY-MM-DD&to=YYYY-MM-DD` |
| `ValidarPermissao(UsuarioId, Permissao)` | Valida permissão | `GET /api/auth/validate-permission?permission=[CODE]` |
| `GerarRelatorio(Tipo, DataInicio, DataFim)` | Gera relatório | `POST /api/reports/audit/generate` |
| `LogarOperacao(Entidade, Acao, Dados)` | Registra operação | Automático via middleware de auditoria |

---

## 4. INTEGRAÇÕES OBRIGATÓRIAS

### 4.1 Central de Funcionalidades (Feature Flags)

**FeatureKey**: `AUDIT_SECURITY`

**Configuração**:
```json
{
    "featureKey": "AUDIT_SECURITY",
    "nome": "Auditoria de Acesso e Segurança",
    "descricao": "Ativa logging, detecção de anomalias, dashboard de segurança e alertas",
    "habilitado": true,
    "isSystemFeature": true,
    "subFeatures": [
        {
            "featureKey": "AUDIT_SECURITY_UEBA",
            "nome": "Detecção de Anomalias (UEBA)",
            "descricao": "Análise comportamental de usuários",
            "habilitado": true
        },
        {
            "featureKey": "AUDIT_SECURITY_SIEM_INTEGRATION",
            "nome": "Integração com SIEM",
            "descricao": "Envio automático de logs para Azure Sentinel",
            "habilitado": true
        },
        {
            "featureKey": "AUDIT_SECURITY_JIT_PRIVILEGE",
            "nome": "Just-In-Time Privilege",
            "descricao": "Concessão temporária de privilégios",
            "habilitado": true
        }
    ]
}
```

**Nota**: Feature é obrigatória (isSystemFeature = true). Desabilitação requer aprovação de segurança.

---

### 4.2 Internacionalização (i18n)

**Chaves de Tradução**:

```json
{
    "audit": {
        "security": {
            "title": "Auditoria de Acesso e Segurança",
            "sidebar": "Segurança",
            "form": {
                "loginAttempts": "Tentativas de Login",
                "userActions": "Ações de Usuários",
                "anomalies": "Anomalias Detectadas",
                "ipAddress": "Endereço IP",
                "timestamp": "Data/Hora",
                "result": "Resultado",
                "successfulLogins": "Logins Bem-Sucedidos",
                "failedLogins": "Logins Falhados",
                "failureReason": "Motivo da Falha",
                "geolocation": "Geolocalização",
                "device": "Dispositivo",
                "browser": "Navegador",
                "jitRequest": "Solicitação de Elevação",
                "jitDuration": "Duração (minutos)",
                "jitJustification": "Justificativa",
                "certificationPeriod": "Período de Certificação",
                "certificationStatus": "Status da Certificação"
            },
            "messages": {
                "success": {
                    "loginRecorded": "Login registrado com sucesso",
                    "actionLogged": "Ação registrada em auditoria",
                    "jitRequested": "Solicitação de elevação enviada para aprovação",
                    "certificationApproved": "Permissões certificadas"
                },
                "error": {
                    "ipBlocked": "Endereço IP está bloqueado",
                    "bruteForceDetected": "Múltiplas tentativas falhadas detectadas",
                    "sodViolation": "Violação de segregação de funções",
                    "unauthorizedAccess": "Acesso não autorizado a este recurso",
                    "anomalyDetected": "Comportamento anômalo detectado",
                    "mfaRequired": "Autenticação multi-fator é obrigatória"
                },
                "warning": {
                    "unusualActivity": "Atividade incomum detectada",
                    "highRiskAccess": "Acesso de alto risco",
                    "privilegedActionApproving": "Ação privilegiada requer aprovação"
                }
            },
            "validation": {
                "required": "Campo obrigatório",
                "invalidIP": "Endereço IP inválido",
                "invalidEmail": "Email inválido",
                "jitDurationTooLong": "Duração máxima é 4 horas",
                "passwordTooWeak": "Senha não atende requisitos mínimos"
            },
            "alerts": {
                "critical": "Crítico",
                "high": "Alto",
                "medium": "Médio",
                "low": "Baixo"
            },
            "dashboard": {
                "recentLogins": "Logins Recentes",
                "anomaliesDetected": "Anomalias Detectadas",
                "usersOnline": "Usuários Online",
                "securityAlerts": "Alertas de Segurança",
                "accessReview": "Revisão de Acessos",
                "complianceStatus": "Status de Conformidade"
            }
        }
    }
}
```

---

### 4.3 Auditoria

**Operações Auditadas**:

| Operação | Código | Dados Registrados |
|----------|--------|-------------------|
| Login bem-sucedido | `AUDIT_LOGIN_SUCCESS` | Email, IP, timestamp, dispositivo, navegador, geolocalização |
| Login falhado | `AUDIT_LOGIN_FAILURE` | Email, IP, timestamp, motivo, tentativa número |
| Criação de entidade | `AUDIT_ENTITY_CREATE` | Usuário, entidade, dados novos, timestamp, IP |
| Atualização de entidade | `AUDIT_ENTITY_UPDATE` | Usuário, entidade, dados antes/depois, timestamp, IP |
| Deleção de entidade | `AUDIT_ENTITY_DELETE` | Usuário, entidade, dados deletados, timestamp, IP |
| Aprovação | `AUDIT_APPROVAL` | Aprovador, entidade, decisão, motivo, timestamp |
| Elevação de privilégio | `AUDIT_PRIVILEGE_ELEVATION` | Usuário, duração, aprovador, timestamp |
| Mudança de permissão | `AUDIT_PERMISSION_CHANGE` | Usuário, permissão, ação (add/remove), timestamp |
| Acesso a dado sensível | `AUDIT_SENSITIVE_DATA_ACCESS` | Usuário, dado, timestamp, duração do acesso |
| Export de dados | `AUDIT_DATA_EXPORT` | Usuário, quantidade de registros, formato, timestamp |

**Retenção**: 10 anos (conforme LGPD Artigo 7 - Direitos do Titular, ISO 27001, SOX 404)

---

### 4.4 Controle de Acesso (RBAC)

**Permissões**:

| Permissão | Descrição | Perfis |
|-----------|-----------|--------|
| `audit:security:view` | Visualizar logs de segurança | Auditor, Gerente de Segurança, Admin |
| `audit:security:export` | Exportar logs para análise forense | Auditor, Investigador de Segurança |
| `audit:security:alert_manage` | Gerenciar alertas de segurança | Gerente de Segurança, SOC |
| `audit:permission:review` | Revisar e certificar permissões | Gerente, RH |
| `audit:permission:manage` | Atribuir/remover permissões | Admin de Sistema |
| `audit:privilege:request_elevation` | Solicitar elevação de privilégio | Qualquer usuário |
| `audit:privilege:approve_elevation` | Aprovar elevação de privilégio | Admin de Sistema |
| `audit:policy:manage` | Gerenciar políticas de segurança | Gerente de Segurança |
| `audit:anomaly:view` | Visualizar anomalias detectadas | Gerente de Segurança, Investigador |
| `audit:compliance:report` | Gerar relatórios de compliance | Auditor, Compliance Officer |

**Nota**: Permissões são validadas em runtime. Violação de SOD impede atribuição de permissões conflitantes.

---

## 5. ENDPOINTS DA API

### 5.1 CRUD Principal - Logs de Acesso

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| GET | `/api/audit/access-logs` | Listar logs de acesso com filtros | `audit:security:view` |
| GET | `/api/audit/access-logs/{id}` | Obter log de acesso por ID | `audit:security:view` |
| GET | `/api/audit/access-logs/by-user/{email}` | Logs de acesso de usuário específico | `audit:security:view` |
| GET | `/api/audit/access-logs/by-ip/{ip}` | Logs de acesso de IP específico | `audit:security:view` |
| GET | `/api/audit/access-logs/failed` | Listar apenas logins falhados | `audit:security:view` |

### 5.2 Operações Especiais - Detecção e Análise

| Método | Endpoint | Descrição | Permissão |
|--------|----------|-----------|-----------|
| POST | `/api/audit/anomalies/detect` | Disparar detecção de anomalias | `audit:anomaly:view` |
| GET | `/api/audit/anomalies` | Listar anomalias detectadas | `audit:anomaly:view` |
| POST | `/api/audit/sod/validate` | Validar segregação de funções | `audit:permission:manage` |
| GET | `/api/audit/sod/violations` | Listar violações de SOD | `audit:permission:manage` |
| POST | `/api/audit/certification/start` | Iniciar certificação trimestral | `audit:permission:review` |
| GET | `/api/audit/certification/{trimestre}/{ano}` | Obter status de certificação | `audit:permission:review` |
| POST | `/api/audit/privilege/request` | Solicitar elevação de privilégio | `audit:privilege:request_elevation` |
| POST | `/api/audit/privilege/{id}/approve` | Aprovar elevação de privilégio | `audit:privilege:approve_elevation` |
| GET | `/api/audit/dashboard` | Dashboard de segurança | `audit:security:view` |
| POST | `/api/audit/forensics/investigate` | Iniciar investigação forense | `audit:security:export` |
| POST | `/api/audit/forensics/export` | Exportar relatório forense | `audit:security:export` |
| POST | `/api/audit/alerts/acknowledge` | Reconhecer alerta de segurança | `audit:security:alert_manage` |
| GET | `/api/audit/compliance/report` | Gerar relatório de compliance | `audit:compliance:report` |

---

## 6. FLUXOS PRINCIPAIS

### 6.1 Fluxo de Login com Validação de Segurança

```
Usuário tenta fazer login
    |
    v
Validar IP contra lista negra/branca
    |
    +--- IP bloqueado? ---> Rejeitar (HTTP 403)
    |
    v (IP permitido)
Validar contra política de segurança (horário, localização, MFA)
    |
    +--- Viola política? ---> Rejeitar com motivo
    |
    v (Política OK)
Autenticar credenciais
    |
    +--- Senha incorreta? ---> Falha++, gerar log, verificar força bruta
    |
    v (Credenciais OK)
Verificar MFA se obrigatório
    |
    +--- MFA falhado? ---> Falha de login
    |
    v (MFA OK)
Registrar login bem-sucedido em log
    |
    v
Verificar UEBA para detectar anomalias
    |
    +--- Anomalia crítica detectada? ---> Gerar alerta, monitorar sessão
    |
    v
Criar sessão
    |
    v
Redirecionar para dashboard
```

### 6.2 Fluxo de Certificação Trimestral de Acessos

```
Sistema detecta início de novo trimestre
    |
    v
Criar certificação trimestral
    |
    v
Para cada gerente:
    |
    +-- Obter subordinados
    |
    +-- Para cada subordinado:
    |       |
    |       +-- Obter permissões ativas
    |       |
    |       +-- Enviar tarefa de revisão ao gerente
    |
    v
Aguardar respostas até data limite (30 dias)
    |
    +--- Gerente não responde? ---> Escalar para seu gestor
    |
    v
Gerente aprova/rejeita permissões
    |
    v
Registrar decisão em auditoria
    |
    v
Se rejeitado:
    |
    +-- Agendar revogação em 72 horas
    |
    v
Finalizar certificação
    |
    v
Gerar relatório de permissões removidas
```

### 6.3 Fluxo de Detecção de Comportamento Anômalo (UEBA)

```
Evento de acesso registrado (login, operação)
    |
    v
Extrair contexto: usuário, hora, IP, ação, dados
    |
    v
Comparar com padrão histórico (últimos 90 dias)
    |
    v
Checar desvios:
    |
    +--- Fora do horário normal? ---> Score += 0.3
    |
    +--- IP de país diferente? ---> Score += 0.3
    |
    +--- Volume 10x acima média? ---> Score += 0.2
    |
    +--- Acesso a dado fora do perfil? ---> Score += 0.2
    |
    v
Score > 0.7?
    |
    +--- SIM: Enviar para Azure ML para refinamento
    |
    v
Score ML > 0.8?
    |
    +--- SIM: Gerar alerta crítico para SOC
    |
    +--- NÃO: Gerar alerta médio para revisão
    |
    v
Registrar anomalia em banco de dados
```

### 6.4 Fluxo de Investigação Forense

```
Incidente de segurança reportado
    |
    v
Coletar período de investigação (data_inicio, data_fim)
    |
    v
Recuperar todos os logs no período:
    |
    +-- Logs de acesso
    +-- Logs de operação
    +-- Alertas de segurança
    |
    v
Correlacionar eventos por usuário, IP, entidade
    |
    v
Construir timeline ordenada por timestamp
    |
    v
Identificar causa raiz:
    |
    +--- Múltiplas falhas antes do acesso? ---> Força bruta
    +--- Acesso de IP suspeito? ---> Acesso não autorizado
    +--- Volume excessivo de deleções? ---> Possível sabotagem
    |
    v
Gerar relatório com recomendações
    |
    v
Exportar para formato CSV/JSON
    |
    v
Enviar para análise em Splunk/ELK
```

---

## 7. SEGURANÇA

### 7.1 Proteções Implementadas

| Proteção | Descrição |
|----------|-----------|
| **Criptografia em Repouso** | Logs armazenados com AES-256, chaves em Azure Key Vault |
| **Criptografia em Trânsito** | TLS 1.3 para todos os endpoints, HTTPS obrigatório |
| **Validação de IP** | Bloqueio automático de IPs suspeitos após múltiplas falhas |
| **Rate Limiting** | Máximo 10 requisições/minuto por IP para endpoints críticos |
| **RBAC (Role-Based Access Control)** | Acesso granular por permissão, validação em runtime |
| **Segregação de Funções (SOD)** | Bloqueio de permissões conflitantes em tempo real |
| **Auditoria Completa** | Todos os acessos e operações registrados imutavelmente |
| **Detecção de Anomalias** | UEBA + Azure ML para detecção de comportamentos suspeitos |
| **Just-In-Time Privilege** | Elevação temporária com aprovação dual-control |
| **Política de Segurança Centralizada** | Regras aplicadas em tempo real (MFA, senha, horário, localização) |
| **SIEM Integration** | Envio automático de logs para Azure Sentinel |
| **Backup e Replicação** | Backup diário, geo-redundância, retenção 10 anos |

### 7.2 Testes de Segurança Obrigatórios

- [ ] **SQL Injection em Filtros**: Tentar injetar SQL em filtros de data, IP, usuário
- [ ] **XSS em Exportação**: Verificar se caracteres especiais são escapados em CSV/JSON
- [ ] **CSRF Protection**: Validar tokens CSRF em POST/PUT/DELETE
- [ ] **Validação de Permissão**: Tentar acessar recursos sem permissão (esperado: 403)
- [ ] **Força Bruta**: 10 tentativas falhadas de login, verificar bloqueio automático
- [ ] **Rate Limiting**: >10 requisições/min, verificar throttling
- [ ] **Privilégio Elevado**: Tentar usar JIT sem aprovação (esperado: rejeição)
- [ ] **Segregação de Funções**: Tentar atribuir permissões conflitantes (esperado: erro SOD)
- [ ] **Criptografia**: Verificar dados em repouso (não em plaintext)
- [ ] **Audit Trail Imutabilidade**: Tentar alterar log histórico (esperado: erro)

---

## 8. MÉTRICAS E INDICADORES

### 8.1 KPIs

| KPI | Meta | Medição |
|-----|------|---------|
| **Taxa de Detecção de Anomalias** | ≥95% de comportamentos suspeitos detectados | Anomalias detectadas / Total de eventos suspeitos |
| **Tempo de Resposta a Alerta Crítico** | <5 minutos | Timestamp alerta - Timestamp ação SOC |
| **Taxa de Falha de Login** | <2% de tentativas falhadas (normal) | Logins falhados / Total de logins * 100 |
| **Cobertura de Certificação de Acessos** | 100% de usuários certificados trimestralmente | Usuários certificados / Total de usuários |
| **Conformidade de SOD** | 0% de violações ativas | Violações encontradas em validação |
| **Retenção de Logs** | 100% de logs mantidos por 10 anos | Logs arquivados / Total de logs gerados |
| **Disponibilidade do Dashboard** | ≥99.9% uptime | Tempo ativo / Tempo total |
| **Latência de Integração SIEM** | <1 minuto para recepção de evento | Tempo de envio - Tempo de recepção |

### 8.2 Alertas

| Alerta | Condição | Ação |
|--------|----------|------|
| **Força Bruta em Progresso** | ≥5 falhas de login em 15 min do mesmo IP | Bloquear IP por 60 min, notificar SOC |
| **Anomalia de Alto Risco** | UEBA score ≥0.8 | Monitorar sessão, escalar para investigação |
| **Violação de SOD** | Tentativa de atribuir permissão conflitante | Rejeitar operação, registrar em auditoria |
| **Acesso a Dado Sensível Não Autorizado** | Usuário sem permissão acessa dado sensível | Bloquear acesso, gerar alerta crítico |
| **Elevação de Privilégio Expirada** | JIT excede duração aprovada | Revogar privilégio automaticamente |
| **Certificação Pendente Não Cumprida** | Gerente não responde em 30 dias | Escalar para seu gestor, gerar relatório |
| **Tentativa de Acesso fora do Horário** | Admin tenta acessar fora das 09:00-18:00 | Bloquear acesso, exigir aprovação |
| **Armazenamento de Logs Crítico** | Hot storage >90% capacidade | Escalada para infraestrutura, agendar archive |

---

## 9. PRÓXIMOS PASSOS

1. **Modelo de Dados**: Criar [MD-RF095](./MD-RF095-Auditoria-Acesso-Seguranca.md)
   - Tabelas: LogAcesso, LogOperacao, Alerta, ElevacaoPrivilegio, Certificacao
   - Índices por DataHora, Email, IP, ClienteId
   - Constraints para integridade de dados
   - Auditoria de mudanças em tabelas críticas

2. **Casos de Uso**: Criar [UC-RF095](./UC-RF095-Auditoria-Acesso-Seguranca.md)
   - UC01: Registrar Tentativa de Login
   - UC02: Detectar Força Bruta
   - UC03: Analisar Anomalias de Comportamento
   - UC04: Validar Segregação de Funções
   - UC05: Iniciar Certificação Trimestral

3. **Implementação Backend**: Commands/Queries/Handlers (.NET 10)
   - `CreateLoginAuditCommand`
   - `DetectBruteForceQuery`
   - `AnalyzeUserBehaviorCommand` (integração Azure ML)
   - `GenerateForensicsReportQuery`
   - `SendSecurityAlertCommand` (integração Azure Sentinel)

4. **Implementação Frontend**: Telas Angular 19
   - Dashboard de Segurança (tempo real, filtros)
   - Visualizador de Logs (datatables, exportação)
   - Configurador de Políticas
   - Workflow de Certificação
   - Formulário de Solicitação JIT

5. **Testes**: Executar cenários documentados
   - Teste de força bruta (bloquear após 10 tentativas)
   - Teste de UEBA (detectar anomalia 100km em <1h)
   - Teste de SOD (rejeitar permissões conflitantes)
   - Teste de retenção (arquivar logs >90 dias)
   - Teste de exportação forense (CSV com 10k registros)

---

## CHANGELOG

| Versão | Data | Descrição | Autor |
|--------|------|-----------|-------|
| 1.0 | 2025-12-28 | Versão inicial - RF095 completo com 12 regras de negócio, 13 endpoints, integração SIEM | Claude Code |

---

**Última Atualização**: 2025-12-28
**Autor**: Claude Code (Anthropic)
**Revisão**: Pendente de validação em MD-RF095
