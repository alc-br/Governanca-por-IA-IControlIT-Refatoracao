#!/usr/bin/env python3
"""
CONTRACTUAL COVERAGE VALIDATOR

Validações obrigatórias:
1) UC cobre 100% do RF
2) UC NÃO cria comportamento fora do RF
3) RF possui UCs obrigatórios (UC00–UC04)
4) TC cobre 100% dos UCs (granular ou fallback)

Exit Codes Contratuais:
10 - RF não totalmente coberto por UC
11 - UC criou comportamento fora do RF
12 - UCs obrigatórios ausentes
20 - TC não cobre 100% dos UCs
0  - PASS (tudo conforme contrato)
"""

from __future__ import annotations
import argparse
import json
import sys
from typing import Any, Dict, List, Set, Tuple
import yaml

# -------------------------
# Utils
# -------------------------

def load_yaml(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}

def norm_id(x: str) -> str:
    return str(x).strip()

# -------------------------
# RF
# -------------------------

def collect_rf_items(rf: Dict[str, Any]) -> Tuple[Set[str], Dict[str, Dict[str, Any]]]:
    catalog = rf.get("catalog", {})
    all_items: Set[str] = set()
    meta: Dict[str, Dict[str, Any]] = {}

    for group, items in catalog.items():
        if not isinstance(items, list):
            continue
        for it in items:
            if not isinstance(it, dict):
                continue
            _id = norm_id(it.get("id", ""))
            if not _id:
                continue

            required = bool(it.get("required", True))
            meta[_id] = {
                "group": group,
                "title": it.get("title") or "",
                "description": it.get("description") or "",
                "required": required
            }
            all_items.add(_id)

    return all_items, meta

# -------------------------
# UC
# -------------------------

def collect_uc_coverage(uc: Dict[str, Any]):
    ucs = uc.get("ucs", []) or []

    rf_items_covered: Set[str] = set()
    uc_ids: Set[str] = set()
    uc_items_required: Set[str] = set()
    ucitem_meta: Dict[str, Dict[str, Any]] = {}

    for u in ucs:
        if not isinstance(u, dict):
            continue

        uc_id = norm_id(u.get("id", ""))
        if not uc_id:
            continue

        uc_ids.add(uc_id)

        covers = u.get("covers", {}) or {}
        for rid in covers.get("rf_items", []) or []:
            rf_items_covered.add(norm_id(rid))

        for item in covers.get("uc_items", []) or []:
            if not isinstance(item, dict):
                continue
            iid = norm_id(item.get("id", ""))
            if not iid:
                continue

            required = bool(item.get("required", True))
            ucitem_meta[iid] = {
                "uc_id": uc_id,
                "title": item.get("title") or "",
                "required": required
            }
            if required:
                uc_items_required.add(iid)

    return rf_items_covered, uc_ids, uc_items_required, ucitem_meta

# -------------------------
# TC
# -------------------------

def collect_tc_coverage(tc: Dict[str, Any]):
    test_cases = tc.get("test_cases", []) or []

    ucs_tested: Set[str] = set()
    uc_items_tested: Set[str] = set()

    for t in test_cases:
        if not isinstance(t, dict):
            continue

        uc_ref = t.get("uc_ref") or ""
        if uc_ref:
            ucs_tested.add(norm_id(uc_ref))

        covers = t.get("covers", {}) or {}
        for iid in covers.get("uc_items", []) or []:
            uc_items_tested.add(norm_id(iid))

    return ucs_tested, uc_items_tested

# -------------------------
# Exclusions
# -------------------------

def apply_exclusions(items: Set[str], exclusions: List[Dict[str, Any]]) -> Set[str]:
    remaining = set(items)
    for ex in exclusions or []:
        ex_id = norm_id(ex.get("id", ""))
        if ex_id in remaining:
            remaining.remove(ex_id)
    return remaining

# -------------------------
# Main
# -------------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--rf", required=True)
    ap.add_argument("--uc", required=True)
    ap.add_argument("--tc", required=False, default=None, help="Path to TC YAML file (optional)")
    ap.add_argument("--out", default="coverage-report.md")
    ap.add_argument("--out-json", default="coverage-report.json")
    args = ap.parse_args()

    rf = load_yaml(args.rf)
    uc = load_yaml(args.uc)
    tc = load_yaml(args.tc) if args.tc else {}

    # RF
    rf_all, rf_meta = collect_rf_items(rf)
    rf_required = {i for i in rf_all if rf_meta[i]["required"]}
    rf_required = apply_exclusions(
        rf_required,
        rf.get("exclusions", {}).get("rf_items", [])
    )

    # UC
    rf_items_covered, uc_ids, uc_items_required, ucitem_meta = collect_uc_coverage(uc)

    # CONTRATO: UCs obrigatórios
    MANDATORY_UCS = {"UC00", "UC01", "UC02", "UC03", "UC04"}
    missing_mandatory_ucs = MANDATORY_UCS - uc_ids

    # CONTRATO: UC não cria comportamento fora do RF
    uc_outside_rf = rf_items_covered - rf_required

    # TC
    ucs_tested, uc_items_tested = collect_tc_coverage(tc)

    # TC granular se existir
    use_granular = len(uc_items_required) > 0
    uc_items_required = apply_exclusions(
        uc_items_required,
        uc.get("exclusions", {}).get("uc_items", [])
    )

    if use_granular:
        tc_missing = uc_items_required - uc_items_tested
    else:
        tc_missing = uc_ids - ucs_tested

    # -------------------------
    # Report
    # -------------------------

    report = {
        "checks": {
            "uc_covers_rf": {
                "required": sorted(rf_required),
                "covered": sorted(rf_items_covered & rf_required),
                "missing": sorted(rf_required - rf_items_covered),
            },
            "uc_outside_rf": {
                "extra_items": sorted(uc_outside_rf),
            },
            "mandatory_ucs": {
                "required": sorted(MANDATORY_UCS),
                "present": sorted(uc_ids),
                "missing": sorted(missing_mandatory_ucs),
            },
            "tc_covers_uc": {
                "missing": sorted(tc_missing),
                "mode": "granular" if use_granular else "uc_only"
            }
        }
    }

    # -------------------------
    # Outputs
    # -------------------------

    with open(args.out_json, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)

    md = []
    md.append("# Coverage Report\n")

    md.append("## UC cobre 100% do RF")
    md.append(f"- Missing: {len(report['checks']['uc_covers_rf']['missing'])}")

    md.append("\n## UC não cria comportamento fora do RF")
    md.append(f"- Extra UC items: {len(report['checks']['uc_outside_rf']['extra_items'])}")

    md.append("\n## UCs obrigatórios")
    md.append(f"- Missing: {len(report['checks']['mandatory_ucs']['missing'])}")

    md.append("\n## TC cobre UCs")
    md.append(f"- Missing: {len(report['checks']['tc_covers_uc']['missing'])}")

    with open(args.out, "w", encoding="utf-8") as f:
        f.write("\n".join(md))

    # -------------------------
    # EXIT CODES CONTRATUAIS
    # -------------------------

    if missing_mandatory_ucs:
        sys.exit(12)

    if uc_outside_rf:
        sys.exit(11)

    if report["checks"]["uc_covers_rf"]["missing"]:
        sys.exit(10)

    # TC é opcional - só valida se foi fornecido
    if args.tc and tc_missing:
        sys.exit(20)

    sys.exit(0)

if __name__ == "__main__":
    main()
